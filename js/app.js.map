{"version":3,"sources":["webpack:///js/app.js","webpack:///webpack/bootstrap f6b06171e54967a3f49b","webpack:///./src/js/main.js","webpack:///./~/interact.js/interact.js"],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","id","loaded","call","m","c","p","_interopRequireDefault","obj","__esModule","default","_interactJs","_interactJs2","draggedDecorations","document","getElementById","decorationInteractable","draggable","inertia","onmove","event","target","x","parseFloat","getAttribute","dx","y","dy","style","transform","setAttribute","on","interaction","pointerIsDown","interacting","drawerDecoration","currentTarget","decoration","cloneNode","decorationPosition","getBoundingClientRect","top","left","appendChild","start","name","dropzone","accept","ondrop","relatedTarget","removeChild","classList","remove","ondragenter","add","ondragleave","realWindow","blank","isElement","o","_window","getWindow","window","test","Element","nodeType","nodeName","isWindow","thing","Window","isDocFrag","DocumentFragment","isArray","isObject","undefined","length","isFunction","splice","isNumber","isBool","isString","trySelector","value","querySelector","extend","dest","source","prop","pointerExtend","deprecated","vendor","prefixedPropREs","indexOf","copyCoords","src","page","client","timeStamp","setEventXY","targetObj","pointers","pointer","pointerAverage","getPageXY","tmpXY","getClientXY","Date","getTime","setEventDeltas","prev","cur","dt","Math","max","speed","hypot","vx","vy","isNativePointer","Event","supportsTouch","Touch","getXY","type","xy","isOperaMobile","scrollX","scrollY","getScrollXY","win","documentElement","scrollLeft","scrollTop","getPointerId","pointerId","identifier","getActualElement","element","SVGElementInstance","correspondingUseElement","node","rootNode","ownerDocument","defaultView","parentWindow","getElementClientRect","clientRect","SVGElement","getClientRects","right","bottom","width","height","getElementRect","isIOS7","scroll","getTouchPair","touches","changedTouches","average","pageX","pageY","clientX","clientY","screenX","screenY","i","touchBBox","minX","min","minY","maxX","maxY","touchDistance","deltaSource","defaultOptions","sourceX","sourceY","touchAngle","prevAngle","angle","atan","PI","dr","drClamped","getOriginXY","interactable","origin","options","parentElement","getRect","closest","_getQBezierValue","t","p1","p2","p3","iT","getQuadraticCurvePoint","startX","startY","cpX","cpY","endX","endY","position","easeOutQuad","b","d","nodeContains","parent","child","parentNode","selector","matchesSelector","host","inContext","_context","testIgnore","interactableElement","ignoreFrom","matchesUpTo","testAllow","allowFrom","checkAxis","axis","thisAxis","drag","checkSnap","action","snap","enabled","checkRestrict","restrict","checkAutoScroll","autoScroll","withinInteractionLimit","maxActions","maxPerElement","activeInteractions","targetCount","targetElementCount","len","interactions","otherAction","prepared","active","maxInteractions","indexOfDeepestElement","elements","n","deepestZone","index","deepestZoneParents","dropzoneParents","unshift","HTMLElement","SVGSVGElement","ownerSVGElement","parents","lastChild","previousSibling","Interaction","this","dropTarget","dropElement","prevDropTarget","prevDropElement","edges","matches","matchElements","inertiaStatus","smoothEnd","ending","startEvent","upCoords","xe","ye","sx","sy","t0","vx0","vys","duration","resumeDx","resumeDy","lambda_v0","one_ve_v0","Function","prototype","bind","boundInertiaFrame","inertiaFrame","boundSmoothEndFrame","smoothEndFrame","that","activeDrops","dropzones","rects","pointerIds","downTargets","downTimes","holdTimers","prevCoords","curCoords","startCoords","pointerDelta","downEvent","downPointer","_eventTarget","_curEventTarget","prevEvent","tapTime","prevTap","startOffset","restrictOffset","snapOffsets","gesture","startDistance","prevDistance","distance","scale","startAngle","snapStatus","realX","realY","snappedX","snappedY","targets","locked","changed","restrictStatus","restrictedX","restrictedY","restricted","pointerWasMoved","gesturing","dragging","resizing","resizeAxes","mouse","push","getInteractionFromPointer","eventType","eventTarget","mouseEvent","pointerType","allowResume","supportsPointerEvent","contains","doOnInteractions","method","path","curEventTarget","prevTouchTime","_updateEventTargets","InteractEvent","phase","related","starting","coords","relativePoints","range","elementRect","x0","y0","clientX0","clientY0","ctrlKey","altKey","shiftKey","metaKey","button","buttons","detail","zeroResumeDelta","resize","square","axes","box","ds","da","prevScale","velocityX","velocityY","atan2","overlap","up","down","swipe","velocity","preventOriginalDefault","originalEvent","preventDefault","getActionCursor","cursor","actionCursors","cursorKey","edgeNames","checkResizeEdge","rect","margin","defaultActionChecker","resizeEdges","shouldResize","actionIsEnabled","resizeOptions","edge","validateAction","actionName","delegateListener","useCapture","fakeEvent","delegated","delegatedEvents","selectors","context","contexts","listeners","j","delegateUseCapture","interact","interactables","get","Interactable","_element","_iEvents","Node","events","pEventTypes","pointerDown","move","pointerHover","_doc","documents","listenToDocument","set","warnOnce","message","warned","console","warn","apply","arguments","endAllInteractions","pointerEnd","doc","PointerEvent","MSPointerEvent","over","out","cancel","selectorDown","pointerMove","pointerOver","pointerOut","pointerUp","pointerCancel","autoScrollMove","frameElement","parentDoc","error","windowParentError","checkAndPreventDefault","useAttachEvent","currentAction","array","nodeList","ie8MatchesSelector","replace","prefixedMatchesSelector","limit","el","createTextNode","wrap","sqrt","dynamicDrop","base","actionChecker","styleCursor","dropChecker","manualStart","Infinity","drop","preserveAspectRatio","NaN","invert","perAction","endOnly","offsets","container","resistance","minSpeed","endSpeed","smoothEndDuration","_holdDuration","now","dtx","prevTimeX","dty","prevTimeY","scrollBy","isScrolling","cancelFrame","reqFrame","stop","DocumentTouch","navigator","userAgent","pointerMoveTolerance","all","atob","resizex","resizey","resizexy","resizetop","resizeleft","resizebottom","resizeright","resizetopleft","resizebottomright","resizetopright","resizebottomleft","wheelEvent","eventTypes","globalEvents","appName","match","platform","appVersion","requestAnimationFrame","cancelAnimationFrame","listener","elementIndex","typeCount","attachedListeners","supplied","wrapped","useCount","ret","listenerIndex","immediatePropagationStopped","srcElement","preventDef","stopPropagation","stopProp","stopImmediatePropagation","stopImmProp","addEvent","Boolean","removeEvent","hasOwnProperty","returnValue","cancelBubble","_elements","_targets","_attachedListeners","webkit","ptr","pushCurMatches","curMatches","curMatchElements","prevTargetElement","addPointer","elementInteractable","elementAction","getAction","forEachSelector","validateSelector","pushMatches","querySelectorAll","eventCopy","pointerIndex","setTimeout","pointerHold","collectEventTargets","forceAction","newAction","setModifications","preEnd","shouldMove","shouldSnap","shouldRestrict","setSnapping","setRestriction","setStartOffsets","snapOffset","offset","pageUp","clientUp","inertiaPosition","recordPointer","duplicateMove","clearTimeout","absX","abs","absY","targetAxis","thisInteraction","getDraggable","selectorInteractable","dragStart","dragEvent","fire","setActiveDrops","dropEvents","getDropEvents","activate","fireActiveDrops","dragMove","draggableElement","getDrop","leave","enter","resizeStart","resizeEvent","startRect","linkedEdges","_linkedEdges","resizeStartAspectRatio","resizeRects","current","previous","delta","deltaRect","resizeMove","invertible","originalEdges","swap","gestureStart","gestureEvent","gestureMove","isNaN","removePointer","ie8Dblclick","endEvent","inertiaOptions","pointerSpeed","inertiaPossible","endSnap","endRestrict","snapRestrict","vy0","v0","calcInertia","statusObject","useStatusXY","modifiedXe","modifiedYe","deactivate","collectDrops","drops","dropElements","currentElement","prevElement","dragElement","possibleDrops","validDrops","dropCheck","dropIndex","pointerEvent","dragLeave","prevDropzone","dragEnter","dragmove","clearTargets","lambda","te","progress","exp","quadPoint","collectSelectors","els","isSet","firePointers","interval","createNewDoubleTap","originalPointer","double","propagationStopped","doubleTap","matchElement","pageCoords","status","relIndex","relative","inRange","snapChanged","restriction","prevent","inertiaDur","log","innerWidth","innerHeight","interactionListeners","indexOfElement","callback","setOnEvents","phases","ondropactivate","ondropdeactivate","ondropmove","onstart","onend","oninertiastart","setPerAction","option","checker","dropped","dropOverlap","horizontal","vertical","dragRect","cx","cy","overlapArea","overlapRatio","newValue","resizable","squareResize","gesturable","actions","setOptions","thisOption","mode","createSnapGrid","gridOffset","grid","anchors","paths","elementOrigin","allActions","rectChecker","iEvent","onEvent","funcName","search","trim","split","off","eventList","matchFound","fn","useCap","methods","perActions","settings","setting","unset","enableDragging","enableResizing","enableGesturing","debug","downTime","getPointerAverage","getTouchBBox","getTouchDistance","getTouchAngle","newvalue","offsetX","offsetY","gridx","round","gridy","newX","newY","elems","lastTime","vendors","currTime","timeToCall"],"mappings":"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","file":"js/app.js","sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\t\n\tvar _interactJs = __webpack_require__(1);\n\t\n\tvar _interactJs2 = _interopRequireDefault(_interactJs);\n\t\n\t// This element will hold all dragged decorations\n\t__webpack_require__(2);\n\t\n\tvar draggedDecorations = document.getElementById('draggedDecorations');\n\t\n\tvar decorationInteractable = (0, _interactJs2['default'])('.dragged-decorations .decoration').draggable({\n\t  inertia: true,\n\t  // Rectangular shapes aren't precise enough :/\n\t  // restrict: {\n\t  //   restriction: document.querySelector('.christmas-tree'),\n\t  //   endOnly: true,\n\t  // },\n\t  onmove: function onmove(event) {\n\t    var target = event.target;\n\t    // keep the dragged position in the data-x/data-y attributes\n\t    var x = (parseFloat(target.getAttribute('data-x')) || 0) + event.dx;\n\t    var y = (parseFloat(target.getAttribute('data-y')) || 0) + event.dy;\n\t\n\t    // translate the element\n\t    // target.style.transform = 'translate(' + x + 'px, ' + y + 'px)';\n\t    target.style.transform = 'translate(' + x + 'px, ' + y + 'px)';\n\t\n\t    // update the position attributes\n\t    target.setAttribute('data-x', x);\n\t    target.setAttribute('data-y', y);\n\t  }\n\t});\n\t\n\tvar decorationDrawerInteractable = (0, _interactJs2['default'])('.decoration-drawer .decoration').on('move', function (event) {\n\t  var interaction = event.interaction;\n\t\n\t  if (interaction.pointerIsDown && !interaction.interacting()) {\n\t    var drawerDecoration = event.currentTarget;\n\t\n\t    // Create a clone of the decoration, which will actually be dragged around\n\t    var decoration = drawerDecoration.cloneNode(true);\n\t\n\t    // Get the position of the decoration in the drawer\n\t    var decorationPosition = drawerDecoration.getBoundingClientRect();\n\t\n\t    // Position the cloned decoration on top of the original\n\t    decoration.style.top = decorationPosition.top + 'px';\n\t    decoration.style.left = decorationPosition.left + 'px';\n\t\n\t    // Add the cloned decoration to the DOM\n\t    draggedDecorations.appendChild(decoration);\n\t\n\t    // Manually start a 'movedrag' event, for the newly cloned decoration\n\t    interaction.start({\n\t      name: 'drag'\n\t    }, decorationInteractable, decoration);\n\t  }\n\t});\n\t\n\tvar thrashCanInteractable = (0, _interactJs2['default'])('.thrash-can-container').dropzone({\n\t  accept: '.decoration',\n\t  ondrop: function ondrop(event) {\n\t    var decoration = event.relatedTarget;\n\t\n\t    // Thrash the decoration\n\t    draggedDecorations.removeChild(decoration);\n\t\n\t    // Close the thrash can\n\t    event.target.classList.remove('hovering');\n\t  },\n\t  ondragenter: function ondragenter(event) {\n\t    // Put the decoration and thrash can in the 'Will be removed' state\n\t    event.target.classList.add('hovering');\n\t    event.relatedTarget.classList.add('removable');\n\t  },\n\t  ondragleave: function ondragleave(event) {\n\t    // Remove the decoration and thrash from the'Will be removed' state\n\t    event.target.classList.remove('hovering');\n\t    event.relatedTarget.classList.remove('removable');\n\t  }\n\t});\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * interact.js v1.2.8\n\t *\n\t * Copyright (c) 2012-2015 Taye Adeyemi <dev@taye.me>\n\t * Open source under the MIT License.\n\t * https://raw.github.com/taye/interact.js/master/LICENSE\n\t */\n\t(function (realWindow) {\n\t    'use strict';\n\t\n\t    // return early if there's no window to work with (eg. Node.js)\n\t    if (!realWindow) { return; }\n\t\n\t    var // get wrapped window if using Shadow DOM polyfill\n\t        window = (function () {\n\t            // create a TextNode\n\t            var el = realWindow.document.createTextNode('');\n\t\n\t            // check if it's wrapped by a polyfill\n\t            if (el.ownerDocument !== realWindow.document\n\t                && typeof realWindow.wrap === 'function'\n\t                && realWindow.wrap(el) === el) {\n\t                // return wrapped window\n\t                return realWindow.wrap(realWindow);\n\t            }\n\t\n\t            // no Shadow DOM polyfil or native implementation\n\t            return realWindow;\n\t        }()),\n\t\n\t        document           = window.document,\n\t        DocumentFragment   = window.DocumentFragment   || blank,\n\t        SVGElement         = window.SVGElement         || blank,\n\t        SVGSVGElement      = window.SVGSVGElement      || blank,\n\t        SVGElementInstance = window.SVGElementInstance || blank,\n\t        HTMLElement        = window.HTMLElement        || window.Element,\n\t\n\t        PointerEvent = (window.PointerEvent || window.MSPointerEvent),\n\t        pEventTypes,\n\t\n\t        hypot = Math.hypot || function (x, y) { return Math.sqrt(x * x + y * y); },\n\t\n\t        tmpXY = {},     // reduce object creation in getXY()\n\t\n\t        documents       = [],   // all documents being listened to\n\t\n\t        interactables   = [],   // all set interactables\n\t        interactions    = [],   // all interactions\n\t\n\t        dynamicDrop     = false,\n\t\n\t        // {\n\t        //      type: {\n\t        //          selectors: ['selector', ...],\n\t        //          contexts : [document, ...],\n\t        //          listeners: [[listener, useCapture], ...]\n\t        //      }\n\t        //  }\n\t        delegatedEvents = {},\n\t\n\t        defaultOptions = {\n\t            base: {\n\t                accept        : null,\n\t                actionChecker : null,\n\t                styleCursor   : true,\n\t                preventDefault: 'auto',\n\t                origin        : { x: 0, y: 0 },\n\t                deltaSource   : 'page',\n\t                allowFrom     : null,\n\t                ignoreFrom    : null,\n\t                _context      : document,\n\t                dropChecker   : null\n\t            },\n\t\n\t            drag: {\n\t                enabled: false,\n\t                manualStart: true,\n\t                max: Infinity,\n\t                maxPerElement: 1,\n\t\n\t                snap: null,\n\t                restrict: null,\n\t                inertia: null,\n\t                autoScroll: null,\n\t\n\t                axis: 'xy'\n\t            },\n\t\n\t            drop: {\n\t                enabled: false,\n\t                accept: null,\n\t                overlap: 'pointer'\n\t            },\n\t\n\t            resize: {\n\t                enabled: false,\n\t                manualStart: false,\n\t                max: Infinity,\n\t                maxPerElement: 1,\n\t\n\t                snap: null,\n\t                restrict: null,\n\t                inertia: null,\n\t                autoScroll: null,\n\t\n\t                square: false,\n\t                preserveAspectRatio: false,\n\t                axis: 'xy',\n\t\n\t                // use default margin\n\t                margin: NaN,\n\t\n\t                // object with props left, right, top, bottom which are\n\t                // true/false values to resize when the pointer is over that edge,\n\t                // CSS selectors to match the handles for each direction\n\t                // or the Elements for each handle\n\t                edges: null,\n\t\n\t                // a value of 'none' will limit the resize rect to a minimum of 0x0\n\t                // 'negate' will alow the rect to have negative width/height\n\t                // 'reposition' will keep the width/height positive by swapping\n\t                // the top and bottom edges and/or swapping the left and right edges\n\t                invert: 'none'\n\t            },\n\t\n\t            gesture: {\n\t                manualStart: false,\n\t                enabled: false,\n\t                max: Infinity,\n\t                maxPerElement: 1,\n\t\n\t                restrict: null\n\t            },\n\t\n\t            perAction: {\n\t                manualStart: false,\n\t                max: Infinity,\n\t                maxPerElement: 1,\n\t\n\t                snap: {\n\t                    enabled     : false,\n\t                    endOnly     : false,\n\t                    range       : Infinity,\n\t                    targets     : null,\n\t                    offsets     : null,\n\t\n\t                    relativePoints: null\n\t                },\n\t\n\t                restrict: {\n\t                    enabled: false,\n\t                    endOnly: false\n\t                },\n\t\n\t                autoScroll: {\n\t                    enabled     : false,\n\t                    container   : null,     // the item that is scrolled (Window or HTMLElement)\n\t                    margin      : 60,\n\t                    speed       : 300       // the scroll speed in pixels per second\n\t                },\n\t\n\t                inertia: {\n\t                    enabled          : false,\n\t                    resistance       : 10,    // the lambda in exponential decay\n\t                    minSpeed         : 100,   // target speed must be above this for inertia to start\n\t                    endSpeed         : 10,    // the speed at which inertia is slow enough to stop\n\t                    allowResume      : true,  // allow resuming an action in inertia phase\n\t                    zeroResumeDelta  : true,  // if an action is resumed after launch, set dx/dy to 0\n\t                    smoothEndDuration: 300    // animate to snap/restrict endOnly if there's no inertia\n\t                }\n\t            },\n\t\n\t            _holdDuration: 600\n\t        },\n\t\n\t        // Things related to autoScroll\n\t        autoScroll = {\n\t            interaction: null,\n\t            i: null,    // the handle returned by window.setInterval\n\t            x: 0, y: 0, // Direction each pulse is to scroll in\n\t\n\t            // scroll the window by the values in scroll.x/y\n\t            scroll: function () {\n\t                var options = autoScroll.interaction.target.options[autoScroll.interaction.prepared.name].autoScroll,\n\t                    container = options.container || getWindow(autoScroll.interaction.element),\n\t                    now = new Date().getTime(),\n\t                    // change in time in seconds\n\t                    dtx = (now - autoScroll.prevTimeX) / 1000,\n\t                    dty = (now - autoScroll.prevTimeY) / 1000,\n\t                    vx, vy, sx, sy;\n\t\n\t                // displacement\n\t                if (options.velocity) {\n\t                  vx = options.velocity.x;\n\t                  vy = options.velocity.y;\n\t                }\n\t                else {\n\t                  vx = vy = options.speed\n\t                }\n\t \n\t                sx = vx * dtx;\n\t                sy = vy * dty;\n\t\n\t                if (sx >= 1 || sy >= 1) {\n\t                    if (isWindow(container)) {\n\t                        container.scrollBy(autoScroll.x * sx, autoScroll.y * sy);\n\t                    }\n\t                    else if (container) {\n\t                        container.scrollLeft += autoScroll.x * sx;\n\t                        container.scrollTop  += autoScroll.y * sy;\n\t                    }\n\t\n\t                    if (sx >=1) autoScroll.prevTimeX = now;\n\t                    if (sy >= 1) autoScroll.prevTimeY = now;\n\t                }\n\t\n\t                if (autoScroll.isScrolling) {\n\t                    cancelFrame(autoScroll.i);\n\t                    autoScroll.i = reqFrame(autoScroll.scroll);\n\t                }\n\t            },\n\t\n\t            isScrolling: false,\n\t            prevTimeX: 0,\n\t            prevTimeY: 0,\n\t\n\t            start: function (interaction) {\n\t                autoScroll.isScrolling = true;\n\t                cancelFrame(autoScroll.i);\n\t\n\t                autoScroll.interaction = interaction;\n\t                autoScroll.prevTimeX = new Date().getTime();\n\t                autoScroll.prevTimeY = new Date().getTime();\n\t                autoScroll.i = reqFrame(autoScroll.scroll);\n\t            },\n\t\n\t            stop: function () {\n\t                autoScroll.isScrolling = false;\n\t                cancelFrame(autoScroll.i);\n\t            }\n\t        },\n\t\n\t        // Does the browser support touch input?\n\t        supportsTouch = (('ontouchstart' in window) || window.DocumentTouch && document instanceof window.DocumentTouch),\n\t\n\t        // Does the browser support PointerEvents\n\t        // Avoid PointerEvent bugs introduced in Chrome 55\n\t        supportsPointerEvent = PointerEvent && !/Chrome/.test(navigator.userAgent),\n\t\n\t        // Less Precision with touch input\n\t        margin = supportsTouch || supportsPointerEvent? 20: 10,\n\t\n\t        pointerMoveTolerance = 1,\n\t\n\t        // for ignoring browser's simulated mouse events\n\t        prevTouchTime = 0,\n\t\n\t        // Allow this many interactions to happen simultaneously\n\t        maxInteractions = Infinity,\n\t\n\t        // Check if is IE9 or older\n\t        actionCursors = (document.all && !window.atob) ? {\n\t            drag    : 'move',\n\t            resizex : 'e-resize',\n\t            resizey : 's-resize',\n\t            resizexy: 'se-resize',\n\t\n\t            resizetop        : 'n-resize',\n\t            resizeleft       : 'w-resize',\n\t            resizebottom     : 's-resize',\n\t            resizeright      : 'e-resize',\n\t            resizetopleft    : 'se-resize',\n\t            resizebottomright: 'se-resize',\n\t            resizetopright   : 'ne-resize',\n\t            resizebottomleft : 'ne-resize',\n\t\n\t            gesture : ''\n\t        } : {\n\t            drag    : 'move',\n\t            resizex : 'ew-resize',\n\t            resizey : 'ns-resize',\n\t            resizexy: 'nwse-resize',\n\t\n\t            resizetop        : 'ns-resize',\n\t            resizeleft       : 'ew-resize',\n\t            resizebottom     : 'ns-resize',\n\t            resizeright      : 'ew-resize',\n\t            resizetopleft    : 'nwse-resize',\n\t            resizebottomright: 'nwse-resize',\n\t            resizetopright   : 'nesw-resize',\n\t            resizebottomleft : 'nesw-resize',\n\t\n\t            gesture : ''\n\t        },\n\t\n\t        actionIsEnabled = {\n\t            drag   : true,\n\t            resize : true,\n\t            gesture: true\n\t        },\n\t\n\t        // because Webkit and Opera still use 'mousewheel' event type\n\t        wheelEvent = 'onmousewheel' in document? 'mousewheel': 'wheel',\n\t\n\t        eventTypes = [\n\t            'dragstart',\n\t            'dragmove',\n\t            'draginertiastart',\n\t            'dragend',\n\t            'dragenter',\n\t            'dragleave',\n\t            'dropactivate',\n\t            'dropdeactivate',\n\t            'dropmove',\n\t            'drop',\n\t            'resizestart',\n\t            'resizemove',\n\t            'resizeinertiastart',\n\t            'resizeend',\n\t            'gesturestart',\n\t            'gesturemove',\n\t            'gestureinertiastart',\n\t            'gestureend',\n\t\n\t            'down',\n\t            'move',\n\t            'up',\n\t            'cancel',\n\t            'tap',\n\t            'doubletap',\n\t            'hold'\n\t        ],\n\t\n\t        globalEvents = {},\n\t\n\t        // Opera Mobile must be handled differently\n\t        isOperaMobile = navigator.appName == 'Opera' &&\n\t            supportsTouch &&\n\t            navigator.userAgent.match('Presto'),\n\t\n\t        // scrolling doesn't change the result of getClientRects on iOS 7\n\t        isIOS7 = (/iP(hone|od|ad)/.test(navigator.platform)\n\t                         && /OS 7[^\\d]/.test(navigator.appVersion)),\n\t\n\t        // prefix matchesSelector\n\t        prefixedMatchesSelector = 'matches' in Element.prototype?\n\t                'matches': 'webkitMatchesSelector' in Element.prototype?\n\t                    'webkitMatchesSelector': 'mozMatchesSelector' in Element.prototype?\n\t                        'mozMatchesSelector': 'oMatchesSelector' in Element.prototype?\n\t                            'oMatchesSelector': 'msMatchesSelector',\n\t\n\t        // will be polyfill function if browser is IE8\n\t        ie8MatchesSelector,\n\t\n\t        // native requestAnimationFrame or polyfill\n\t        reqFrame = realWindow.requestAnimationFrame,\n\t        cancelFrame = realWindow.cancelAnimationFrame,\n\t\n\t        // Events wrapper\n\t        events = (function () {\n\t            var useAttachEvent = ('attachEvent' in window) && !('addEventListener' in window),\n\t                addEvent       = useAttachEvent?  'attachEvent': 'addEventListener',\n\t                removeEvent    = useAttachEvent?  'detachEvent': 'removeEventListener',\n\t                on             = useAttachEvent? 'on': '',\n\t\n\t                elements          = [],\n\t                targets           = [],\n\t                attachedListeners = [];\n\t\n\t            function add (element, type, listener, useCapture) {\n\t                var elementIndex = indexOf(elements, element),\n\t                    target = targets[elementIndex];\n\t\n\t                if (!target) {\n\t                    target = {\n\t                        events: {},\n\t                        typeCount: 0\n\t                    };\n\t\n\t                    elementIndex = elements.push(element) - 1;\n\t                    targets.push(target);\n\t\n\t                    attachedListeners.push((useAttachEvent ? {\n\t                            supplied: [],\n\t                            wrapped : [],\n\t                            useCount: []\n\t                        } : null));\n\t                }\n\t\n\t                if (!target.events[type]) {\n\t                    target.events[type] = [];\n\t                    target.typeCount++;\n\t                }\n\t\n\t                if (!contains(target.events[type], listener)) {\n\t                    var ret;\n\t\n\t                    if (useAttachEvent) {\n\t                        var listeners = attachedListeners[elementIndex],\n\t                            listenerIndex = indexOf(listeners.supplied, listener);\n\t\n\t                        var wrapped = listeners.wrapped[listenerIndex] || function (event) {\n\t                            if (!event.immediatePropagationStopped) {\n\t                                event.target = event.srcElement;\n\t                                event.currentTarget = element;\n\t\n\t                                event.preventDefault = event.preventDefault || preventDef;\n\t                                event.stopPropagation = event.stopPropagation || stopProp;\n\t                                event.stopImmediatePropagation = event.stopImmediatePropagation || stopImmProp;\n\t\n\t                                if (/mouse|click/.test(event.type)) {\n\t                                    event.pageX = event.clientX + getWindow(element).document.documentElement.scrollLeft;\n\t                                    event.pageY = event.clientY + getWindow(element).document.documentElement.scrollTop;\n\t                                }\n\t\n\t                                listener(event);\n\t                            }\n\t                        };\n\t\n\t                        ret = element[addEvent](on + type, wrapped, Boolean(useCapture));\n\t\n\t                        if (listenerIndex === -1) {\n\t                            listeners.supplied.push(listener);\n\t                            listeners.wrapped.push(wrapped);\n\t                            listeners.useCount.push(1);\n\t                        }\n\t                        else {\n\t                            listeners.useCount[listenerIndex]++;\n\t                        }\n\t                    }\n\t                    else {\n\t                        ret = element[addEvent](type, listener, useCapture || false);\n\t                    }\n\t                    target.events[type].push(listener);\n\t\n\t                    return ret;\n\t                }\n\t            }\n\t\n\t            function remove (element, type, listener, useCapture) {\n\t                var i,\n\t                    elementIndex = indexOf(elements, element),\n\t                    target = targets[elementIndex],\n\t                    listeners,\n\t                    listenerIndex,\n\t                    wrapped = listener;\n\t\n\t                if (!target || !target.events) {\n\t                    return;\n\t                }\n\t\n\t                if (useAttachEvent) {\n\t                    listeners = attachedListeners[elementIndex];\n\t                    listenerIndex = indexOf(listeners.supplied, listener);\n\t                    wrapped = listeners.wrapped[listenerIndex];\n\t                }\n\t\n\t                if (type === 'all') {\n\t                    for (type in target.events) {\n\t                        if (target.events.hasOwnProperty(type)) {\n\t                            remove(element, type, 'all');\n\t                        }\n\t                    }\n\t                    return;\n\t                }\n\t\n\t                if (target.events[type]) {\n\t                    var len = target.events[type].length;\n\t\n\t                    if (listener === 'all') {\n\t                        for (i = 0; i < len; i++) {\n\t                            remove(element, type, target.events[type][i], Boolean(useCapture));\n\t                        }\n\t                        return;\n\t                    } else {\n\t                        for (i = 0; i < len; i++) {\n\t                            if (target.events[type][i] === listener) {\n\t                                element[removeEvent](on + type, wrapped, useCapture || false);\n\t                                target.events[type].splice(i, 1);\n\t\n\t                                if (useAttachEvent && listeners) {\n\t                                    listeners.useCount[listenerIndex]--;\n\t                                    if (listeners.useCount[listenerIndex] === 0) {\n\t                                        listeners.supplied.splice(listenerIndex, 1);\n\t                                        listeners.wrapped.splice(listenerIndex, 1);\n\t                                        listeners.useCount.splice(listenerIndex, 1);\n\t                                    }\n\t                                }\n\t\n\t                                break;\n\t                            }\n\t                        }\n\t                    }\n\t\n\t                    if (target.events[type] && target.events[type].length === 0) {\n\t                        target.events[type] = null;\n\t                        target.typeCount--;\n\t                    }\n\t                }\n\t\n\t                if (!target.typeCount) {\n\t                    targets.splice(elementIndex, 1);\n\t                    elements.splice(elementIndex, 1);\n\t                    attachedListeners.splice(elementIndex, 1);\n\t                }\n\t            }\n\t\n\t            function preventDef () {\n\t                this.returnValue = false;\n\t            }\n\t\n\t            function stopProp () {\n\t                this.cancelBubble = true;\n\t            }\n\t\n\t            function stopImmProp () {\n\t                this.cancelBubble = true;\n\t                this.immediatePropagationStopped = true;\n\t            }\n\t\n\t            return {\n\t                add: add,\n\t                remove: remove,\n\t                useAttachEvent: useAttachEvent,\n\t\n\t                _elements: elements,\n\t                _targets: targets,\n\t                _attachedListeners: attachedListeners\n\t            };\n\t        }());\n\t\n\t    function blank () {}\n\t\n\t    function isElement (o) {\n\t        if (!o || (typeof o !== 'object')) { return false; }\n\t\n\t        var _window = getWindow(o) || window;\n\t\n\t        return (/object|function/.test(typeof _window.Element)\n\t            ? o instanceof _window.Element //DOM2\n\t            : o.nodeType === 1 && typeof o.nodeName === \"string\");\n\t    }\n\t    function isWindow (thing) { return thing === window || !!(thing && thing.Window) && (thing instanceof thing.Window); }\n\t    function isDocFrag (thing) { return !!thing && thing instanceof DocumentFragment; }\n\t    function isArray (thing) {\n\t        return isObject(thing)\n\t                && (typeof thing.length !== undefined)\n\t                && isFunction(thing.splice);\n\t    }\n\t    function isObject   (thing) { return !!thing && (typeof thing === 'object'); }\n\t    function isFunction (thing) { return typeof thing === 'function'; }\n\t    function isNumber   (thing) { return typeof thing === 'number'  ; }\n\t    function isBool     (thing) { return typeof thing === 'boolean' ; }\n\t    function isString   (thing) { return typeof thing === 'string'  ; }\n\t\n\t    function trySelector (value) {\n\t        if (!isString(value)) { return false; }\n\t\n\t        // an exception will be raised if it is invalid\n\t        document.querySelector(value);\n\t        return true;\n\t    }\n\t\n\t    function extend (dest, source) {\n\t        for (var prop in source) {\n\t            dest[prop] = source[prop];\n\t        }\n\t        return dest;\n\t    }\n\t\n\t    var prefixedPropREs = {\n\t      webkit: /(Movement[XY]|Radius[XY]|RotationAngle|Force)$/\n\t    };\n\t\n\t    function pointerExtend (dest, source) {\n\t        for (var prop in source) {\n\t          var deprecated = false;\n\t\n\t          // skip deprecated prefixed properties\n\t          for (var vendor in prefixedPropREs) {\n\t            if (prop.indexOf(vendor) === 0 && prefixedPropREs[vendor].test(prop)) {\n\t              deprecated = true;\n\t              break;\n\t            }\n\t          }\n\t\n\t          if (!deprecated) {\n\t            dest[prop] = source[prop];\n\t          }\n\t        }\n\t        return dest;\n\t    }\n\t\n\t    function copyCoords (dest, src) {\n\t        dest.page = dest.page || {};\n\t        dest.page.x = src.page.x;\n\t        dest.page.y = src.page.y;\n\t\n\t        dest.client = dest.client || {};\n\t        dest.client.x = src.client.x;\n\t        dest.client.y = src.client.y;\n\t\n\t        dest.timeStamp = src.timeStamp;\n\t    }\n\t\n\t    function setEventXY (targetObj, pointers, interaction) {\n\t        var pointer = (pointers.length > 1\n\t                       ? pointerAverage(pointers)\n\t                       : pointers[0]);\n\t\n\t        getPageXY(pointer, tmpXY, interaction);\n\t        targetObj.page.x = tmpXY.x;\n\t        targetObj.page.y = tmpXY.y;\n\t\n\t        getClientXY(pointer, tmpXY, interaction);\n\t        targetObj.client.x = tmpXY.x;\n\t        targetObj.client.y = tmpXY.y;\n\t\n\t        targetObj.timeStamp = new Date().getTime();\n\t    }\n\t\n\t    function setEventDeltas (targetObj, prev, cur) {\n\t        targetObj.page.x     = cur.page.x      - prev.page.x;\n\t        targetObj.page.y     = cur.page.y      - prev.page.y;\n\t        targetObj.client.x   = cur.client.x    - prev.client.x;\n\t        targetObj.client.y   = cur.client.y    - prev.client.y;\n\t        targetObj.timeStamp = new Date().getTime() - prev.timeStamp;\n\t\n\t        // set pointer velocity\n\t        var dt = Math.max(targetObj.timeStamp / 1000, 0.001);\n\t        targetObj.page.speed   = hypot(targetObj.page.x, targetObj.page.y) / dt;\n\t        targetObj.page.vx      = targetObj.page.x / dt;\n\t        targetObj.page.vy      = targetObj.page.y / dt;\n\t\n\t        targetObj.client.speed = hypot(targetObj.client.x, targetObj.page.y) / dt;\n\t        targetObj.client.vx    = targetObj.client.x / dt;\n\t        targetObj.client.vy    = targetObj.client.y / dt;\n\t    }\n\t\n\t    function isNativePointer (pointer) {\n\t        return (pointer instanceof window.Event\n\t            || (supportsTouch && window.Touch && pointer instanceof window.Touch));\n\t    }\n\t\n\t    // Get specified X/Y coords for mouse or event.touches[0]\n\t    function getXY (type, pointer, xy) {\n\t        xy = xy || {};\n\t        type = type || 'page';\n\t\n\t        xy.x = pointer[type + 'X'];\n\t        xy.y = pointer[type + 'Y'];\n\t\n\t        return xy;\n\t    }\n\t\n\t    function getPageXY (pointer, page) {\n\t        page = page || {};\n\t\n\t        // Opera Mobile handles the viewport and scrolling oddly\n\t        if (isOperaMobile && isNativePointer(pointer)) {\n\t            getXY('screen', pointer, page);\n\t\n\t            page.x += window.scrollX;\n\t            page.y += window.scrollY;\n\t        }\n\t        else {\n\t            getXY('page', pointer, page);\n\t        }\n\t\n\t        return page;\n\t    }\n\t\n\t    function getClientXY (pointer, client) {\n\t        client = client || {};\n\t\n\t        if (isOperaMobile && isNativePointer(pointer)) {\n\t            // Opera Mobile handles the viewport and scrolling oddly\n\t            getXY('screen', pointer, client);\n\t        }\n\t        else {\n\t          getXY('client', pointer, client);\n\t        }\n\t\n\t        return client;\n\t    }\n\t\n\t    function getScrollXY (win) {\n\t        win = win || window;\n\t        return {\n\t            x: win.scrollX || win.document.documentElement.scrollLeft,\n\t            y: win.scrollY || win.document.documentElement.scrollTop\n\t        };\n\t    }\n\t\n\t    function getPointerId (pointer) {\n\t        return isNumber(pointer.pointerId)? pointer.pointerId : pointer.identifier;\n\t    }\n\t\n\t    function getActualElement (element) {\n\t        return (element instanceof SVGElementInstance\n\t            ? element.correspondingUseElement\n\t            : element);\n\t    }\n\t\n\t    function getWindow (node) {\n\t        if (isWindow(node)) {\n\t            return node;\n\t        }\n\t\n\t        var rootNode = (node.ownerDocument || node);\n\t\n\t        return rootNode.defaultView || rootNode.parentWindow || window;\n\t    }\n\t\n\t    function getElementClientRect (element) {\n\t        var clientRect = (element instanceof SVGElement\n\t                            ? element.getBoundingClientRect()\n\t                            : element.getClientRects()[0]);\n\t\n\t        return clientRect && {\n\t            left  : clientRect.left,\n\t            right : clientRect.right,\n\t            top   : clientRect.top,\n\t            bottom: clientRect.bottom,\n\t            width : clientRect.width || clientRect.right - clientRect.left,\n\t            height: clientRect.height || clientRect.bottom - clientRect.top\n\t        };\n\t    }\n\t\n\t    function getElementRect (element) {\n\t        var clientRect = getElementClientRect(element);\n\t\n\t        if (!isIOS7 && clientRect) {\n\t            var scroll = getScrollXY(getWindow(element));\n\t\n\t            clientRect.left   += scroll.x;\n\t            clientRect.right  += scroll.x;\n\t            clientRect.top    += scroll.y;\n\t            clientRect.bottom += scroll.y;\n\t        }\n\t\n\t        return clientRect;\n\t    }\n\t\n\t    function getTouchPair (event) {\n\t        var touches = [];\n\t\n\t        // array of touches is supplied\n\t        if (isArray(event)) {\n\t            touches[0] = event[0];\n\t            touches[1] = event[1];\n\t        }\n\t        // an event\n\t        else {\n\t            if (event.type === 'touchend') {\n\t                if (event.touches.length === 1) {\n\t                    touches[0] = event.touches[0];\n\t                    touches[1] = event.changedTouches[0];\n\t                }\n\t                else if (event.touches.length === 0) {\n\t                    touches[0] = event.changedTouches[0];\n\t                    touches[1] = event.changedTouches[1];\n\t                }\n\t            }\n\t            else {\n\t                touches[0] = event.touches[0];\n\t                touches[1] = event.touches[1];\n\t            }\n\t        }\n\t\n\t        return touches;\n\t    }\n\t\n\t    function pointerAverage (pointers) {\n\t        var average = {\n\t            pageX  : 0,\n\t            pageY  : 0,\n\t            clientX: 0,\n\t            clientY: 0,\n\t            screenX: 0,\n\t            screenY: 0\n\t        };\n\t        var prop;\n\t\n\t        for (var i = 0; i < pointers.length; i++) {\n\t            for (prop in average) {\n\t                average[prop] += pointers[i][prop];\n\t            }\n\t        }\n\t        for (prop in average) {\n\t            average[prop] /= pointers.length;\n\t        }\n\t\n\t        return average;\n\t    }\n\t\n\t    function touchBBox (event) {\n\t        if (!event.length && !(event.touches && event.touches.length > 1)) {\n\t            return;\n\t        }\n\t\n\t        var touches = getTouchPair(event),\n\t            minX = Math.min(touches[0].pageX, touches[1].pageX),\n\t            minY = Math.min(touches[0].pageY, touches[1].pageY),\n\t            maxX = Math.max(touches[0].pageX, touches[1].pageX),\n\t            maxY = Math.max(touches[0].pageY, touches[1].pageY);\n\t\n\t        return {\n\t            x: minX,\n\t            y: minY,\n\t            left: minX,\n\t            top: minY,\n\t            width: maxX - minX,\n\t            height: maxY - minY\n\t        };\n\t    }\n\t\n\t    function touchDistance (event, deltaSource) {\n\t        deltaSource = deltaSource || defaultOptions.deltaSource;\n\t\n\t        var sourceX = deltaSource + 'X',\n\t            sourceY = deltaSource + 'Y',\n\t            touches = getTouchPair(event);\n\t\n\t\n\t        var dx = touches[0][sourceX] - touches[1][sourceX],\n\t            dy = touches[0][sourceY] - touches[1][sourceY];\n\t\n\t        return hypot(dx, dy);\n\t    }\n\t\n\t    function touchAngle (event, prevAngle, deltaSource) {\n\t        deltaSource = deltaSource || defaultOptions.deltaSource;\n\t\n\t        var sourceX = deltaSource + 'X',\n\t            sourceY = deltaSource + 'Y',\n\t            touches = getTouchPair(event),\n\t            dx = touches[0][sourceX] - touches[1][sourceX],\n\t            dy = touches[0][sourceY] - touches[1][sourceY],\n\t            angle = 180 * Math.atan(dy / dx) / Math.PI;\n\t\n\t        if (isNumber(prevAngle)) {\n\t            var dr = angle - prevAngle,\n\t                drClamped = dr % 360;\n\t\n\t            if (drClamped > 315) {\n\t                angle -= 360 + (angle / 360)|0 * 360;\n\t            }\n\t            else if (drClamped > 135) {\n\t                angle -= 180 + (angle / 360)|0 * 360;\n\t            }\n\t            else if (drClamped < -315) {\n\t                angle += 360 + (angle / 360)|0 * 360;\n\t            }\n\t            else if (drClamped < -135) {\n\t                angle += 180 + (angle / 360)|0 * 360;\n\t            }\n\t        }\n\t\n\t        return  angle;\n\t    }\n\t\n\t    function getOriginXY (interactable, element) {\n\t        var origin = interactable\n\t                ? interactable.options.origin\n\t                : defaultOptions.origin;\n\t\n\t        if (origin === 'parent') {\n\t            origin = parentElement(element);\n\t        }\n\t        else if (origin === 'self') {\n\t            origin = interactable.getRect(element);\n\t        }\n\t        else if (trySelector(origin)) {\n\t            origin = closest(element, origin) || { x: 0, y: 0 };\n\t        }\n\t\n\t        if (isFunction(origin)) {\n\t            origin = origin(interactable && element);\n\t        }\n\t\n\t        if (isElement(origin))  {\n\t            origin = getElementRect(origin);\n\t        }\n\t\n\t        origin.x = ('x' in origin)? origin.x : origin.left;\n\t        origin.y = ('y' in origin)? origin.y : origin.top;\n\t\n\t        return origin;\n\t    }\n\t\n\t    // http://stackoverflow.com/a/5634528/2280888\n\t    function _getQBezierValue(t, p1, p2, p3) {\n\t        var iT = 1 - t;\n\t        return iT * iT * p1 + 2 * iT * t * p2 + t * t * p3;\n\t    }\n\t\n\t    function getQuadraticCurvePoint(startX, startY, cpX, cpY, endX, endY, position) {\n\t        return {\n\t            x:  _getQBezierValue(position, startX, cpX, endX),\n\t            y:  _getQBezierValue(position, startY, cpY, endY)\n\t        };\n\t    }\n\t\n\t    // http://gizma.com/easing/\n\t    function easeOutQuad (t, b, c, d) {\n\t        t /= d;\n\t        return -c * t*(t-2) + b;\n\t    }\n\t\n\t    function nodeContains (parent, child) {\n\t        while (child) {\n\t            if (child === parent) {\n\t                return true;\n\t            }\n\t\n\t            child = child.parentNode;\n\t        }\n\t\n\t        return false;\n\t    }\n\t\n\t    function closest (child, selector) {\n\t        var parent = parentElement(child);\n\t\n\t        while (isElement(parent)) {\n\t            if (matchesSelector(parent, selector)) { return parent; }\n\t\n\t            parent = parentElement(parent);\n\t        }\n\t\n\t        return null;\n\t    }\n\t\n\t    function parentElement (node) {\n\t        var parent = node.parentNode;\n\t\n\t        if (isDocFrag(parent)) {\n\t            // skip past #shado-root fragments\n\t            while ((parent = parent.host) && isDocFrag(parent)) {}\n\t\n\t            return parent;\n\t        }\n\t\n\t        return parent;\n\t    }\n\t\n\t    function inContext (interactable, element) {\n\t        return interactable._context === element.ownerDocument\n\t                || nodeContains(interactable._context, element);\n\t    }\n\t\n\t    function testIgnore (interactable, interactableElement, element) {\n\t        var ignoreFrom = interactable.options.ignoreFrom;\n\t\n\t        if (!ignoreFrom || !isElement(element)) { return false; }\n\t\n\t        if (isString(ignoreFrom)) {\n\t            return matchesUpTo(element, ignoreFrom, interactableElement);\n\t        }\n\t        else if (isElement(ignoreFrom)) {\n\t            return nodeContains(ignoreFrom, element);\n\t        }\n\t\n\t        return false;\n\t    }\n\t\n\t    function testAllow (interactable, interactableElement, element) {\n\t        var allowFrom = interactable.options.allowFrom;\n\t\n\t        if (!allowFrom) { return true; }\n\t\n\t        if (!isElement(element)) { return false; }\n\t\n\t        if (isString(allowFrom)) {\n\t            return matchesUpTo(element, allowFrom, interactableElement);\n\t        }\n\t        else if (isElement(allowFrom)) {\n\t            return nodeContains(allowFrom, element);\n\t        }\n\t\n\t        return false;\n\t    }\n\t\n\t    function checkAxis (axis, interactable) {\n\t        if (!interactable) { return false; }\n\t\n\t        var thisAxis = interactable.options.drag.axis;\n\t\n\t        return (axis === 'xy' || thisAxis === 'xy' || thisAxis === axis);\n\t    }\n\t\n\t    function checkSnap (interactable, action) {\n\t        var options = interactable.options;\n\t\n\t        if (/^resize/.test(action)) {\n\t            action = 'resize';\n\t        }\n\t\n\t        return options[action].snap && options[action].snap.enabled;\n\t    }\n\t\n\t    function checkRestrict (interactable, action) {\n\t        var options = interactable.options;\n\t\n\t        if (/^resize/.test(action)) {\n\t            action = 'resize';\n\t        }\n\t\n\t        return  options[action].restrict && options[action].restrict.enabled;\n\t    }\n\t\n\t    function checkAutoScroll (interactable, action) {\n\t        var options = interactable.options;\n\t\n\t        if (/^resize/.test(action)) {\n\t            action = 'resize';\n\t        }\n\t\n\t        return  options[action].autoScroll && options[action].autoScroll.enabled;\n\t    }\n\t\n\t    function withinInteractionLimit (interactable, element, action) {\n\t        var options = interactable.options,\n\t            maxActions = options[action.name].max,\n\t            maxPerElement = options[action.name].maxPerElement,\n\t            activeInteractions = 0,\n\t            targetCount = 0,\n\t            targetElementCount = 0;\n\t\n\t        for (var i = 0, len = interactions.length; i < len; i++) {\n\t            var interaction = interactions[i],\n\t                otherAction = interaction.prepared.name,\n\t                active = interaction.interacting();\n\t\n\t            if (!active) { continue; }\n\t\n\t            activeInteractions++;\n\t\n\t            if (activeInteractions >= maxInteractions) {\n\t                return false;\n\t            }\n\t\n\t            if (interaction.target !== interactable) { continue; }\n\t\n\t            targetCount += (otherAction === action.name)|0;\n\t\n\t            if (targetCount >= maxActions) {\n\t                return false;\n\t            }\n\t\n\t            if (interaction.element === element) {\n\t                targetElementCount++;\n\t\n\t                if (otherAction !== action.name || targetElementCount >= maxPerElement) {\n\t                    return false;\n\t                }\n\t            }\n\t        }\n\t\n\t        return maxInteractions > 0;\n\t    }\n\t\n\t    // Test for the element that's \"above\" all other qualifiers\n\t    function indexOfDeepestElement (elements) {\n\t        var dropzone,\n\t            deepestZone = elements[0],\n\t            index = deepestZone? 0: -1,\n\t            parent,\n\t            deepestZoneParents = [],\n\t            dropzoneParents = [],\n\t            child,\n\t            i,\n\t            n;\n\t\n\t        for (i = 1; i < elements.length; i++) {\n\t            dropzone = elements[i];\n\t\n\t            // an element might belong to multiple selector dropzones\n\t            if (!dropzone || dropzone === deepestZone) {\n\t                continue;\n\t            }\n\t\n\t            if (!deepestZone) {\n\t                deepestZone = dropzone;\n\t                index = i;\n\t                continue;\n\t            }\n\t\n\t            // check if the deepest or current are document.documentElement or document.rootElement\n\t            // - if the current dropzone is, do nothing and continue\n\t            if (dropzone.parentNode === dropzone.ownerDocument) {\n\t                continue;\n\t            }\n\t            // - if deepest is, update with the current dropzone and continue to next\n\t            else if (deepestZone.parentNode === dropzone.ownerDocument) {\n\t                deepestZone = dropzone;\n\t                index = i;\n\t                continue;\n\t            }\n\t\n\t            if (!deepestZoneParents.length) {\n\t                parent = deepestZone;\n\t                while (parent.parentNode && parent.parentNode !== parent.ownerDocument) {\n\t                    deepestZoneParents.unshift(parent);\n\t                    parent = parent.parentNode;\n\t                }\n\t            }\n\t\n\t            // if this element is an svg element and the current deepest is\n\t            // an HTMLElement\n\t            if (deepestZone instanceof HTMLElement\n\t                && dropzone instanceof SVGElement\n\t                && !(dropzone instanceof SVGSVGElement)) {\n\t\n\t                if (dropzone === deepestZone.parentNode) {\n\t                    continue;\n\t                }\n\t\n\t                parent = dropzone.ownerSVGElement;\n\t            }\n\t            else {\n\t                parent = dropzone;\n\t            }\n\t\n\t            dropzoneParents = [];\n\t\n\t            while (parent.parentNode !== parent.ownerDocument) {\n\t                dropzoneParents.unshift(parent);\n\t                parent = parent.parentNode;\n\t            }\n\t\n\t            n = 0;\n\t\n\t            // get (position of last common ancestor) + 1\n\t            while (dropzoneParents[n] && dropzoneParents[n] === deepestZoneParents[n]) {\n\t                n++;\n\t            }\n\t\n\t            var parents = [\n\t                dropzoneParents[n - 1],\n\t                dropzoneParents[n],\n\t                deepestZoneParents[n]\n\t            ];\n\t\n\t            child = parents[0].lastChild;\n\t\n\t            while (child) {\n\t                if (child === parents[1]) {\n\t                    deepestZone = dropzone;\n\t                    index = i;\n\t                    deepestZoneParents = [];\n\t\n\t                    break;\n\t                }\n\t                else if (child === parents[2]) {\n\t                    break;\n\t                }\n\t\n\t                child = child.previousSibling;\n\t            }\n\t        }\n\t\n\t        return index;\n\t    }\n\t\n\t    function Interaction () {\n\t        this.target          = null; // current interactable being interacted with\n\t        this.element         = null; // the target element of the interactable\n\t        this.dropTarget      = null; // the dropzone a drag target might be dropped into\n\t        this.dropElement     = null; // the element at the time of checking\n\t        this.prevDropTarget  = null; // the dropzone that was recently dragged away from\n\t        this.prevDropElement = null; // the element at the time of checking\n\t\n\t        this.prepared        = {     // action that's ready to be fired on next move event\n\t            name : null,\n\t            axis : null,\n\t            edges: null\n\t        };\n\t\n\t        this.matches         = [];   // all selectors that are matched by target element\n\t        this.matchElements   = [];   // corresponding elements\n\t\n\t        this.inertiaStatus = {\n\t            active       : false,\n\t            smoothEnd    : false,\n\t            ending       : false,\n\t\n\t            startEvent: null,\n\t            upCoords: {},\n\t\n\t            xe: 0, ye: 0,\n\t            sx: 0, sy: 0,\n\t\n\t            t0: 0,\n\t            vx0: 0, vys: 0,\n\t            duration: 0,\n\t\n\t            resumeDx: 0,\n\t            resumeDy: 0,\n\t\n\t            lambda_v0: 0,\n\t            one_ve_v0: 0,\n\t            i  : null\n\t        };\n\t\n\t        if (isFunction(Function.prototype.bind)) {\n\t            this.boundInertiaFrame = this.inertiaFrame.bind(this);\n\t            this.boundSmoothEndFrame = this.smoothEndFrame.bind(this);\n\t        }\n\t        else {\n\t            var that = this;\n\t\n\t            this.boundInertiaFrame = function () { return that.inertiaFrame(); };\n\t            this.boundSmoothEndFrame = function () { return that.smoothEndFrame(); };\n\t        }\n\t\n\t        this.activeDrops = {\n\t            dropzones: [],      // the dropzones that are mentioned below\n\t            elements : [],      // elements of dropzones that accept the target draggable\n\t            rects    : []       // the rects of the elements mentioned above\n\t        };\n\t\n\t        // keep track of added pointers\n\t        this.pointers    = [];\n\t        this.pointerIds  = [];\n\t        this.downTargets = [];\n\t        this.downTimes   = [];\n\t        this.holdTimers  = [];\n\t\n\t        // Previous native pointer move event coordinates\n\t        this.prevCoords = {\n\t            page     : { x: 0, y: 0 },\n\t            client   : { x: 0, y: 0 },\n\t            timeStamp: 0\n\t        };\n\t        // current native pointer move event coordinates\n\t        this.curCoords = {\n\t            page     : { x: 0, y: 0 },\n\t            client   : { x: 0, y: 0 },\n\t            timeStamp: 0\n\t        };\n\t\n\t        // Starting InteractEvent pointer coordinates\n\t        this.startCoords = {\n\t            page     : { x: 0, y: 0 },\n\t            client   : { x: 0, y: 0 },\n\t            timeStamp: 0\n\t        };\n\t\n\t        // Change in coordinates and time of the pointer\n\t        this.pointerDelta = {\n\t            page     : { x: 0, y: 0, vx: 0, vy: 0, speed: 0 },\n\t            client   : { x: 0, y: 0, vx: 0, vy: 0, speed: 0 },\n\t            timeStamp: 0\n\t        };\n\t\n\t        this.downEvent   = null;    // pointerdown/mousedown/touchstart event\n\t        this.downPointer = {};\n\t\n\t        this._eventTarget    = null;\n\t        this._curEventTarget = null;\n\t\n\t        this.prevEvent = null;      // previous action event\n\t        this.tapTime   = 0;         // time of the most recent tap event\n\t        this.prevTap   = null;\n\t\n\t        this.startOffset    = { left: 0, right: 0, top: 0, bottom: 0 };\n\t        this.restrictOffset = { left: 0, right: 0, top: 0, bottom: 0 };\n\t        this.snapOffsets    = [];\n\t\n\t        this.gesture = {\n\t            start: { x: 0, y: 0 },\n\t\n\t            startDistance: 0,   // distance between two touches of touchStart\n\t            prevDistance : 0,\n\t            distance     : 0,\n\t\n\t            scale: 1,           // gesture.distance / gesture.startDistance\n\t\n\t            startAngle: 0,      // angle of line joining two touches\n\t            prevAngle : 0       // angle of the previous gesture event\n\t        };\n\t\n\t        this.snapStatus = {\n\t            x       : 0, y       : 0,\n\t            dx      : 0, dy      : 0,\n\t            realX   : 0, realY   : 0,\n\t            snappedX: 0, snappedY: 0,\n\t            targets : [],\n\t            locked  : false,\n\t            changed : false\n\t        };\n\t\n\t        this.restrictStatus = {\n\t            dx         : 0, dy         : 0,\n\t            restrictedX: 0, restrictedY: 0,\n\t            snap       : null,\n\t            restricted : false,\n\t            changed    : false\n\t        };\n\t\n\t        this.restrictStatus.snap = this.snapStatus;\n\t\n\t        this.pointerIsDown   = false;\n\t        this.pointerWasMoved = false;\n\t        this.gesturing       = false;\n\t        this.dragging        = false;\n\t        this.resizing        = false;\n\t        this.resizeAxes      = 'xy';\n\t\n\t        this.mouse = false;\n\t\n\t        interactions.push(this);\n\t    }\n\t\n\t    Interaction.prototype = {\n\t        getPageXY  : function (pointer, xy) { return   getPageXY(pointer, xy, this); },\n\t        getClientXY: function (pointer, xy) { return getClientXY(pointer, xy, this); },\n\t        setEventXY : function (target, ptr) { return  setEventXY(target, ptr, this); },\n\t\n\t        pointerOver: function (pointer, event, eventTarget) {\n\t            if (this.prepared.name || !this.mouse) { return; }\n\t\n\t            var curMatches = [],\n\t                curMatchElements = [],\n\t                prevTargetElement = this.element;\n\t\n\t            this.addPointer(pointer);\n\t\n\t            if (this.target\n\t                && (testIgnore(this.target, this.element, eventTarget)\n\t                    || !testAllow(this.target, this.element, eventTarget))) {\n\t                // if the eventTarget should be ignored or shouldn't be allowed\n\t                // clear the previous target\n\t                this.target = null;\n\t                this.element = null;\n\t                this.matches = [];\n\t                this.matchElements = [];\n\t            }\n\t\n\t            var elementInteractable = interactables.get(eventTarget),\n\t                elementAction = (elementInteractable\n\t                                 && !testIgnore(elementInteractable, eventTarget, eventTarget)\n\t                                 && testAllow(elementInteractable, eventTarget, eventTarget)\n\t                                 && validateAction(\n\t                                     elementInteractable.getAction(pointer, event, this, eventTarget),\n\t                                     elementInteractable));\n\t\n\t            if (elementAction && !withinInteractionLimit(elementInteractable, eventTarget, elementAction)) {\n\t                 elementAction = null;\n\t            }\n\t\n\t            function pushCurMatches (interactable, selector) {\n\t                if (interactable\n\t                    && inContext(interactable, eventTarget)\n\t                    && !testIgnore(interactable, eventTarget, eventTarget)\n\t                    && testAllow(interactable, eventTarget, eventTarget)\n\t                    && matchesSelector(eventTarget, selector)) {\n\t\n\t                    curMatches.push(interactable);\n\t                    curMatchElements.push(eventTarget);\n\t                }\n\t            }\n\t\n\t            if (elementAction) {\n\t                this.target = elementInteractable;\n\t                this.element = eventTarget;\n\t                this.matches = [];\n\t                this.matchElements = [];\n\t            }\n\t            else {\n\t                interactables.forEachSelector(pushCurMatches);\n\t\n\t                if (this.validateSelector(pointer, event, curMatches, curMatchElements)) {\n\t                    this.matches = curMatches;\n\t                    this.matchElements = curMatchElements;\n\t\n\t                    this.pointerHover(pointer, event, this.matches, this.matchElements);\n\t                    events.add(eventTarget,\n\t                                        supportsPointerEvent? pEventTypes.move : 'mousemove',\n\t                                        listeners.pointerHover);\n\t                }\n\t                else if (this.target) {\n\t                    if (nodeContains(prevTargetElement, eventTarget)) {\n\t                        this.pointerHover(pointer, event, this.matches, this.matchElements);\n\t                        events.add(this.element,\n\t                                            supportsPointerEvent? pEventTypes.move : 'mousemove',\n\t                                            listeners.pointerHover);\n\t                    }\n\t                    else {\n\t                        this.target = null;\n\t                        this.element = null;\n\t                        this.matches = [];\n\t                        this.matchElements = [];\n\t                    }\n\t                }\n\t            }\n\t        },\n\t\n\t        // Check what action would be performed on pointerMove target if a mouse\n\t        // button were pressed and change the cursor accordingly\n\t        pointerHover: function (pointer, event, eventTarget, curEventTarget, matches, matchElements) {\n\t            var target = this.target;\n\t\n\t            if (!this.prepared.name && this.mouse) {\n\t\n\t                var action;\n\t\n\t                // update pointer coords for defaultActionChecker to use\n\t                this.setEventXY(this.curCoords, [pointer]);\n\t\n\t                if (matches) {\n\t                    action = this.validateSelector(pointer, event, matches, matchElements);\n\t                }\n\t                else if (target) {\n\t                    action = validateAction(target.getAction(this.pointers[0], event, this, this.element), this.target);\n\t                }\n\t\n\t                if (target && target.options.styleCursor) {\n\t                    if (action) {\n\t                        target._doc.documentElement.style.cursor = getActionCursor(action);\n\t                    }\n\t                    else {\n\t                        target._doc.documentElement.style.cursor = '';\n\t                    }\n\t                }\n\t            }\n\t            else if (this.prepared.name) {\n\t                this.checkAndPreventDefault(event, target, this.element);\n\t            }\n\t        },\n\t\n\t        pointerOut: function (pointer, event, eventTarget) {\n\t            if (this.prepared.name) { return; }\n\t\n\t            // Remove temporary event listeners for selector Interactables\n\t            if (!interactables.get(eventTarget)) {\n\t                events.remove(eventTarget,\n\t                                       supportsPointerEvent? pEventTypes.move : 'mousemove',\n\t                                       listeners.pointerHover);\n\t            }\n\t\n\t            if (this.target && this.target.options.styleCursor && !this.interacting()) {\n\t                this.target._doc.documentElement.style.cursor = '';\n\t            }\n\t        },\n\t\n\t        selectorDown: function (pointer, event, eventTarget, curEventTarget) {\n\t            var that = this,\n\t                // copy event to be used in timeout for IE8\n\t                eventCopy = events.useAttachEvent? extend({}, event) : event,\n\t                element = eventTarget,\n\t                pointerIndex = this.addPointer(pointer),\n\t                action;\n\t\n\t            this.holdTimers[pointerIndex] = setTimeout(function () {\n\t                that.pointerHold(events.useAttachEvent? eventCopy : pointer, eventCopy, eventTarget, curEventTarget);\n\t            }, defaultOptions._holdDuration);\n\t\n\t            this.pointerIsDown = true;\n\t\n\t            // Check if the down event hits the current inertia target\n\t            if (this.inertiaStatus.active && this.target.selector) {\n\t                // climb up the DOM tree from the event target\n\t                while (isElement(element)) {\n\t\n\t                    // if this element is the current inertia target element\n\t                    if (element === this.element\n\t                        // and the prospective action is the same as the ongoing one\n\t                        && validateAction(this.target.getAction(pointer, event, this, this.element), this.target).name === this.prepared.name) {\n\t\n\t                        // stop inertia so that the next move will be a normal one\n\t                        cancelFrame(this.inertiaStatus.i);\n\t                        this.inertiaStatus.active = false;\n\t\n\t                        this.collectEventTargets(pointer, event, eventTarget, 'down');\n\t                        return;\n\t                    }\n\t                    element = parentElement(element);\n\t                }\n\t            }\n\t\n\t            // do nothing if interacting\n\t            if (this.interacting()) {\n\t                this.collectEventTargets(pointer, event, eventTarget, 'down');\n\t                return;\n\t            }\n\t\n\t            function pushMatches (interactable, selector, context) {\n\t                var elements = ie8MatchesSelector\n\t                    ? context.querySelectorAll(selector)\n\t                    : undefined;\n\t\n\t                if (inContext(interactable, element)\n\t                    && !testIgnore(interactable, element, eventTarget)\n\t                    && testAllow(interactable, element, eventTarget)\n\t                    && matchesSelector(element, selector, elements)) {\n\t\n\t                    that.matches.push(interactable);\n\t                    that.matchElements.push(element);\n\t                }\n\t            }\n\t\n\t            // update pointer coords for defaultActionChecker to use\n\t            this.setEventXY(this.curCoords, [pointer]);\n\t            this.downEvent = event;\n\t\n\t            while (isElement(element) && !action) {\n\t                this.matches = [];\n\t                this.matchElements = [];\n\t\n\t                interactables.forEachSelector(pushMatches);\n\t\n\t                action = this.validateSelector(pointer, event, this.matches, this.matchElements);\n\t                element = parentElement(element);\n\t            }\n\t\n\t            if (action) {\n\t                this.prepared.name  = action.name;\n\t                this.prepared.axis  = action.axis;\n\t                this.prepared.edges = action.edges;\n\t\n\t                this.collectEventTargets(pointer, event, eventTarget, 'down');\n\t\n\t                return this.pointerDown(pointer, event, eventTarget, curEventTarget, action);\n\t            }\n\t            else {\n\t                // do these now since pointerDown isn't being called from here\n\t                this.downTimes[pointerIndex] = new Date().getTime();\n\t                this.downTargets[pointerIndex] = eventTarget;\n\t                pointerExtend(this.downPointer, pointer);\n\t\n\t                copyCoords(this.prevCoords, this.curCoords);\n\t                this.pointerWasMoved = false;\n\t            }\n\t\n\t            this.collectEventTargets(pointer, event, eventTarget, 'down');\n\t        },\n\t\n\t        // Determine action to be performed on next pointerMove and add appropriate\n\t        // style and event Listeners\n\t        pointerDown: function (pointer, event, eventTarget, curEventTarget, forceAction) {\n\t            if (!forceAction && !this.inertiaStatus.active && this.pointerWasMoved && this.prepared.name) {\n\t                this.checkAndPreventDefault(event, this.target, this.element);\n\t\n\t                return;\n\t            }\n\t\n\t            this.pointerIsDown = true;\n\t            this.downEvent = event;\n\t\n\t            var pointerIndex = this.addPointer(pointer),\n\t                action;\n\t\n\t            // If it is the second touch of a multi-touch gesture, keep the\n\t            // target the same and get a new action if a target was set by the\n\t            // first touch\n\t            if (this.pointerIds.length > 1 && this.target._element === this.element) {\n\t                var newAction = validateAction(forceAction || this.target.getAction(pointer, event, this, this.element), this.target);\n\t\n\t                if (withinInteractionLimit(this.target, this.element, newAction)) {\n\t                    action = newAction;\n\t                }\n\t\n\t                this.prepared.name = null;\n\t            }\n\t            // Otherwise, set the target if there is no action prepared\n\t            else if (!this.prepared.name) {\n\t                var interactable = interactables.get(curEventTarget);\n\t\n\t                if (interactable\n\t                    && !testIgnore(interactable, curEventTarget, eventTarget)\n\t                    && testAllow(interactable, curEventTarget, eventTarget)\n\t                    && (action = validateAction(forceAction || interactable.getAction(pointer, event, this, curEventTarget), interactable, eventTarget))\n\t                    && withinInteractionLimit(interactable, curEventTarget, action)) {\n\t                    this.target = interactable;\n\t                    this.element = curEventTarget;\n\t                }\n\t            }\n\t\n\t            var target = this.target,\n\t                options = target && target.options;\n\t\n\t            if (target && (forceAction || !this.prepared.name)) {\n\t                action = action || validateAction(forceAction || target.getAction(pointer, event, this, curEventTarget), target, this.element);\n\t\n\t                this.setEventXY(this.startCoords, this.pointers);\n\t\n\t                if (!action) { return; }\n\t\n\t                if (options.styleCursor) {\n\t                    target._doc.documentElement.style.cursor = getActionCursor(action);\n\t                }\n\t\n\t                this.resizeAxes = action.name === 'resize'? action.axis : null;\n\t\n\t                if (action === 'gesture' && this.pointerIds.length < 2) {\n\t                    action = null;\n\t                }\n\t\n\t                this.prepared.name  = action.name;\n\t                this.prepared.axis  = action.axis;\n\t                this.prepared.edges = action.edges;\n\t\n\t                this.snapStatus.snappedX = this.snapStatus.snappedY =\n\t                    this.restrictStatus.restrictedX = this.restrictStatus.restrictedY = NaN;\n\t\n\t                this.downTimes[pointerIndex] = new Date().getTime();\n\t                this.downTargets[pointerIndex] = eventTarget;\n\t                pointerExtend(this.downPointer, pointer);\n\t\n\t                copyCoords(this.prevCoords, this.startCoords);\n\t                this.pointerWasMoved = false;\n\t\n\t                this.checkAndPreventDefault(event, target, this.element);\n\t            }\n\t            // if inertia is active try to resume action\n\t            else if (this.inertiaStatus.active\n\t                && curEventTarget === this.element\n\t                && validateAction(target.getAction(pointer, event, this, this.element), target).name === this.prepared.name) {\n\t\n\t                cancelFrame(this.inertiaStatus.i);\n\t                this.inertiaStatus.active = false;\n\t\n\t                this.checkAndPreventDefault(event, target, this.element);\n\t            }\n\t        },\n\t\n\t        setModifications: function (coords, preEnd) {\n\t            var target         = this.target,\n\t                shouldMove     = true,\n\t                shouldSnap     = checkSnap(target, this.prepared.name)     && (!target.options[this.prepared.name].snap.endOnly     || preEnd),\n\t                shouldRestrict = checkRestrict(target, this.prepared.name) && (!target.options[this.prepared.name].restrict.endOnly || preEnd);\n\t\n\t            if (shouldSnap    ) { this.setSnapping   (coords); } else { this.snapStatus    .locked     = false; }\n\t            if (shouldRestrict) { this.setRestriction(coords); } else { this.restrictStatus.restricted = false; }\n\t\n\t            if (shouldSnap && this.snapStatus.locked && !this.snapStatus.changed) {\n\t                shouldMove = shouldRestrict && this.restrictStatus.restricted && this.restrictStatus.changed;\n\t            }\n\t            else if (shouldRestrict && this.restrictStatus.restricted && !this.restrictStatus.changed) {\n\t                shouldMove = false;\n\t            }\n\t\n\t            return shouldMove;\n\t        },\n\t\n\t        setStartOffsets: function (action, interactable, element) {\n\t            var rect = interactable.getRect(element),\n\t                origin = getOriginXY(interactable, element),\n\t                snap = interactable.options[this.prepared.name].snap,\n\t                restrict = interactable.options[this.prepared.name].restrict,\n\t                width, height;\n\t\n\t            if (rect) {\n\t                this.startOffset.left = this.startCoords.page.x - rect.left;\n\t                this.startOffset.top  = this.startCoords.page.y - rect.top;\n\t\n\t                this.startOffset.right  = rect.right  - this.startCoords.page.x;\n\t                this.startOffset.bottom = rect.bottom - this.startCoords.page.y;\n\t\n\t                if ('width' in rect) { width = rect.width; }\n\t                else { width = rect.right - rect.left; }\n\t                if ('height' in rect) { height = rect.height; }\n\t                else { height = rect.bottom - rect.top; }\n\t            }\n\t            else {\n\t                this.startOffset.left = this.startOffset.top = this.startOffset.right = this.startOffset.bottom = 0;\n\t            }\n\t\n\t            this.snapOffsets.splice(0);\n\t\n\t            var snapOffset = snap && snap.offset === 'startCoords'\n\t                                ? {\n\t                                    x: this.startCoords.page.x - origin.x,\n\t                                    y: this.startCoords.page.y - origin.y\n\t                                }\n\t                                : snap && snap.offset || { x: 0, y: 0 };\n\t\n\t            if (rect && snap && snap.relativePoints && snap.relativePoints.length) {\n\t                for (var i = 0; i < snap.relativePoints.length; i++) {\n\t                    this.snapOffsets.push({\n\t                        x: this.startOffset.left - (width  * snap.relativePoints[i].x) + snapOffset.x,\n\t                        y: this.startOffset.top  - (height * snap.relativePoints[i].y) + snapOffset.y\n\t                    });\n\t                }\n\t            }\n\t            else {\n\t                this.snapOffsets.push(snapOffset);\n\t            }\n\t\n\t            if (rect && restrict.elementRect) {\n\t                this.restrictOffset.left = this.startOffset.left - (width  * restrict.elementRect.left);\n\t                this.restrictOffset.top  = this.startOffset.top  - (height * restrict.elementRect.top);\n\t\n\t                this.restrictOffset.right  = this.startOffset.right  - (width  * (1 - restrict.elementRect.right));\n\t                this.restrictOffset.bottom = this.startOffset.bottom - (height * (1 - restrict.elementRect.bottom));\n\t            }\n\t            else {\n\t                this.restrictOffset.left = this.restrictOffset.top = this.restrictOffset.right = this.restrictOffset.bottom = 0;\n\t            }\n\t        },\n\t\n\t        /*\\\n\t         * Interaction.start\n\t         [ method ]\n\t         *\n\t         * Start an action with the given Interactable and Element as tartgets. The\n\t         * action must be enabled for the target Interactable and an appropriate number\n\t         * of pointers must be held down  1 for drag/resize, 2 for gesture.\n\t         *\n\t         * Use it with `interactable.<action>able({ manualStart: false })` to always\n\t         * [start actions manually](https://github.com/taye/interact.js/issues/114)\n\t         *\n\t         - action       (object)  The action to be performed - drag, resize, etc.\n\t         - interactable (Interactable) The Interactable to target\n\t         - element      (Element) The DOM Element to target\n\t         = (object) interact\n\t         **\n\t         | interact(target)\n\t         |   .draggable({\n\t         |     // disable the default drag start by down->move\n\t         |     manualStart: true\n\t         |   })\n\t         |   // start dragging after the user holds the pointer down\n\t         |   .on('hold', function (event) {\n\t         |     var interaction = event.interaction;\n\t         |\n\t         |     if (!interaction.interacting()) {\n\t         |       interaction.start({ name: 'drag' },\n\t         |                         event.interactable,\n\t         |                         event.currentTarget);\n\t         |     }\n\t         | });\n\t        \\*/\n\t        start: function (action, interactable, element) {\n\t            if (this.interacting()\n\t                || !this.pointerIsDown\n\t                || this.pointerIds.length < (action.name === 'gesture'? 2 : 1)) {\n\t                return;\n\t            }\n\t\n\t            // if this interaction had been removed after stopping\n\t            // add it back\n\t            if (indexOf(interactions, this) === -1) {\n\t                interactions.push(this);\n\t            }\n\t\n\t            // set the startCoords if there was no prepared action\n\t            if (!this.prepared.name) {\n\t                this.setEventXY(this.startCoords, this.pointers);\n\t            }\n\t\n\t            this.prepared.name  = action.name;\n\t            this.prepared.axis  = action.axis;\n\t            this.prepared.edges = action.edges;\n\t            this.target         = interactable;\n\t            this.element        = element;\n\t\n\t            this.setStartOffsets(action.name, interactable, element);\n\t            this.setModifications(this.startCoords.page);\n\t\n\t            this.prevEvent = this[this.prepared.name + 'Start'](this.downEvent);\n\t        },\n\t\n\t        pointerMove: function (pointer, event, eventTarget, curEventTarget, preEnd) {\n\t            if (this.inertiaStatus.active) {\n\t                var pageUp   = this.inertiaStatus.upCoords.page;\n\t                var clientUp = this.inertiaStatus.upCoords.client;\n\t\n\t                var inertiaPosition = {\n\t                    pageX  : pageUp.x   + this.inertiaStatus.sx,\n\t                    pageY  : pageUp.y   + this.inertiaStatus.sy,\n\t                    clientX: clientUp.x + this.inertiaStatus.sx,\n\t                    clientY: clientUp.y + this.inertiaStatus.sy\n\t                };\n\t\n\t                this.setEventXY(this.curCoords, [inertiaPosition]);\n\t            }\n\t            else {\n\t                this.recordPointer(pointer);\n\t                this.setEventXY(this.curCoords, this.pointers);\n\t            }\n\t\n\t            var duplicateMove = (this.curCoords.page.x === this.prevCoords.page.x\n\t                                 && this.curCoords.page.y === this.prevCoords.page.y\n\t                                 && this.curCoords.client.x === this.prevCoords.client.x\n\t                                 && this.curCoords.client.y === this.prevCoords.client.y);\n\t\n\t            var dx, dy,\n\t                pointerIndex = this.mouse? 0 : indexOf(this.pointerIds, getPointerId(pointer));\n\t\n\t            // register movement greater than pointerMoveTolerance\n\t            if (this.pointerIsDown && !this.pointerWasMoved) {\n\t                dx = this.curCoords.client.x - this.startCoords.client.x;\n\t                dy = this.curCoords.client.y - this.startCoords.client.y;\n\t\n\t                this.pointerWasMoved = hypot(dx, dy) > pointerMoveTolerance;\n\t            }\n\t\n\t            if (!duplicateMove && (!this.pointerIsDown || this.pointerWasMoved)) {\n\t                if (this.pointerIsDown) {\n\t                    clearTimeout(this.holdTimers[pointerIndex]);\n\t                }\n\t\n\t                this.collectEventTargets(pointer, event, eventTarget, 'move');\n\t            }\n\t\n\t            if (!this.pointerIsDown) { return; }\n\t\n\t            if (duplicateMove && this.pointerWasMoved && !preEnd) {\n\t                this.checkAndPreventDefault(event, this.target, this.element);\n\t                return;\n\t            }\n\t\n\t            // set pointer coordinate, time changes and speeds\n\t            setEventDeltas(this.pointerDelta, this.prevCoords, this.curCoords);\n\t\n\t            if (!this.prepared.name) { return; }\n\t\n\t            if (this.pointerWasMoved\n\t                // ignore movement while inertia is active\n\t                && (!this.inertiaStatus.active || (pointer instanceof InteractEvent && /inertiastart/.test(pointer.type)))) {\n\t\n\t                // if just starting an action, calculate the pointer speed now\n\t                if (!this.interacting()) {\n\t                    setEventDeltas(this.pointerDelta, this.prevCoords, this.curCoords);\n\t\n\t                    // check if a drag is in the correct axis\n\t                    if (this.prepared.name === 'drag') {\n\t                        var absX = Math.abs(dx),\n\t                            absY = Math.abs(dy),\n\t                            targetAxis = this.target.options.drag.axis,\n\t                            axis = (absX > absY ? 'x' : absX < absY ? 'y' : 'xy');\n\t\n\t                        // if the movement isn't in the axis of the interactable\n\t                        if (axis !== 'xy' && targetAxis !== 'xy' && targetAxis !== axis) {\n\t                            // cancel the prepared action\n\t                            this.prepared.name = null;\n\t\n\t                            // then try to get a drag from another ineractable\n\t\n\t                            var element = eventTarget;\n\t\n\t                            // check element interactables\n\t                            while (isElement(element)) {\n\t                                var elementInteractable = interactables.get(element);\n\t\n\t                                if (elementInteractable\n\t                                    && elementInteractable !== this.target\n\t                                    && !elementInteractable.options.drag.manualStart\n\t                                    && elementInteractable.getAction(this.downPointer, this.downEvent, this, element).name === 'drag'\n\t                                    && checkAxis(axis, elementInteractable)) {\n\t\n\t                                    this.prepared.name = 'drag';\n\t                                    this.target = elementInteractable;\n\t                                    this.element = element;\n\t                                    break;\n\t                                }\n\t\n\t                                element = parentElement(element);\n\t                            }\n\t\n\t                            // if there's no drag from element interactables,\n\t                            // check the selector interactables\n\t                            if (!this.prepared.name) {\n\t                                var thisInteraction = this;\n\t\n\t                                var getDraggable = function (interactable, selector, context) {\n\t                                    var elements = ie8MatchesSelector\n\t                                        ? context.querySelectorAll(selector)\n\t                                        : undefined;\n\t\n\t                                    if (interactable === thisInteraction.target) { return; }\n\t\n\t                                    if (inContext(interactable, eventTarget)\n\t                                        && !interactable.options.drag.manualStart\n\t                                        && !testIgnore(interactable, element, eventTarget)\n\t                                        && testAllow(interactable, element, eventTarget)\n\t                                        && matchesSelector(element, selector, elements)\n\t                                        && interactable.getAction(thisInteraction.downPointer, thisInteraction.downEvent, thisInteraction, element).name === 'drag'\n\t                                        && checkAxis(axis, interactable)\n\t                                        && withinInteractionLimit(interactable, element, 'drag')) {\n\t\n\t                                        return interactable;\n\t                                    }\n\t                                };\n\t\n\t                                element = eventTarget;\n\t\n\t                                while (isElement(element)) {\n\t                                    var selectorInteractable = interactables.forEachSelector(getDraggable);\n\t\n\t                                    if (selectorInteractable) {\n\t                                        this.prepared.name = 'drag';\n\t                                        this.target = selectorInteractable;\n\t                                        this.element = element;\n\t                                        break;\n\t                                    }\n\t\n\t                                    element = parentElement(element);\n\t                                }\n\t                            }\n\t                        }\n\t                    }\n\t                }\n\t\n\t                var starting = !!this.prepared.name && !this.interacting();\n\t\n\t                if (starting\n\t                    && (this.target.options[this.prepared.name].manualStart\n\t                        || !withinInteractionLimit(this.target, this.element, this.prepared))) {\n\t                    this.stop(event);\n\t                    return;\n\t                }\n\t\n\t                if (this.prepared.name && this.target) {\n\t                    if (starting) {\n\t                        this.start(this.prepared, this.target, this.element);\n\t                    }\n\t\n\t                    var shouldMove = this.setModifications(this.curCoords.page, preEnd);\n\t\n\t                    // move if snapping or restriction doesn't prevent it\n\t                    if (shouldMove || starting) {\n\t                        this.prevEvent = this[this.prepared.name + 'Move'](event);\n\t                    }\n\t\n\t                    this.checkAndPreventDefault(event, this.target, this.element);\n\t                }\n\t            }\n\t\n\t            copyCoords(this.prevCoords, this.curCoords);\n\t\n\t            if (this.dragging || this.resizing) {\n\t                this.autoScrollMove(pointer);\n\t            }\n\t        },\n\t\n\t        dragStart: function (event) {\n\t            var dragEvent = new InteractEvent(this, event, 'drag', 'start', this.element);\n\t\n\t            this.dragging = true;\n\t            this.target.fire(dragEvent);\n\t\n\t            // reset active dropzones\n\t            this.activeDrops.dropzones = [];\n\t            this.activeDrops.elements  = [];\n\t            this.activeDrops.rects     = [];\n\t\n\t            if (!this.dynamicDrop) {\n\t                this.setActiveDrops(this.element);\n\t            }\n\t\n\t            var dropEvents = this.getDropEvents(event, dragEvent);\n\t\n\t            if (dropEvents.activate) {\n\t                this.fireActiveDrops(dropEvents.activate);\n\t            }\n\t\n\t            return dragEvent;\n\t        },\n\t\n\t        dragMove: function (event) {\n\t            var target = this.target,\n\t                dragEvent  = new InteractEvent(this, event, 'drag', 'move', this.element),\n\t                draggableElement = this.element,\n\t                drop = this.getDrop(dragEvent, event, draggableElement);\n\t\n\t            this.dropTarget = drop.dropzone;\n\t            this.dropElement = drop.element;\n\t\n\t            var dropEvents = this.getDropEvents(event, dragEvent);\n\t\n\t            target.fire(dragEvent);\n\t\n\t            if (dropEvents.leave) { this.prevDropTarget.fire(dropEvents.leave); }\n\t            if (dropEvents.enter) {     this.dropTarget.fire(dropEvents.enter); }\n\t            if (dropEvents.move ) {     this.dropTarget.fire(dropEvents.move ); }\n\t\n\t            this.prevDropTarget  = this.dropTarget;\n\t            this.prevDropElement = this.dropElement;\n\t\n\t            return dragEvent;\n\t        },\n\t\n\t        resizeStart: function (event) {\n\t            var resizeEvent = new InteractEvent(this, event, 'resize', 'start', this.element);\n\t\n\t            if (this.prepared.edges) {\n\t                var startRect = this.target.getRect(this.element);\n\t\n\t                /*\n\t                 * When using the `resizable.square` or `resizable.preserveAspectRatio` options, resizing from one edge\n\t                 * will affect another. E.g. with `resizable.square`, resizing to make the right edge larger will make\n\t                 * the bottom edge larger by the same amount. We call these 'linked' edges. Any linked edges will depend\n\t                 * on the active edges and the edge being interacted with.\n\t                 */\n\t                if (this.target.options.resize.square || this.target.options.resize.preserveAspectRatio) {\n\t                    var linkedEdges = extend({}, this.prepared.edges);\n\t\n\t                    linkedEdges.top    = linkedEdges.top    || (linkedEdges.left   && !linkedEdges.bottom);\n\t                    linkedEdges.left   = linkedEdges.left   || (linkedEdges.top    && !linkedEdges.right );\n\t                    linkedEdges.bottom = linkedEdges.bottom || (linkedEdges.right  && !linkedEdges.top   );\n\t                    linkedEdges.right  = linkedEdges.right  || (linkedEdges.bottom && !linkedEdges.left  );\n\t\n\t                    this.prepared._linkedEdges = linkedEdges;\n\t                }\n\t                else {\n\t                    this.prepared._linkedEdges = null;\n\t                }\n\t\n\t                // if using `resizable.preserveAspectRatio` option, record aspect ratio at the start of the resize\n\t                if (this.target.options.resize.preserveAspectRatio) {\n\t                    this.resizeStartAspectRatio = startRect.width / startRect.height;\n\t                }\n\t\n\t                this.resizeRects = {\n\t                    start     : startRect,\n\t                    current   : extend({}, startRect),\n\t                    restricted: extend({}, startRect),\n\t                    previous  : extend({}, startRect),\n\t                    delta     : {\n\t                        left: 0, right : 0, width : 0,\n\t                        top : 0, bottom: 0, height: 0\n\t                    }\n\t                };\n\t\n\t                resizeEvent.rect = this.resizeRects.restricted;\n\t                resizeEvent.deltaRect = this.resizeRects.delta;\n\t            }\n\t\n\t            this.target.fire(resizeEvent);\n\t\n\t            this.resizing = true;\n\t\n\t            return resizeEvent;\n\t        },\n\t\n\t        resizeMove: function (event) {\n\t            var resizeEvent = new InteractEvent(this, event, 'resize', 'move', this.element);\n\t\n\t            var edges = this.prepared.edges,\n\t                invert = this.target.options.resize.invert,\n\t                invertible = invert === 'reposition' || invert === 'negate';\n\t\n\t            if (edges) {\n\t                var dx = resizeEvent.dx,\n\t                    dy = resizeEvent.dy,\n\t\n\t                    start      = this.resizeRects.start,\n\t                    current    = this.resizeRects.current,\n\t                    restricted = this.resizeRects.restricted,\n\t                    delta      = this.resizeRects.delta,\n\t                    previous   = extend(this.resizeRects.previous, restricted),\n\t\n\t                    originalEdges = edges;\n\t\n\t                // `resize.preserveAspectRatio` takes precedence over `resize.square`\n\t                if (this.target.options.resize.preserveAspectRatio) {\n\t                    var resizeStartAspectRatio = this.resizeStartAspectRatio;\n\t\n\t                    edges = this.prepared._linkedEdges;\n\t\n\t                    if ((originalEdges.left && originalEdges.bottom)\n\t                        || (originalEdges.right && originalEdges.top)) {\n\t                        dy = -dx / resizeStartAspectRatio;\n\t                    }\n\t                    else if (originalEdges.left || originalEdges.right) { dy = dx / resizeStartAspectRatio; }\n\t                    else if (originalEdges.top || originalEdges.bottom) { dx = dy * resizeStartAspectRatio; }\n\t                }\n\t                else if (this.target.options.resize.square) {\n\t                    edges = this.prepared._linkedEdges;\n\t\n\t                    if ((originalEdges.left && originalEdges.bottom)\n\t                        || (originalEdges.right && originalEdges.top)) {\n\t                        dy = -dx;\n\t                    }\n\t                    else if (originalEdges.left || originalEdges.right) { dy = dx; }\n\t                    else if (originalEdges.top || originalEdges.bottom) { dx = dy; }\n\t                }\n\t\n\t                // update the 'current' rect without modifications\n\t                if (edges.top   ) { current.top    += dy; }\n\t                if (edges.bottom) { current.bottom += dy; }\n\t                if (edges.left  ) { current.left   += dx; }\n\t                if (edges.right ) { current.right  += dx; }\n\t\n\t                if (invertible) {\n\t                    // if invertible, copy the current rect\n\t                    extend(restricted, current);\n\t\n\t                    if (invert === 'reposition') {\n\t                        // swap edge values if necessary to keep width/height positive\n\t                        var swap;\n\t\n\t                        if (restricted.top > restricted.bottom) {\n\t                            swap = restricted.top;\n\t\n\t                            restricted.top = restricted.bottom;\n\t                            restricted.bottom = swap;\n\t                        }\n\t                        if (restricted.left > restricted.right) {\n\t                            swap = restricted.left;\n\t\n\t                            restricted.left = restricted.right;\n\t                            restricted.right = swap;\n\t                        }\n\t                    }\n\t                }\n\t                else {\n\t                    // if not invertible, restrict to minimum of 0x0 rect\n\t                    restricted.top    = Math.min(current.top, start.bottom);\n\t                    restricted.bottom = Math.max(current.bottom, start.top);\n\t                    restricted.left   = Math.min(current.left, start.right);\n\t                    restricted.right  = Math.max(current.right, start.left);\n\t                }\n\t\n\t                restricted.width  = restricted.right  - restricted.left;\n\t                restricted.height = restricted.bottom - restricted.top ;\n\t\n\t                for (var edge in restricted) {\n\t                    delta[edge] = restricted[edge] - previous[edge];\n\t                }\n\t\n\t                resizeEvent.edges = this.prepared.edges;\n\t                resizeEvent.rect = restricted;\n\t                resizeEvent.deltaRect = delta;\n\t            }\n\t\n\t            this.target.fire(resizeEvent);\n\t\n\t            return resizeEvent;\n\t        },\n\t\n\t        gestureStart: function (event) {\n\t            var gestureEvent = new InteractEvent(this, event, 'gesture', 'start', this.element);\n\t\n\t            gestureEvent.ds = 0;\n\t\n\t            this.gesture.startDistance = this.gesture.prevDistance = gestureEvent.distance;\n\t            this.gesture.startAngle = this.gesture.prevAngle = gestureEvent.angle;\n\t            this.gesture.scale = 1;\n\t\n\t            this.gesturing = true;\n\t\n\t            this.target.fire(gestureEvent);\n\t\n\t            return gestureEvent;\n\t        },\n\t\n\t        gestureMove: function (event) {\n\t            if (!this.pointerIds.length) {\n\t                return this.prevEvent;\n\t            }\n\t\n\t            var gestureEvent;\n\t\n\t            gestureEvent = new InteractEvent(this, event, 'gesture', 'move', this.element);\n\t            gestureEvent.ds = gestureEvent.scale - this.gesture.scale;\n\t\n\t            this.target.fire(gestureEvent);\n\t\n\t            this.gesture.prevAngle = gestureEvent.angle;\n\t            this.gesture.prevDistance = gestureEvent.distance;\n\t\n\t            if (gestureEvent.scale !== Infinity &&\n\t                gestureEvent.scale !== null &&\n\t                gestureEvent.scale !== undefined  &&\n\t                !isNaN(gestureEvent.scale)) {\n\t\n\t                this.gesture.scale = gestureEvent.scale;\n\t            }\n\t\n\t            return gestureEvent;\n\t        },\n\t\n\t        pointerHold: function (pointer, event, eventTarget) {\n\t            this.collectEventTargets(pointer, event, eventTarget, 'hold');\n\t        },\n\t\n\t        pointerUp: function (pointer, event, eventTarget, curEventTarget) {\n\t            var pointerIndex = this.mouse? 0 : indexOf(this.pointerIds, getPointerId(pointer));\n\t\n\t            clearTimeout(this.holdTimers[pointerIndex]);\n\t\n\t            this.collectEventTargets(pointer, event, eventTarget, 'up' );\n\t            this.collectEventTargets(pointer, event, eventTarget, 'tap');\n\t\n\t            this.pointerEnd(pointer, event, eventTarget, curEventTarget);\n\t\n\t            this.removePointer(pointer);\n\t        },\n\t\n\t        pointerCancel: function (pointer, event, eventTarget, curEventTarget) {\n\t            var pointerIndex = this.mouse? 0 : indexOf(this.pointerIds, getPointerId(pointer));\n\t\n\t            clearTimeout(this.holdTimers[pointerIndex]);\n\t\n\t            this.collectEventTargets(pointer, event, eventTarget, 'cancel');\n\t            this.pointerEnd(pointer, event, eventTarget, curEventTarget);\n\t\n\t            this.removePointer(pointer);\n\t        },\n\t\n\t        // http://www.quirksmode.org/dom/events/click.html\n\t        // >Events leading to dblclick\n\t        //\n\t        // IE8 doesn't fire down event before dblclick.\n\t        // This workaround tries to fire a tap and doubletap after dblclick\n\t        ie8Dblclick: function (pointer, event, eventTarget) {\n\t            if (this.prevTap\n\t                && event.clientX === this.prevTap.clientX\n\t                && event.clientY === this.prevTap.clientY\n\t                && eventTarget   === this.prevTap.target) {\n\t\n\t                this.downTargets[0] = eventTarget;\n\t                this.downTimes[0] = new Date().getTime();\n\t                this.collectEventTargets(pointer, event, eventTarget, 'tap');\n\t            }\n\t        },\n\t\n\t        // End interact move events and stop auto-scroll unless inertia is enabled\n\t        pointerEnd: function (pointer, event, eventTarget, curEventTarget) {\n\t            var endEvent,\n\t                target = this.target,\n\t                options = target && target.options,\n\t                inertiaOptions = options && this.prepared.name && options[this.prepared.name].inertia,\n\t                inertiaStatus = this.inertiaStatus;\n\t\n\t            if (this.interacting()) {\n\t\n\t                if (inertiaStatus.active && !inertiaStatus.ending) { return; }\n\t\n\t                var pointerSpeed,\n\t                    now = new Date().getTime(),\n\t                    inertiaPossible = false,\n\t                    inertia = false,\n\t                    smoothEnd = false,\n\t                    endSnap = checkSnap(target, this.prepared.name) && options[this.prepared.name].snap.endOnly,\n\t                    endRestrict = checkRestrict(target, this.prepared.name) && options[this.prepared.name].restrict.endOnly,\n\t                    dx = 0,\n\t                    dy = 0,\n\t                    startEvent;\n\t\n\t                if (this.dragging) {\n\t                    if      (options.drag.axis === 'x' ) { pointerSpeed = Math.abs(this.pointerDelta.client.vx); }\n\t                    else if (options.drag.axis === 'y' ) { pointerSpeed = Math.abs(this.pointerDelta.client.vy); }\n\t                    else   /*options.drag.axis === 'xy'*/{ pointerSpeed = this.pointerDelta.client.speed; }\n\t                }\n\t                else {\n\t                    pointerSpeed = this.pointerDelta.client.speed;\n\t                }\n\t\n\t                // check if inertia should be started\n\t                inertiaPossible = (inertiaOptions && inertiaOptions.enabled\n\t                                   && this.prepared.name !== 'gesture'\n\t                                   && event !== inertiaStatus.startEvent);\n\t\n\t                inertia = (inertiaPossible\n\t                           && (now - this.curCoords.timeStamp) < 50\n\t                           && pointerSpeed > inertiaOptions.minSpeed\n\t                           && pointerSpeed > inertiaOptions.endSpeed);\n\t\n\t                if (inertiaPossible && !inertia && (endSnap || endRestrict)) {\n\t\n\t                    var snapRestrict = {};\n\t\n\t                    snapRestrict.snap = snapRestrict.restrict = snapRestrict;\n\t\n\t                    if (endSnap) {\n\t                        this.setSnapping(this.curCoords.page, snapRestrict);\n\t                        if (snapRestrict.locked) {\n\t                            dx += snapRestrict.dx;\n\t                            dy += snapRestrict.dy;\n\t                        }\n\t                    }\n\t\n\t                    if (endRestrict) {\n\t                        this.setRestriction(this.curCoords.page, snapRestrict);\n\t                        if (snapRestrict.restricted) {\n\t                            dx += snapRestrict.dx;\n\t                            dy += snapRestrict.dy;\n\t                        }\n\t                    }\n\t\n\t                    if (dx || dy) {\n\t                        smoothEnd = true;\n\t                    }\n\t                }\n\t\n\t                if (inertia || smoothEnd) {\n\t                    copyCoords(inertiaStatus.upCoords, this.curCoords);\n\t\n\t                    this.pointers[0] = inertiaStatus.startEvent = startEvent =\n\t                        new InteractEvent(this, event, this.prepared.name, 'inertiastart', this.element);\n\t\n\t                    inertiaStatus.t0 = now;\n\t\n\t                    target.fire(inertiaStatus.startEvent);\n\t\n\t                    if (inertia) {\n\t                        inertiaStatus.vx0 = this.pointerDelta.client.vx;\n\t                        inertiaStatus.vy0 = this.pointerDelta.client.vy;\n\t                        inertiaStatus.v0 = pointerSpeed;\n\t\n\t                        this.calcInertia(inertiaStatus);\n\t\n\t                        var page = extend({}, this.curCoords.page),\n\t                            origin = getOriginXY(target, this.element),\n\t                            statusObject;\n\t\n\t                        page.x = page.x + inertiaStatus.xe - origin.x;\n\t                        page.y = page.y + inertiaStatus.ye - origin.y;\n\t\n\t                        statusObject = {\n\t                            useStatusXY: true,\n\t                            x: page.x,\n\t                            y: page.y,\n\t                            dx: 0,\n\t                            dy: 0,\n\t                            snap: null\n\t                        };\n\t\n\t                        statusObject.snap = statusObject;\n\t\n\t                        dx = dy = 0;\n\t\n\t                        if (endSnap) {\n\t                            var snap = this.setSnapping(this.curCoords.page, statusObject);\n\t\n\t                            if (snap.locked) {\n\t                                dx += snap.dx;\n\t                                dy += snap.dy;\n\t                            }\n\t                        }\n\t\n\t                        if (endRestrict) {\n\t                            var restrict = this.setRestriction(this.curCoords.page, statusObject);\n\t\n\t                            if (restrict.restricted) {\n\t                                dx += restrict.dx;\n\t                                dy += restrict.dy;\n\t                            }\n\t                        }\n\t\n\t                        inertiaStatus.modifiedXe += dx;\n\t                        inertiaStatus.modifiedYe += dy;\n\t\n\t                        inertiaStatus.i = reqFrame(this.boundInertiaFrame);\n\t                    }\n\t                    else {\n\t                        inertiaStatus.smoothEnd = true;\n\t                        inertiaStatus.xe = dx;\n\t                        inertiaStatus.ye = dy;\n\t\n\t                        inertiaStatus.sx = inertiaStatus.sy = 0;\n\t\n\t                        inertiaStatus.i = reqFrame(this.boundSmoothEndFrame);\n\t                    }\n\t\n\t                    inertiaStatus.active = true;\n\t                    return;\n\t                }\n\t\n\t                if (endSnap || endRestrict) {\n\t                    // fire a move event at the snapped coordinates\n\t                    this.pointerMove(pointer, event, eventTarget, curEventTarget, true);\n\t                }\n\t            }\n\t\n\t            if (this.dragging) {\n\t                endEvent = new InteractEvent(this, event, 'drag', 'end', this.element);\n\t\n\t                var draggableElement = this.element,\n\t                    drop = this.getDrop(endEvent, event, draggableElement);\n\t\n\t                this.dropTarget = drop.dropzone;\n\t                this.dropElement = drop.element;\n\t\n\t                var dropEvents = this.getDropEvents(event, endEvent);\n\t\n\t                if (dropEvents.leave) { this.prevDropTarget.fire(dropEvents.leave); }\n\t                if (dropEvents.enter) {     this.dropTarget.fire(dropEvents.enter); }\n\t                if (dropEvents.drop ) {     this.dropTarget.fire(dropEvents.drop ); }\n\t                if (dropEvents.deactivate) {\n\t                    this.fireActiveDrops(dropEvents.deactivate);\n\t                }\n\t\n\t                target.fire(endEvent);\n\t            }\n\t            else if (this.resizing) {\n\t                endEvent = new InteractEvent(this, event, 'resize', 'end', this.element);\n\t                target.fire(endEvent);\n\t            }\n\t            else if (this.gesturing) {\n\t                endEvent = new InteractEvent(this, event, 'gesture', 'end', this.element);\n\t                target.fire(endEvent);\n\t            }\n\t\n\t            this.stop(event);\n\t        },\n\t\n\t        collectDrops: function (element) {\n\t            var drops = [],\n\t                elements = [],\n\t                i;\n\t\n\t            element = element || this.element;\n\t\n\t            // collect all dropzones and their elements which qualify for a drop\n\t            for (i = 0; i < interactables.length; i++) {\n\t                if (!interactables[i].options.drop.enabled) { continue; }\n\t\n\t                var current = interactables[i],\n\t                    accept = current.options.drop.accept;\n\t\n\t                // test the draggable element against the dropzone's accept setting\n\t                if ((isElement(accept) && accept !== element)\n\t                    || (isString(accept)\n\t                        && !matchesSelector(element, accept))) {\n\t\n\t                    continue;\n\t                }\n\t\n\t                // query for new elements if necessary\n\t                var dropElements = current.selector? current._context.querySelectorAll(current.selector) : [current._element];\n\t\n\t                for (var j = 0, len = dropElements.length; j < len; j++) {\n\t                    var currentElement = dropElements[j];\n\t\n\t                    if (currentElement === element) {\n\t                        continue;\n\t                    }\n\t\n\t                    drops.push(current);\n\t                    elements.push(currentElement);\n\t                }\n\t            }\n\t\n\t            return {\n\t                dropzones: drops,\n\t                elements: elements\n\t            };\n\t        },\n\t\n\t        fireActiveDrops: function (event) {\n\t            var i,\n\t                current,\n\t                currentElement,\n\t                prevElement;\n\t\n\t            // loop through all active dropzones and trigger event\n\t            for (i = 0; i < this.activeDrops.dropzones.length; i++) {\n\t                current = this.activeDrops.dropzones[i];\n\t                currentElement = this.activeDrops.elements [i];\n\t\n\t                // prevent trigger of duplicate events on same element\n\t                if (currentElement !== prevElement) {\n\t                    // set current element as event target\n\t                    event.target = currentElement;\n\t                    current.fire(event);\n\t                }\n\t                prevElement = currentElement;\n\t            }\n\t        },\n\t\n\t        // Collect a new set of possible drops and save them in activeDrops.\n\t        // setActiveDrops should always be called when a drag has just started or a\n\t        // drag event happens while dynamicDrop is true\n\t        setActiveDrops: function (dragElement) {\n\t            // get dropzones and their elements that could receive the draggable\n\t            var possibleDrops = this.collectDrops(dragElement, true);\n\t\n\t            this.activeDrops.dropzones = possibleDrops.dropzones;\n\t            this.activeDrops.elements  = possibleDrops.elements;\n\t            this.activeDrops.rects     = [];\n\t\n\t            for (var i = 0; i < this.activeDrops.dropzones.length; i++) {\n\t                this.activeDrops.rects[i] = this.activeDrops.dropzones[i].getRect(this.activeDrops.elements[i]);\n\t            }\n\t        },\n\t\n\t        getDrop: function (dragEvent, event, dragElement) {\n\t            var validDrops = [];\n\t\n\t            if (dynamicDrop) {\n\t                this.setActiveDrops(dragElement);\n\t            }\n\t\n\t            // collect all dropzones and their elements which qualify for a drop\n\t            for (var j = 0; j < this.activeDrops.dropzones.length; j++) {\n\t                var current        = this.activeDrops.dropzones[j],\n\t                    currentElement = this.activeDrops.elements [j],\n\t                    rect           = this.activeDrops.rects    [j];\n\t\n\t                validDrops.push(current.dropCheck(dragEvent, event, this.target, dragElement, currentElement, rect)\n\t                                ? currentElement\n\t                                : null);\n\t            }\n\t\n\t            // get the most appropriate dropzone based on DOM depth and order\n\t            var dropIndex = indexOfDeepestElement(validDrops),\n\t                dropzone  = this.activeDrops.dropzones[dropIndex] || null,\n\t                element   = this.activeDrops.elements [dropIndex] || null;\n\t\n\t            return {\n\t                dropzone: dropzone,\n\t                element: element\n\t            };\n\t        },\n\t\n\t        getDropEvents: function (pointerEvent, dragEvent) {\n\t            var dropEvents = {\n\t                enter     : null,\n\t                leave     : null,\n\t                activate  : null,\n\t                deactivate: null,\n\t                move      : null,\n\t                drop      : null\n\t            };\n\t\n\t            if (this.dropElement !== this.prevDropElement) {\n\t                // if there was a prevDropTarget, create a dragleave event\n\t                if (this.prevDropTarget) {\n\t                    dropEvents.leave = {\n\t                        target       : this.prevDropElement,\n\t                        dropzone     : this.prevDropTarget,\n\t                        relatedTarget: dragEvent.target,\n\t                        draggable    : dragEvent.interactable,\n\t                        dragEvent    : dragEvent,\n\t                        interaction  : this,\n\t                        timeStamp    : dragEvent.timeStamp,\n\t                        type         : 'dragleave'\n\t                    };\n\t\n\t                    dragEvent.dragLeave = this.prevDropElement;\n\t                    dragEvent.prevDropzone = this.prevDropTarget;\n\t                }\n\t                // if the dropTarget is not null, create a dragenter event\n\t                if (this.dropTarget) {\n\t                    dropEvents.enter = {\n\t                        target       : this.dropElement,\n\t                        dropzone     : this.dropTarget,\n\t                        relatedTarget: dragEvent.target,\n\t                        draggable    : dragEvent.interactable,\n\t                        dragEvent    : dragEvent,\n\t                        interaction  : this,\n\t                        timeStamp    : dragEvent.timeStamp,\n\t                        type         : 'dragenter'\n\t                    };\n\t\n\t                    dragEvent.dragEnter = this.dropElement;\n\t                    dragEvent.dropzone = this.dropTarget;\n\t                }\n\t            }\n\t\n\t            if (dragEvent.type === 'dragend' && this.dropTarget) {\n\t                dropEvents.drop = {\n\t                    target       : this.dropElement,\n\t                    dropzone     : this.dropTarget,\n\t                    relatedTarget: dragEvent.target,\n\t                    draggable    : dragEvent.interactable,\n\t                    dragEvent    : dragEvent,\n\t                    interaction  : this,\n\t                    timeStamp    : dragEvent.timeStamp,\n\t                    type         : 'drop'\n\t                };\n\t\n\t                dragEvent.dropzone = this.dropTarget;\n\t            }\n\t            if (dragEvent.type === 'dragstart') {\n\t                dropEvents.activate = {\n\t                    target       : null,\n\t                    dropzone     : null,\n\t                    relatedTarget: dragEvent.target,\n\t                    draggable    : dragEvent.interactable,\n\t                    dragEvent    : dragEvent,\n\t                    interaction  : this,\n\t                    timeStamp    : dragEvent.timeStamp,\n\t                    type         : 'dropactivate'\n\t                };\n\t            }\n\t            if (dragEvent.type === 'dragend') {\n\t                dropEvents.deactivate = {\n\t                    target       : null,\n\t                    dropzone     : null,\n\t                    relatedTarget: dragEvent.target,\n\t                    draggable    : dragEvent.interactable,\n\t                    dragEvent    : dragEvent,\n\t                    interaction  : this,\n\t                    timeStamp    : dragEvent.timeStamp,\n\t                    type         : 'dropdeactivate'\n\t                };\n\t            }\n\t            if (dragEvent.type === 'dragmove' && this.dropTarget) {\n\t                dropEvents.move = {\n\t                    target       : this.dropElement,\n\t                    dropzone     : this.dropTarget,\n\t                    relatedTarget: dragEvent.target,\n\t                    draggable    : dragEvent.interactable,\n\t                    dragEvent    : dragEvent,\n\t                    interaction  : this,\n\t                    dragmove     : dragEvent,\n\t                    timeStamp    : dragEvent.timeStamp,\n\t                    type         : 'dropmove'\n\t                };\n\t                dragEvent.dropzone = this.dropTarget;\n\t            }\n\t\n\t            return dropEvents;\n\t        },\n\t\n\t        currentAction: function () {\n\t            return (this.dragging && 'drag') || (this.resizing && 'resize') || (this.gesturing && 'gesture') || null;\n\t        },\n\t\n\t        interacting: function () {\n\t            return this.dragging || this.resizing || this.gesturing;\n\t        },\n\t\n\t        clearTargets: function () {\n\t            this.target = this.element = null;\n\t\n\t            this.dropTarget = this.dropElement = this.prevDropTarget = this.prevDropElement = null;\n\t        },\n\t\n\t        stop: function (event) {\n\t            if (this.interacting()) {\n\t                autoScroll.stop();\n\t                this.matches = [];\n\t                this.matchElements = [];\n\t\n\t                var target = this.target;\n\t\n\t                if (target.options.styleCursor) {\n\t                    target._doc.documentElement.style.cursor = '';\n\t                }\n\t\n\t                // prevent Default only if were previously interacting\n\t                if (event && isFunction(event.preventDefault)) {\n\t                    this.checkAndPreventDefault(event, target, this.element);\n\t                }\n\t\n\t                if (this.dragging) {\n\t                    this.activeDrops.dropzones = this.activeDrops.elements = this.activeDrops.rects = null;\n\t                }\n\t            }\n\t\n\t            this.clearTargets();\n\t\n\t            this.pointerIsDown = this.snapStatus.locked = this.dragging = this.resizing = this.gesturing = false;\n\t            this.prepared.name = this.prevEvent = null;\n\t            this.inertiaStatus.resumeDx = this.inertiaStatus.resumeDy = 0;\n\t\n\t            // remove pointers if their ID isn't in this.pointerIds\n\t            for (var i = 0; i < this.pointers.length; i++) {\n\t                if (indexOf(this.pointerIds, getPointerId(this.pointers[i])) === -1) {\n\t                    this.pointers.splice(i, 1);\n\t                }\n\t            }\n\t        },\n\t\n\t        inertiaFrame: function () {\n\t            var inertiaStatus = this.inertiaStatus,\n\t                options = this.target.options[this.prepared.name].inertia,\n\t                lambda = options.resistance,\n\t                t = new Date().getTime() / 1000 - inertiaStatus.t0;\n\t\n\t            if (t < inertiaStatus.te) {\n\t\n\t                var progress =  1 - (Math.exp(-lambda * t) - inertiaStatus.lambda_v0) / inertiaStatus.one_ve_v0;\n\t\n\t                if (inertiaStatus.modifiedXe === inertiaStatus.xe && inertiaStatus.modifiedYe === inertiaStatus.ye) {\n\t                    inertiaStatus.sx = inertiaStatus.xe * progress;\n\t                    inertiaStatus.sy = inertiaStatus.ye * progress;\n\t                }\n\t                else {\n\t                    var quadPoint = getQuadraticCurvePoint(\n\t                            0, 0,\n\t                            inertiaStatus.xe, inertiaStatus.ye,\n\t                            inertiaStatus.modifiedXe, inertiaStatus.modifiedYe,\n\t                            progress);\n\t\n\t                    inertiaStatus.sx = quadPoint.x;\n\t                    inertiaStatus.sy = quadPoint.y;\n\t                }\n\t\n\t                this.pointerMove(inertiaStatus.startEvent, inertiaStatus.startEvent);\n\t\n\t                inertiaStatus.i = reqFrame(this.boundInertiaFrame);\n\t            }\n\t            else {\n\t                inertiaStatus.ending = true;\n\t\n\t                inertiaStatus.sx = inertiaStatus.modifiedXe;\n\t                inertiaStatus.sy = inertiaStatus.modifiedYe;\n\t\n\t                this.pointerMove(inertiaStatus.startEvent, inertiaStatus.startEvent);\n\t                this.pointerEnd(inertiaStatus.startEvent, inertiaStatus.startEvent);\n\t\n\t                inertiaStatus.active = inertiaStatus.ending = false;\n\t            }\n\t        },\n\t\n\t        smoothEndFrame: function () {\n\t            var inertiaStatus = this.inertiaStatus,\n\t                t = new Date().getTime() - inertiaStatus.t0,\n\t                duration = this.target.options[this.prepared.name].inertia.smoothEndDuration;\n\t\n\t            if (t < duration) {\n\t                inertiaStatus.sx = easeOutQuad(t, 0, inertiaStatus.xe, duration);\n\t                inertiaStatus.sy = easeOutQuad(t, 0, inertiaStatus.ye, duration);\n\t\n\t                this.pointerMove(inertiaStatus.startEvent, inertiaStatus.startEvent);\n\t\n\t                inertiaStatus.i = reqFrame(this.boundSmoothEndFrame);\n\t            }\n\t            else {\n\t                inertiaStatus.ending = true;\n\t\n\t                inertiaStatus.sx = inertiaStatus.xe;\n\t                inertiaStatus.sy = inertiaStatus.ye;\n\t\n\t                this.pointerMove(inertiaStatus.startEvent, inertiaStatus.startEvent);\n\t                this.pointerEnd(inertiaStatus.startEvent, inertiaStatus.startEvent);\n\t\n\t                inertiaStatus.smoothEnd =\n\t                  inertiaStatus.active = inertiaStatus.ending = false;\n\t            }\n\t        },\n\t\n\t        addPointer: function (pointer) {\n\t            var id = getPointerId(pointer),\n\t                index = this.mouse? 0 : indexOf(this.pointerIds, id);\n\t\n\t            if (index === -1) {\n\t                index = this.pointerIds.length;\n\t            }\n\t\n\t            this.pointerIds[index] = id;\n\t            this.pointers[index] = pointer;\n\t\n\t            return index;\n\t        },\n\t\n\t        removePointer: function (pointer) {\n\t            var id = getPointerId(pointer),\n\t                index = this.mouse? 0 : indexOf(this.pointerIds, id);\n\t\n\t            if (index === -1) { return; }\n\t\n\t            this.pointers   .splice(index, 1);\n\t            this.pointerIds .splice(index, 1);\n\t            this.downTargets.splice(index, 1);\n\t            this.downTimes  .splice(index, 1);\n\t            this.holdTimers .splice(index, 1);\n\t        },\n\t\n\t        recordPointer: function (pointer) {\n\t            var index = this.mouse? 0: indexOf(this.pointerIds, getPointerId(pointer));\n\t\n\t            if (index === -1) { return; }\n\t\n\t            this.pointers[index] = pointer;\n\t        },\n\t\n\t        collectEventTargets: function (pointer, event, eventTarget, eventType) {\n\t            var pointerIndex = this.mouse? 0 : indexOf(this.pointerIds, getPointerId(pointer));\n\t\n\t            // do not fire a tap event if the pointer was moved before being lifted\n\t            if (eventType === 'tap' && (this.pointerWasMoved\n\t                // or if the pointerup target is different to the pointerdown target\n\t                || !(this.downTargets[pointerIndex] && this.downTargets[pointerIndex] === eventTarget))) {\n\t                return;\n\t            }\n\t\n\t            var targets = [],\n\t                elements = [],\n\t                element = eventTarget;\n\t\n\t            function collectSelectors (interactable, selector, context) {\n\t                var els = ie8MatchesSelector\n\t                        ? context.querySelectorAll(selector)\n\t                        : undefined;\n\t\n\t                if (interactable._iEvents[eventType]\n\t                    && isElement(element)\n\t                    && inContext(interactable, element)\n\t                    && !testIgnore(interactable, element, eventTarget)\n\t                    && testAllow(interactable, element, eventTarget)\n\t                    && matchesSelector(element, selector, els)) {\n\t\n\t                    targets.push(interactable);\n\t                    elements.push(element);\n\t                }\n\t            }\n\t\n\t            while (element) {\n\t                if (interact.isSet(element) && interact(element)._iEvents[eventType]) {\n\t                    targets.push(interact(element));\n\t                    elements.push(element);\n\t                }\n\t\n\t                interactables.forEachSelector(collectSelectors);\n\t\n\t                element = parentElement(element);\n\t            }\n\t\n\t            // create the tap event even if there are no listeners so that\n\t            // doubletap can still be created and fired\n\t            if (targets.length || eventType === 'tap') {\n\t                this.firePointers(pointer, event, eventTarget, targets, elements, eventType);\n\t            }\n\t        },\n\t\n\t        firePointers: function (pointer, event, eventTarget, targets, elements, eventType) {\n\t            var pointerIndex = this.mouse? 0 : indexOf(this.pointerIds, getPointerId(pointer)),\n\t                pointerEvent = {},\n\t                i,\n\t                // for tap events\n\t                interval, createNewDoubleTap;\n\t\n\t            // if it's a doubletap then the event properties would have been\n\t            // copied from the tap event and provided as the pointer argument\n\t            if (eventType === 'doubletap') {\n\t                pointerEvent = pointer;\n\t            }\n\t            else {\n\t                pointerExtend(pointerEvent, event);\n\t                if (event !== pointer) {\n\t                    pointerExtend(pointerEvent, pointer);\n\t                }\n\t\n\t                pointerEvent.preventDefault           = preventOriginalDefault;\n\t                pointerEvent.stopPropagation          = InteractEvent.prototype.stopPropagation;\n\t                pointerEvent.stopImmediatePropagation = InteractEvent.prototype.stopImmediatePropagation;\n\t                pointerEvent.interaction              = this;\n\t\n\t                pointerEvent.timeStamp       = new Date().getTime();\n\t                pointerEvent.originalEvent   = event;\n\t                pointerEvent.originalPointer = pointer;\n\t                pointerEvent.type            = eventType;\n\t                pointerEvent.pointerId       = getPointerId(pointer);\n\t                pointerEvent.pointerType     = this.mouse? 'mouse' : !supportsPointerEvent? 'touch'\n\t                                                    : isString(pointer.pointerType)\n\t                                                        ? pointer.pointerType\n\t                                                        : [,,'touch', 'pen', 'mouse'][pointer.pointerType];\n\t            }\n\t\n\t            if (eventType === 'tap') {\n\t                pointerEvent.dt = pointerEvent.timeStamp - this.downTimes[pointerIndex];\n\t\n\t                interval = pointerEvent.timeStamp - this.tapTime;\n\t                createNewDoubleTap = !!(this.prevTap && this.prevTap.type !== 'doubletap'\n\t                       && this.prevTap.target === pointerEvent.target\n\t                       && interval < 500);\n\t\n\t                pointerEvent.double = createNewDoubleTap;\n\t\n\t                this.tapTime = pointerEvent.timeStamp;\n\t            }\n\t\n\t            for (i = 0; i < targets.length; i++) {\n\t                pointerEvent.currentTarget = elements[i];\n\t                pointerEvent.interactable = targets[i];\n\t                targets[i].fire(pointerEvent);\n\t\n\t                if (pointerEvent.immediatePropagationStopped\n\t                    ||(pointerEvent.propagationStopped && elements[i + 1] !== pointerEvent.currentTarget)) {\n\t                    break;\n\t                }\n\t            }\n\t\n\t            if (createNewDoubleTap) {\n\t                var doubleTap = {};\n\t\n\t                extend(doubleTap, pointerEvent);\n\t\n\t                doubleTap.dt   = interval;\n\t                doubleTap.type = 'doubletap';\n\t\n\t                this.collectEventTargets(doubleTap, event, eventTarget, 'doubletap');\n\t\n\t                this.prevTap = doubleTap;\n\t            }\n\t            else if (eventType === 'tap') {\n\t                this.prevTap = pointerEvent;\n\t            }\n\t        },\n\t\n\t        validateSelector: function (pointer, event, matches, matchElements) {\n\t            for (var i = 0, len = matches.length; i < len; i++) {\n\t                var match = matches[i],\n\t                    matchElement = matchElements[i],\n\t                    action = validateAction(match.getAction(pointer, event, this, matchElement), match);\n\t\n\t                if (action && withinInteractionLimit(match, matchElement, action)) {\n\t                    this.target = match;\n\t                    this.element = matchElement;\n\t\n\t                    return action;\n\t                }\n\t            }\n\t        },\n\t\n\t        setSnapping: function (pageCoords, status) {\n\t            var snap = this.target.options[this.prepared.name].snap,\n\t                targets = [],\n\t                target,\n\t                page,\n\t                i;\n\t\n\t            status = status || this.snapStatus;\n\t\n\t            if (status.useStatusXY) {\n\t                page = { x: status.x, y: status.y };\n\t            }\n\t            else {\n\t                var origin = getOriginXY(this.target, this.element);\n\t\n\t                page = extend({}, pageCoords);\n\t\n\t                page.x -= origin.x;\n\t                page.y -= origin.y;\n\t            }\n\t\n\t            status.realX = page.x;\n\t            status.realY = page.y;\n\t\n\t            page.x = page.x - this.inertiaStatus.resumeDx;\n\t            page.y = page.y - this.inertiaStatus.resumeDy;\n\t\n\t            var len = snap.targets? snap.targets.length : 0;\n\t\n\t            for (var relIndex = 0; relIndex < this.snapOffsets.length; relIndex++) {\n\t                var relative = {\n\t                    x: page.x - this.snapOffsets[relIndex].x,\n\t                    y: page.y - this.snapOffsets[relIndex].y\n\t                };\n\t\n\t                for (i = 0; i < len; i++) {\n\t                    if (isFunction(snap.targets[i])) {\n\t                        target = snap.targets[i](relative.x, relative.y, this);\n\t                    }\n\t                    else {\n\t                        target = snap.targets[i];\n\t                    }\n\t\n\t                    if (!target) { continue; }\n\t\n\t                    targets.push({\n\t                        x: isNumber(target.x) ? (target.x + this.snapOffsets[relIndex].x) : relative.x,\n\t                        y: isNumber(target.y) ? (target.y + this.snapOffsets[relIndex].y) : relative.y,\n\t\n\t                        range: isNumber(target.range)? target.range: snap.range\n\t                    });\n\t                }\n\t            }\n\t\n\t            var closest = {\n\t                    target: null,\n\t                    inRange: false,\n\t                    distance: 0,\n\t                    range: 0,\n\t                    dx: 0,\n\t                    dy: 0\n\t                };\n\t\n\t            for (i = 0, len = targets.length; i < len; i++) {\n\t                target = targets[i];\n\t\n\t                var range = target.range,\n\t                    dx = target.x - page.x,\n\t                    dy = target.y - page.y,\n\t                    distance = hypot(dx, dy),\n\t                    inRange = distance <= range;\n\t\n\t                // Infinite targets count as being out of range\n\t                // compared to non infinite ones that are in range\n\t                if (range === Infinity && closest.inRange && closest.range !== Infinity) {\n\t                    inRange = false;\n\t                }\n\t\n\t                if (!closest.target || (inRange\n\t                    // is the closest target in range?\n\t                    ? (closest.inRange && range !== Infinity\n\t                        // the pointer is relatively deeper in this target\n\t                        ? distance / range < closest.distance / closest.range\n\t                        // this target has Infinite range and the closest doesn't\n\t                        : (range === Infinity && closest.range !== Infinity)\n\t                            // OR this target is closer that the previous closest\n\t                            || distance < closest.distance)\n\t                    // The other is not in range and the pointer is closer to this target\n\t                    : (!closest.inRange && distance < closest.distance))) {\n\t\n\t                    if (range === Infinity) {\n\t                        inRange = true;\n\t                    }\n\t\n\t                    closest.target = target;\n\t                    closest.distance = distance;\n\t                    closest.range = range;\n\t                    closest.inRange = inRange;\n\t                    closest.dx = dx;\n\t                    closest.dy = dy;\n\t\n\t                    status.range = range;\n\t                }\n\t            }\n\t\n\t            var snapChanged;\n\t\n\t            if (closest.target) {\n\t                snapChanged = (status.snappedX !== closest.target.x || status.snappedY !== closest.target.y);\n\t\n\t                status.snappedX = closest.target.x;\n\t                status.snappedY = closest.target.y;\n\t            }\n\t            else {\n\t                snapChanged = true;\n\t\n\t                status.snappedX = NaN;\n\t                status.snappedY = NaN;\n\t            }\n\t\n\t            status.dx = closest.dx;\n\t            status.dy = closest.dy;\n\t\n\t            status.changed = (snapChanged || (closest.inRange && !status.locked));\n\t            status.locked = closest.inRange;\n\t\n\t            return status;\n\t        },\n\t\n\t        setRestriction: function (pageCoords, status) {\n\t            var target = this.target,\n\t                restrict = target && target.options[this.prepared.name].restrict,\n\t                restriction = restrict && restrict.restriction,\n\t                page;\n\t\n\t            if (!restriction) {\n\t                return status;\n\t            }\n\t\n\t            status = status || this.restrictStatus;\n\t\n\t            page = status.useStatusXY\n\t                    ? page = { x: status.x, y: status.y }\n\t                    : page = extend({}, pageCoords);\n\t\n\t            if (status.snap && status.snap.locked) {\n\t                page.x += status.snap.dx || 0;\n\t                page.y += status.snap.dy || 0;\n\t            }\n\t\n\t            page.x -= this.inertiaStatus.resumeDx;\n\t            page.y -= this.inertiaStatus.resumeDy;\n\t\n\t            status.dx = 0;\n\t            status.dy = 0;\n\t            status.restricted = false;\n\t\n\t            var rect, restrictedX, restrictedY;\n\t\n\t            if (isString(restriction)) {\n\t                if (restriction === 'parent') {\n\t                    restriction = parentElement(this.element);\n\t                }\n\t                else if (restriction === 'self') {\n\t                    restriction = target.getRect(this.element);\n\t                }\n\t                else {\n\t                    restriction = closest(this.element, restriction);\n\t                }\n\t\n\t                if (!restriction) { return status; }\n\t            }\n\t\n\t            if (isFunction(restriction)) {\n\t                restriction = restriction(page.x, page.y, this.element);\n\t            }\n\t\n\t            if (isElement(restriction)) {\n\t                restriction = getElementRect(restriction);\n\t            }\n\t\n\t            rect = restriction;\n\t\n\t            if (!restriction) {\n\t                restrictedX = page.x;\n\t                restrictedY = page.y;\n\t            }\n\t            // object is assumed to have\n\t            // x, y, width, height or\n\t            // left, top, right, bottom\n\t            else if ('x' in restriction && 'y' in restriction) {\n\t                restrictedX = Math.max(Math.min(rect.x + rect.width  - this.restrictOffset.right , page.x), rect.x + this.restrictOffset.left);\n\t                restrictedY = Math.max(Math.min(rect.y + rect.height - this.restrictOffset.bottom, page.y), rect.y + this.restrictOffset.top );\n\t            }\n\t            else {\n\t                restrictedX = Math.max(Math.min(rect.right  - this.restrictOffset.right , page.x), rect.left + this.restrictOffset.left);\n\t                restrictedY = Math.max(Math.min(rect.bottom - this.restrictOffset.bottom, page.y), rect.top  + this.restrictOffset.top );\n\t            }\n\t\n\t            status.dx = restrictedX - page.x;\n\t            status.dy = restrictedY - page.y;\n\t\n\t            status.changed = status.restrictedX !== restrictedX || status.restrictedY !== restrictedY;\n\t            status.restricted = !!(status.dx || status.dy);\n\t\n\t            status.restrictedX = restrictedX;\n\t            status.restrictedY = restrictedY;\n\t\n\t            return status;\n\t        },\n\t\n\t        checkAndPreventDefault: function (event, interactable, element) {\n\t            if (!(interactable = interactable || this.target)) { return; }\n\t\n\t            var options = interactable.options,\n\t                prevent = options.preventDefault;\n\t\n\t            if (prevent === 'auto' && element && !/^(input|select|textarea)$/i.test(event.target.nodeName)) {\n\t                // do not preventDefault on pointerdown if the prepared action is a drag\n\t                // and dragging can only start from a certain direction - this allows\n\t                // a touch to pan the viewport if a drag isn't in the right direction\n\t                if (/down|start/i.test(event.type)\n\t                    && this.prepared.name === 'drag' && options.drag.axis !== 'xy') {\n\t\n\t                    return;\n\t                }\n\t\n\t                // with manualStart, only preventDefault while interacting\n\t                if (options[this.prepared.name] && options[this.prepared.name].manualStart\n\t                    && !this.interacting()) {\n\t                    return;\n\t                }\n\t\n\t                event.preventDefault();\n\t                return;\n\t            }\n\t\n\t            if (prevent === 'always') {\n\t                event.preventDefault();\n\t                return;\n\t            }\n\t        },\n\t\n\t        calcInertia: function (status) {\n\t            var inertiaOptions = this.target.options[this.prepared.name].inertia,\n\t                lambda = inertiaOptions.resistance,\n\t                inertiaDur = -Math.log(inertiaOptions.endSpeed / status.v0) / lambda;\n\t\n\t            status.x0 = this.prevEvent.pageX;\n\t            status.y0 = this.prevEvent.pageY;\n\t            status.t0 = status.startEvent.timeStamp / 1000;\n\t            status.sx = status.sy = 0;\n\t\n\t            status.modifiedXe = status.xe = (status.vx0 - inertiaDur) / lambda;\n\t            status.modifiedYe = status.ye = (status.vy0 - inertiaDur) / lambda;\n\t            status.te = inertiaDur;\n\t\n\t            status.lambda_v0 = lambda / status.v0;\n\t            status.one_ve_v0 = 1 - inertiaOptions.endSpeed / status.v0;\n\t        },\n\t\n\t        autoScrollMove: function (pointer) {\n\t            if (!(this.interacting()\n\t                && checkAutoScroll(this.target, this.prepared.name))) {\n\t                return;\n\t            }\n\t\n\t            if (this.inertiaStatus.active) {\n\t                autoScroll.x = autoScroll.y = 0;\n\t                return;\n\t            }\n\t\n\t            var top,\n\t                right,\n\t                bottom,\n\t                left,\n\t                options = this.target.options[this.prepared.name].autoScroll,\n\t                container = options.container || getWindow(this.element);\n\t\n\t            if (isWindow(container)) {\n\t                left   = pointer.clientX < autoScroll.margin;\n\t                top    = pointer.clientY < autoScroll.margin;\n\t                right  = pointer.clientX > container.innerWidth  - autoScroll.margin;\n\t                bottom = pointer.clientY > container.innerHeight - autoScroll.margin;\n\t            }\n\t            else {\n\t                var rect = getElementClientRect(container);\n\t\n\t                left   = pointer.clientX < rect.left   + autoScroll.margin;\n\t                top    = pointer.clientY < rect.top    + autoScroll.margin;\n\t                right  = pointer.clientX > rect.right  - autoScroll.margin;\n\t                bottom = pointer.clientY > rect.bottom - autoScroll.margin;\n\t            }\n\t\n\t            autoScroll.x = (right ? 1: left? -1: 0);\n\t            autoScroll.y = (bottom? 1:  top? -1: 0);\n\t\n\t            if (!autoScroll.isScrolling) {\n\t                // set the autoScroll properties to those of the target\n\t                autoScroll.margin = options.margin;\n\t                autoScroll.speed  = options.speed;\n\t\n\t                autoScroll.start(this);\n\t            }\n\t        },\n\t\n\t        _updateEventTargets: function (target, currentTarget) {\n\t            this._eventTarget    = target;\n\t            this._curEventTarget = currentTarget;\n\t        }\n\t\n\t    };\n\t\n\t    function getInteractionFromPointer (pointer, eventType, eventTarget) {\n\t        var i = 0, len = interactions.length,\n\t            mouseEvent = (/mouse/i.test(pointer.pointerType || eventType)\n\t                          // MSPointerEvent.MSPOINTER_TYPE_MOUSE\n\t                          || pointer.pointerType === 4),\n\t            interaction;\n\t\n\t        var id = getPointerId(pointer);\n\t\n\t        // try to resume inertia with a new pointer\n\t        if (/down|start/i.test(eventType)) {\n\t            for (i = 0; i < len; i++) {\n\t                interaction = interactions[i];\n\t\n\t                var element = eventTarget;\n\t\n\t                if (interaction.inertiaStatus.active && interaction.target.options[interaction.prepared.name].inertia.allowResume\n\t                    && (interaction.mouse === mouseEvent)) {\n\t                    while (element) {\n\t                        // if the element is the interaction element\n\t                        if (element === interaction.element) {\n\t                            return interaction;\n\t                        }\n\t                        element = parentElement(element);\n\t                    }\n\t                }\n\t            }\n\t        }\n\t\n\t        // if it's a mouse interaction\n\t        if (mouseEvent || !(supportsTouch || supportsPointerEvent)) {\n\t\n\t            // find a mouse interaction that's not in inertia phase\n\t            for (i = 0; i < len; i++) {\n\t                if (interactions[i].mouse && !interactions[i].inertiaStatus.active) {\n\t                    return interactions[i];\n\t                }\n\t            }\n\t\n\t            // find any interaction specifically for mouse.\n\t            // if the eventType is a mousedown, and inertia is active\n\t            // ignore the interaction\n\t            for (i = 0; i < len; i++) {\n\t                if (interactions[i].mouse && !(/down/.test(eventType) && interactions[i].inertiaStatus.active)) {\n\t                    return interaction;\n\t                }\n\t            }\n\t\n\t            // create a new interaction for mouse\n\t            interaction = new Interaction();\n\t            interaction.mouse = true;\n\t\n\t            return interaction;\n\t        }\n\t\n\t        // get interaction that has this pointer\n\t        for (i = 0; i < len; i++) {\n\t            if (contains(interactions[i].pointerIds, id)) {\n\t                return interactions[i];\n\t            }\n\t        }\n\t\n\t        // at this stage, a pointerUp should not return an interaction\n\t        if (/up|end|out/i.test(eventType)) {\n\t            return null;\n\t        }\n\t\n\t        // get first idle interaction\n\t        for (i = 0; i < len; i++) {\n\t            interaction = interactions[i];\n\t\n\t            if ((!interaction.prepared.name || (interaction.target.options.gesture.enabled))\n\t                && !interaction.interacting()\n\t                && !(!mouseEvent && interaction.mouse)) {\n\t\n\t                return interaction;\n\t            }\n\t        }\n\t\n\t        return new Interaction();\n\t    }\n\t\n\t    function doOnInteractions (method) {\n\t        return (function (event) {\n\t            var interaction,\n\t                eventTarget = getActualElement(event.path\n\t                                               ? event.path[0]\n\t                                               : event.target),\n\t                curEventTarget = getActualElement(event.currentTarget),\n\t                i;\n\t\n\t            if (supportsTouch && /touch/.test(event.type)) {\n\t                prevTouchTime = new Date().getTime();\n\t\n\t                for (i = 0; i < event.changedTouches.length; i++) {\n\t                    var pointer = event.changedTouches[i];\n\t\n\t                    interaction = getInteractionFromPointer(pointer, event.type, eventTarget);\n\t\n\t                    if (!interaction) { continue; }\n\t\n\t                    interaction._updateEventTargets(eventTarget, curEventTarget);\n\t\n\t                    interaction[method](pointer, event, eventTarget, curEventTarget);\n\t                }\n\t            }\n\t            else {\n\t                if (!supportsPointerEvent && /mouse/.test(event.type)) {\n\t                    // ignore mouse events while touch interactions are active\n\t                    for (i = 0; i < interactions.length; i++) {\n\t                        if (!interactions[i].mouse && interactions[i].pointerIsDown) {\n\t                            return;\n\t                        }\n\t                    }\n\t\n\t                    // try to ignore mouse events that are simulated by the browser\n\t                    // after a touch event\n\t                    if (new Date().getTime() - prevTouchTime < 500) {\n\t                        return;\n\t                    }\n\t                }\n\t\n\t                interaction = getInteractionFromPointer(event, event.type, eventTarget);\n\t\n\t                if (!interaction) { return; }\n\t\n\t                interaction._updateEventTargets(eventTarget, curEventTarget);\n\t\n\t                interaction[method](event, event, eventTarget, curEventTarget);\n\t            }\n\t        });\n\t    }\n\t\n\t    function InteractEvent (interaction, event, action, phase, element, related) {\n\t        var client,\n\t            page,\n\t            target      = interaction.target,\n\t            snapStatus  = interaction.snapStatus,\n\t            restrictStatus  = interaction.restrictStatus,\n\t            pointers    = interaction.pointers,\n\t            deltaSource = (target && target.options || defaultOptions).deltaSource,\n\t            sourceX     = deltaSource + 'X',\n\t            sourceY     = deltaSource + 'Y',\n\t            options     = target? target.options: defaultOptions,\n\t            origin      = getOriginXY(target, element),\n\t            starting    = phase === 'start',\n\t            ending      = phase === 'end',\n\t            coords      = starting? interaction.startCoords : interaction.curCoords;\n\t\n\t        element = element || interaction.element;\n\t\n\t        page   = extend({}, coords.page);\n\t        client = extend({}, coords.client);\n\t\n\t        page.x -= origin.x;\n\t        page.y -= origin.y;\n\t\n\t        client.x -= origin.x;\n\t        client.y -= origin.y;\n\t\n\t        var relativePoints = options[action].snap && options[action].snap.relativePoints ;\n\t\n\t        if (checkSnap(target, action) && !(starting && relativePoints && relativePoints.length)) {\n\t            this.snap = {\n\t                range  : snapStatus.range,\n\t                locked : snapStatus.locked,\n\t                x      : snapStatus.snappedX,\n\t                y      : snapStatus.snappedY,\n\t                realX  : snapStatus.realX,\n\t                realY  : snapStatus.realY,\n\t                dx     : snapStatus.dx,\n\t                dy     : snapStatus.dy\n\t            };\n\t\n\t            if (snapStatus.locked) {\n\t                page.x += snapStatus.dx;\n\t                page.y += snapStatus.dy;\n\t                client.x += snapStatus.dx;\n\t                client.y += snapStatus.dy;\n\t            }\n\t        }\n\t\n\t        if (checkRestrict(target, action) && !(starting && options[action].restrict.elementRect) && restrictStatus.restricted) {\n\t            page.x += restrictStatus.dx;\n\t            page.y += restrictStatus.dy;\n\t            client.x += restrictStatus.dx;\n\t            client.y += restrictStatus.dy;\n\t\n\t            this.restrict = {\n\t                dx: restrictStatus.dx,\n\t                dy: restrictStatus.dy\n\t            };\n\t        }\n\t\n\t        this.pageX     = page.x;\n\t        this.pageY     = page.y;\n\t        this.clientX   = client.x;\n\t        this.clientY   = client.y;\n\t\n\t        this.x0        = interaction.startCoords.page.x - origin.x;\n\t        this.y0        = interaction.startCoords.page.y - origin.y;\n\t        this.clientX0  = interaction.startCoords.client.x - origin.x;\n\t        this.clientY0  = interaction.startCoords.client.y - origin.y;\n\t        this.ctrlKey   = event.ctrlKey;\n\t        this.altKey    = event.altKey;\n\t        this.shiftKey  = event.shiftKey;\n\t        this.metaKey   = event.metaKey;\n\t        this.button    = event.button;\n\t        this.buttons   = event.buttons;\n\t        this.target    = element;\n\t        this.t0        = interaction.downTimes[0];\n\t        this.type      = action + (phase || '');\n\t\n\t        this.interaction = interaction;\n\t        this.interactable = target;\n\t\n\t        var inertiaStatus = interaction.inertiaStatus;\n\t\n\t        if (inertiaStatus.active) {\n\t            this.detail = 'inertia';\n\t        }\n\t\n\t        if (related) {\n\t            this.relatedTarget = related;\n\t        }\n\t\n\t        // end event dx, dy is difference between start and end points\n\t        if (ending) {\n\t            if (deltaSource === 'client') {\n\t                this.dx = client.x - interaction.startCoords.client.x;\n\t                this.dy = client.y - interaction.startCoords.client.y;\n\t            }\n\t            else {\n\t                this.dx = page.x - interaction.startCoords.page.x;\n\t                this.dy = page.y - interaction.startCoords.page.y;\n\t            }\n\t        }\n\t        else if (starting) {\n\t            this.dx = 0;\n\t            this.dy = 0;\n\t        }\n\t        // copy properties from previousmove if starting inertia\n\t        else if (phase === 'inertiastart') {\n\t            this.dx = interaction.prevEvent.dx;\n\t            this.dy = interaction.prevEvent.dy;\n\t        }\n\t        else {\n\t            if (deltaSource === 'client') {\n\t                this.dx = client.x - interaction.prevEvent.clientX;\n\t                this.dy = client.y - interaction.prevEvent.clientY;\n\t            }\n\t            else {\n\t                this.dx = page.x - interaction.prevEvent.pageX;\n\t                this.dy = page.y - interaction.prevEvent.pageY;\n\t            }\n\t        }\n\t        if (interaction.prevEvent && interaction.prevEvent.detail === 'inertia'\n\t            && !inertiaStatus.active\n\t            && options[action].inertia && options[action].inertia.zeroResumeDelta) {\n\t\n\t            inertiaStatus.resumeDx += this.dx;\n\t            inertiaStatus.resumeDy += this.dy;\n\t\n\t            this.dx = this.dy = 0;\n\t        }\n\t\n\t        if (action === 'resize' && interaction.resizeAxes) {\n\t            if (options.resize.square) {\n\t                if (interaction.resizeAxes === 'y') {\n\t                    this.dx = this.dy;\n\t                }\n\t                else {\n\t                    this.dy = this.dx;\n\t                }\n\t                this.axes = 'xy';\n\t            }\n\t            else {\n\t                this.axes = interaction.resizeAxes;\n\t\n\t                if (interaction.resizeAxes === 'x') {\n\t                    this.dy = 0;\n\t                }\n\t                else if (interaction.resizeAxes === 'y') {\n\t                    this.dx = 0;\n\t                }\n\t            }\n\t        }\n\t        else if (action === 'gesture') {\n\t            this.touches = [pointers[0], pointers[1]];\n\t\n\t            if (starting) {\n\t                this.distance = touchDistance(pointers, deltaSource);\n\t                this.box      = touchBBox(pointers);\n\t                this.scale    = 1;\n\t                this.ds       = 0;\n\t                this.angle    = touchAngle(pointers, undefined, deltaSource);\n\t                this.da       = 0;\n\t            }\n\t            else if (ending || event instanceof InteractEvent) {\n\t                this.distance = interaction.prevEvent.distance;\n\t                this.box      = interaction.prevEvent.box;\n\t                this.scale    = interaction.prevEvent.scale;\n\t                this.ds       = this.scale - 1;\n\t                this.angle    = interaction.prevEvent.angle;\n\t                this.da       = this.angle - interaction.gesture.startAngle;\n\t            }\n\t            else {\n\t                this.distance = touchDistance(pointers, deltaSource);\n\t                this.box      = touchBBox(pointers);\n\t                this.scale    = this.distance / interaction.gesture.startDistance;\n\t                this.angle    = touchAngle(pointers, interaction.gesture.prevAngle, deltaSource);\n\t\n\t                this.ds = this.scale - interaction.gesture.prevScale;\n\t                this.da = this.angle - interaction.gesture.prevAngle;\n\t            }\n\t        }\n\t\n\t        if (starting) {\n\t            this.timeStamp = interaction.downTimes[0];\n\t            this.dt        = 0;\n\t            this.duration  = 0;\n\t            this.speed     = 0;\n\t            this.velocityX = 0;\n\t            this.velocityY = 0;\n\t        }\n\t        else if (phase === 'inertiastart') {\n\t            this.timeStamp = interaction.prevEvent.timeStamp;\n\t            this.dt        = interaction.prevEvent.dt;\n\t            this.duration  = interaction.prevEvent.duration;\n\t            this.speed     = interaction.prevEvent.speed;\n\t            this.velocityX = interaction.prevEvent.velocityX;\n\t            this.velocityY = interaction.prevEvent.velocityY;\n\t        }\n\t        else {\n\t            this.timeStamp = new Date().getTime();\n\t            this.dt        = this.timeStamp - interaction.prevEvent.timeStamp;\n\t            this.duration  = this.timeStamp - interaction.downTimes[0];\n\t\n\t            if (event instanceof InteractEvent) {\n\t                var dx = this[sourceX] - interaction.prevEvent[sourceX],\n\t                    dy = this[sourceY] - interaction.prevEvent[sourceY],\n\t                    dt = this.dt / 1000;\n\t\n\t                this.speed = hypot(dx, dy) / dt;\n\t                this.velocityX = dx / dt;\n\t                this.velocityY = dy / dt;\n\t            }\n\t            // if normal move or end event, use previous user event coords\n\t            else {\n\t                // speed and velocity in pixels per second\n\t                this.speed = interaction.pointerDelta[deltaSource].speed;\n\t                this.velocityX = interaction.pointerDelta[deltaSource].vx;\n\t                this.velocityY = interaction.pointerDelta[deltaSource].vy;\n\t            }\n\t        }\n\t\n\t        if ((ending || phase === 'inertiastart')\n\t            && interaction.prevEvent.speed > 600 && this.timeStamp - interaction.prevEvent.timeStamp < 150) {\n\t\n\t            var angle = 180 * Math.atan2(interaction.prevEvent.velocityY, interaction.prevEvent.velocityX) / Math.PI,\n\t                overlap = 22.5;\n\t\n\t            if (angle < 0) {\n\t                angle += 360;\n\t            }\n\t\n\t            var left = 135 - overlap <= angle && angle < 225 + overlap,\n\t                up   = 225 - overlap <= angle && angle < 315 + overlap,\n\t\n\t                right = !left && (315 - overlap <= angle || angle <  45 + overlap),\n\t                down  = !up   &&   45 - overlap <= angle && angle < 135 + overlap;\n\t\n\t            this.swipe = {\n\t                up   : up,\n\t                down : down,\n\t                left : left,\n\t                right: right,\n\t                angle: angle,\n\t                speed: interaction.prevEvent.speed,\n\t                velocity: {\n\t                    x: interaction.prevEvent.velocityX,\n\t                    y: interaction.prevEvent.velocityY\n\t                }\n\t            };\n\t        }\n\t    }\n\t\n\t    InteractEvent.prototype = {\n\t        preventDefault: blank,\n\t        stopImmediatePropagation: function () {\n\t            this.immediatePropagationStopped = this.propagationStopped = true;\n\t        },\n\t        stopPropagation: function () {\n\t            this.propagationStopped = true;\n\t        }\n\t    };\n\t\n\t    function preventOriginalDefault () {\n\t        this.originalEvent.preventDefault();\n\t    }\n\t\n\t    function getActionCursor (action) {\n\t        var cursor = '';\n\t\n\t        if (action.name === 'drag') {\n\t            cursor =  actionCursors.drag;\n\t        }\n\t        if (action.name === 'resize') {\n\t            if (action.axis) {\n\t                cursor =  actionCursors[action.name + action.axis];\n\t            }\n\t            else if (action.edges) {\n\t                var cursorKey = 'resize',\n\t                    edgeNames = ['top', 'bottom', 'left', 'right'];\n\t\n\t                for (var i = 0; i < 4; i++) {\n\t                    if (action.edges[edgeNames[i]]) {\n\t                        cursorKey += edgeNames[i];\n\t                    }\n\t                }\n\t\n\t                cursor = actionCursors[cursorKey];\n\t            }\n\t        }\n\t\n\t        return cursor;\n\t    }\n\t\n\t    function checkResizeEdge (name, value, page, element, interactableElement, rect, margin) {\n\t        // false, '', undefined, null\n\t        if (!value) { return false; }\n\t\n\t        // true value, use pointer coords and element rect\n\t        if (value === true) {\n\t            // if dimensions are negative, \"switch\" edges\n\t            var width = isNumber(rect.width)? rect.width : rect.right - rect.left,\n\t                height = isNumber(rect.height)? rect.height : rect.bottom - rect.top;\n\t\n\t            if (width < 0) {\n\t                if      (name === 'left' ) { name = 'right'; }\n\t                else if (name === 'right') { name = 'left' ; }\n\t            }\n\t            if (height < 0) {\n\t                if      (name === 'top'   ) { name = 'bottom'; }\n\t                else if (name === 'bottom') { name = 'top'   ; }\n\t            }\n\t\n\t            if (name === 'left'  ) { return page.x < ((width  >= 0? rect.left: rect.right ) + margin); }\n\t            if (name === 'top'   ) { return page.y < ((height >= 0? rect.top : rect.bottom) + margin); }\n\t\n\t            if (name === 'right' ) { return page.x > ((width  >= 0? rect.right : rect.left) - margin); }\n\t            if (name === 'bottom') { return page.y > ((height >= 0? rect.bottom: rect.top ) - margin); }\n\t        }\n\t\n\t        // the remaining checks require an element\n\t        if (!isElement(element)) { return false; }\n\t\n\t        return isElement(value)\n\t                    // the value is an element to use as a resize handle\n\t                    ? value === element\n\t                    // otherwise check if element matches value as selector\n\t                    : matchesUpTo(element, value, interactableElement);\n\t    }\n\t\n\t    function defaultActionChecker (pointer, interaction, element) {\n\t        var rect = this.getRect(element),\n\t            shouldResize = false,\n\t            action = null,\n\t            resizeAxes = null,\n\t            resizeEdges,\n\t            page = extend({}, interaction.curCoords.page),\n\t            options = this.options;\n\t\n\t        if (!rect) { return null; }\n\t\n\t        if (actionIsEnabled.resize && options.resize.enabled) {\n\t            var resizeOptions = options.resize;\n\t\n\t            resizeEdges = {\n\t                left: false, right: false, top: false, bottom: false\n\t            };\n\t\n\t            // if using resize.edges\n\t            if (isObject(resizeOptions.edges)) {\n\t                for (var edge in resizeEdges) {\n\t                    resizeEdges[edge] = checkResizeEdge(edge,\n\t                                                        resizeOptions.edges[edge],\n\t                                                        page,\n\t                                                        interaction._eventTarget,\n\t                                                        element,\n\t                                                        rect,\n\t                                                        resizeOptions.margin || margin);\n\t                }\n\t\n\t                resizeEdges.left = resizeEdges.left && !resizeEdges.right;\n\t                resizeEdges.top  = resizeEdges.top  && !resizeEdges.bottom;\n\t\n\t                shouldResize = resizeEdges.left || resizeEdges.right || resizeEdges.top || resizeEdges.bottom;\n\t            }\n\t            else {\n\t                var right  = options.resize.axis !== 'y' && page.x > (rect.right  - margin),\n\t                    bottom = options.resize.axis !== 'x' && page.y > (rect.bottom - margin);\n\t\n\t                shouldResize = right || bottom;\n\t                resizeAxes = (right? 'x' : '') + (bottom? 'y' : '');\n\t            }\n\t        }\n\t\n\t        action = shouldResize\n\t            ? 'resize'\n\t            : actionIsEnabled.drag && options.drag.enabled\n\t                ? 'drag'\n\t                : null;\n\t\n\t        if (actionIsEnabled.gesture\n\t            && interaction.pointerIds.length >=2\n\t            && !(interaction.dragging || interaction.resizing)) {\n\t            action = 'gesture';\n\t        }\n\t\n\t        if (action) {\n\t            return {\n\t                name: action,\n\t                axis: resizeAxes,\n\t                edges: resizeEdges\n\t            };\n\t        }\n\t\n\t        return null;\n\t    }\n\t\n\t    // Check if action is enabled globally and the current target supports it\n\t    // If so, return the validated action. Otherwise, return null\n\t    function validateAction (action, interactable) {\n\t        if (!isObject(action)) { return null; }\n\t\n\t        var actionName = action.name,\n\t            options = interactable.options;\n\t\n\t        if ((  (actionName  === 'resize'   && options.resize.enabled )\n\t            || (actionName      === 'drag'     && options.drag.enabled  )\n\t            || (actionName      === 'gesture'  && options.gesture.enabled))\n\t            && actionIsEnabled[actionName]) {\n\t\n\t            if (actionName === 'resize' || actionName === 'resizeyx') {\n\t                actionName = 'resizexy';\n\t            }\n\t\n\t            return action;\n\t        }\n\t        return null;\n\t    }\n\t\n\t    var listeners = {},\n\t        interactionListeners = [\n\t            'dragStart', 'dragMove', 'resizeStart', 'resizeMove', 'gestureStart', 'gestureMove',\n\t            'pointerOver', 'pointerOut', 'pointerHover', 'selectorDown',\n\t            'pointerDown', 'pointerMove', 'pointerUp', 'pointerCancel', 'pointerEnd',\n\t            'addPointer', 'removePointer', 'recordPointer', 'autoScrollMove'\n\t        ];\n\t\n\t    for (var i = 0, len = interactionListeners.length; i < len; i++) {\n\t        var name = interactionListeners[i];\n\t\n\t        listeners[name] = doOnInteractions(name);\n\t    }\n\t\n\t    // bound to the interactable context when a DOM event\n\t    // listener is added to a selector interactable\n\t    function delegateListener (event, useCapture) {\n\t        var fakeEvent = {},\n\t            delegated = delegatedEvents[event.type],\n\t            eventTarget = getActualElement(event.path\n\t                                           ? event.path[0]\n\t                                           : event.target),\n\t            element = eventTarget;\n\t\n\t        useCapture = useCapture? true: false;\n\t\n\t        // duplicate the event so that currentTarget can be changed\n\t        for (var prop in event) {\n\t            fakeEvent[prop] = event[prop];\n\t        }\n\t\n\t        fakeEvent.originalEvent = event;\n\t        fakeEvent.preventDefault = preventOriginalDefault;\n\t\n\t        // climb up document tree looking for selector matches\n\t        while (isElement(element)) {\n\t            for (var i = 0; i < delegated.selectors.length; i++) {\n\t                var selector = delegated.selectors[i],\n\t                    context = delegated.contexts[i];\n\t\n\t                if (matchesSelector(element, selector)\n\t                    && nodeContains(context, eventTarget)\n\t                    && nodeContains(context, element)) {\n\t\n\t                    var listeners = delegated.listeners[i];\n\t\n\t                    fakeEvent.currentTarget = element;\n\t\n\t                    for (var j = 0; j < listeners.length; j++) {\n\t                        if (listeners[j][1] === useCapture) {\n\t                            listeners[j][0](fakeEvent);\n\t                        }\n\t                    }\n\t                }\n\t            }\n\t\n\t            element = parentElement(element);\n\t        }\n\t    }\n\t\n\t    function delegateUseCapture (event) {\n\t        return delegateListener.call(this, event, true);\n\t    }\n\t\n\t    interactables.indexOfElement = function indexOfElement (element, context) {\n\t        context = context || document;\n\t\n\t        for (var i = 0; i < this.length; i++) {\n\t            var interactable = this[i];\n\t\n\t            if ((interactable.selector === element\n\t                && (interactable._context === context))\n\t                || (!interactable.selector && interactable._element === element)) {\n\t\n\t                return i;\n\t            }\n\t        }\n\t        return -1;\n\t    };\n\t\n\t    interactables.get = function interactableGet (element, options) {\n\t        return this[this.indexOfElement(element, options && options.context)];\n\t    };\n\t\n\t    interactables.forEachSelector = function (callback) {\n\t        for (var i = 0; i < this.length; i++) {\n\t            var interactable = this[i];\n\t\n\t            if (!interactable.selector) {\n\t                continue;\n\t            }\n\t\n\t            var ret = callback(interactable, interactable.selector, interactable._context, i, this);\n\t\n\t            if (ret !== undefined) {\n\t                return ret;\n\t            }\n\t        }\n\t    };\n\t\n\t    /*\\\n\t     * interact\n\t     [ method ]\n\t     *\n\t     * The methods of this variable can be used to set elements as\n\t     * interactables and also to change various default settings.\n\t     *\n\t     * Calling it as a function and passing an element or a valid CSS selector\n\t     * string returns an Interactable object which has various methods to\n\t     * configure it.\n\t     *\n\t     - element (Element | string) The HTML or SVG Element to interact with or CSS selector\n\t     = (object) An @Interactable\n\t     *\n\t     > Usage\n\t     | interact(document.getElementById('draggable')).draggable(true);\n\t     |\n\t     | var rectables = interact('rect');\n\t     | rectables\n\t     |     .gesturable(true)\n\t     |     .on('gesturemove', function (event) {\n\t     |         // something cool...\n\t     |     })\n\t     |     .autoScroll(true);\n\t    \\*/\n\t    function interact (element, options) {\n\t        return interactables.get(element, options) || new Interactable(element, options);\n\t    }\n\t\n\t    /*\\\n\t     * Interactable\n\t     [ property ]\n\t     **\n\t     * Object type returned by @interact\n\t    \\*/\n\t    function Interactable (element, options) {\n\t        this._element = element;\n\t        this._iEvents = this._iEvents || {};\n\t\n\t        var _window;\n\t\n\t        if (trySelector(element)) {\n\t            this.selector = element;\n\t\n\t            var context = options && options.context;\n\t\n\t            _window = context? getWindow(context) : window;\n\t\n\t            if (context && (_window.Node\n\t                    ? context instanceof _window.Node\n\t                    : (isElement(context) || context === _window.document))) {\n\t\n\t                this._context = context;\n\t            }\n\t        }\n\t        else {\n\t            _window = getWindow(element);\n\t\n\t            if (isElement(element, _window)) {\n\t\n\t                if (supportsPointerEvent) {\n\t                    events.add(this._element, pEventTypes.down, listeners.pointerDown );\n\t                    events.add(this._element, pEventTypes.move, listeners.pointerHover);\n\t                }\n\t                else {\n\t                    events.add(this._element, 'mousedown' , listeners.pointerDown );\n\t                    events.add(this._element, 'mousemove' , listeners.pointerHover);\n\t                    events.add(this._element, 'touchstart', listeners.pointerDown );\n\t                    events.add(this._element, 'touchmove' , listeners.pointerHover);\n\t                }\n\t            }\n\t        }\n\t\n\t        this._doc = _window.document;\n\t\n\t        if (!contains(documents, this._doc)) {\n\t            listenToDocument(this._doc);\n\t        }\n\t\n\t        interactables.push(this);\n\t\n\t        this.set(options);\n\t    }\n\t\n\t    Interactable.prototype = {\n\t        setOnEvents: function (action, phases) {\n\t            if (action === 'drop') {\n\t                if (isFunction(phases.ondrop)          ) { this.ondrop           = phases.ondrop          ; }\n\t                if (isFunction(phases.ondropactivate)  ) { this.ondropactivate   = phases.ondropactivate  ; }\n\t                if (isFunction(phases.ondropdeactivate)) { this.ondropdeactivate = phases.ondropdeactivate; }\n\t                if (isFunction(phases.ondragenter)     ) { this.ondragenter      = phases.ondragenter     ; }\n\t                if (isFunction(phases.ondragleave)     ) { this.ondragleave      = phases.ondragleave     ; }\n\t                if (isFunction(phases.ondropmove)      ) { this.ondropmove       = phases.ondropmove      ; }\n\t            }\n\t            else {\n\t                action = 'on' + action;\n\t\n\t                if (isFunction(phases.onstart)       ) { this[action + 'start'         ] = phases.onstart         ; }\n\t                if (isFunction(phases.onmove)        ) { this[action + 'move'          ] = phases.onmove          ; }\n\t                if (isFunction(phases.onend)         ) { this[action + 'end'           ] = phases.onend           ; }\n\t                if (isFunction(phases.oninertiastart)) { this[action + 'inertiastart'  ] = phases.oninertiastart  ; }\n\t            }\n\t\n\t            return this;\n\t        },\n\t\n\t        /*\\\n\t         * Interactable.draggable\n\t         [ method ]\n\t         *\n\t         * Gets or sets whether drag actions can be performed on the\n\t         * Interactable\n\t         *\n\t         = (boolean) Indicates if this can be the target of drag events\n\t         | var isDraggable = interact('ul li').draggable();\n\t         * or\n\t         - options (boolean | object) #optional true/false or An object with event listeners to be fired on drag events (object makes the Interactable draggable)\n\t         = (object) This Interactable\n\t         | interact(element).draggable({\n\t         |     onstart: function (event) {},\n\t         |     onmove : function (event) {},\n\t         |     onend  : function (event) {},\n\t         |\n\t         |     // the axis in which the first movement must be\n\t         |     // for the drag sequence to start\n\t         |     // 'xy' by default - any direction\n\t         |     axis: 'x' || 'y' || 'xy',\n\t         |\n\t         |     // max number of drags that can happen concurrently\n\t         |     // with elements of this Interactable. Infinity by default\n\t         |     max: Infinity,\n\t         |\n\t         |     // max number of drags that can target the same element+Interactable\n\t         |     // 1 by default\n\t         |     maxPerElement: 2\n\t         | });\n\t        \\*/\n\t        draggable: function (options) {\n\t            if (isObject(options)) {\n\t                this.options.drag.enabled = options.enabled === false? false: true;\n\t                this.setPerAction('drag', options);\n\t                this.setOnEvents('drag', options);\n\t\n\t                if (/^x$|^y$|^xy$/.test(options.axis)) {\n\t                    this.options.drag.axis = options.axis;\n\t                }\n\t                else if (options.axis === null) {\n\t                    delete this.options.drag.axis;\n\t                }\n\t\n\t                return this;\n\t            }\n\t\n\t            if (isBool(options)) {\n\t                this.options.drag.enabled = options;\n\t\n\t                return this;\n\t            }\n\t\n\t            return this.options.drag;\n\t        },\n\t\n\t        setPerAction: function (action, options) {\n\t            // for all the default per-action options\n\t            for (var option in options) {\n\t                // if this option exists for this action\n\t                if (option in defaultOptions[action]) {\n\t                    // if the option in the options arg is an object value\n\t                    if (isObject(options[option])) {\n\t                        // duplicate the object\n\t                        this.options[action][option] = extend(this.options[action][option] || {}, options[option]);\n\t\n\t                        if (isObject(defaultOptions.perAction[option]) && 'enabled' in defaultOptions.perAction[option]) {\n\t                            this.options[action][option].enabled = options[option].enabled === false? false : true;\n\t                        }\n\t                    }\n\t                    else if (isBool(options[option]) && isObject(defaultOptions.perAction[option])) {\n\t                        this.options[action][option].enabled = options[option];\n\t                    }\n\t                    else if (options[option] !== undefined) {\n\t                        // or if it's not undefined, do a plain assignment\n\t                        this.options[action][option] = options[option];\n\t                    }\n\t                }\n\t            }\n\t        },\n\t\n\t        /*\\\n\t         * Interactable.dropzone\n\t         [ method ]\n\t         *\n\t         * Returns or sets whether elements can be dropped onto this\n\t         * Interactable to trigger drop events\n\t         *\n\t         * Dropzones can receive the following events:\n\t         *  - `dropactivate` and `dropdeactivate` when an acceptable drag starts and ends\n\t         *  - `dragenter` and `dragleave` when a draggable enters and leaves the dropzone\n\t         *  - `dragmove` when a draggable that has entered the dropzone is moved\n\t         *  - `drop` when a draggable is dropped into this dropzone\n\t         *\n\t         *  Use the `accept` option to allow only elements that match the given CSS selector or element.\n\t         *\n\t         *  Use the `overlap` option to set how drops are checked for. The allowed values are:\n\t         *   - `'pointer'`, the pointer must be over the dropzone (default)\n\t         *   - `'center'`, the draggable element's center must be over the dropzone\n\t         *   - a number from 0-1 which is the `(intersection area) / (draggable area)`.\n\t         *       e.g. `0.5` for drop to happen when half of the area of the\n\t         *       draggable is over the dropzone\n\t         *\n\t         - options (boolean | object | null) #optional The new value to be set.\n\t         | interact('.drop').dropzone({\n\t         |   accept: '.can-drop' || document.getElementById('single-drop'),\n\t         |   overlap: 'pointer' || 'center' || zeroToOne\n\t         | }\n\t         = (boolean | object) The current setting or this Interactable\n\t        \\*/\n\t        dropzone: function (options) {\n\t            if (isObject(options)) {\n\t                this.options.drop.enabled = options.enabled === false? false: true;\n\t                this.setOnEvents('drop', options);\n\t\n\t                if (/^(pointer|center)$/.test(options.overlap)) {\n\t                    this.options.drop.overlap = options.overlap;\n\t                }\n\t                else if (isNumber(options.overlap)) {\n\t                    this.options.drop.overlap = Math.max(Math.min(1, options.overlap), 0);\n\t                }\n\t                if ('accept' in options) {\n\t                  this.options.drop.accept = options.accept;\n\t                }\n\t                if ('checker' in options) {\n\t                  this.options.drop.checker = options.checker;\n\t                }\n\t\n\t                return this;\n\t            }\n\t\n\t            if (isBool(options)) {\n\t                this.options.drop.enabled = options;\n\t\n\t                return this;\n\t            }\n\t\n\t            return this.options.drop;\n\t        },\n\t\n\t        dropCheck: function (dragEvent, event, draggable, draggableElement, dropElement, rect) {\n\t            var dropped = false;\n\t\n\t            // if the dropzone has no rect (eg. display: none)\n\t            // call the custom dropChecker or just return false\n\t            if (!(rect = rect || this.getRect(dropElement))) {\n\t                return (this.options.drop.checker\n\t                    ? this.options.drop.checker(dragEvent, event, dropped, this, dropElement, draggable, draggableElement)\n\t                    : false);\n\t            }\n\t\n\t            var dropOverlap = this.options.drop.overlap;\n\t\n\t            if (dropOverlap === 'pointer') {\n\t                var page = getPageXY(dragEvent),\n\t                    origin = getOriginXY(draggable, draggableElement),\n\t                    horizontal,\n\t                    vertical;\n\t\n\t                page.x += origin.x;\n\t                page.y += origin.y;\n\t\n\t                horizontal = (page.x > rect.left) && (page.x < rect.right);\n\t                vertical   = (page.y > rect.top ) && (page.y < rect.bottom);\n\t\n\t                dropped = horizontal && vertical;\n\t            }\n\t\n\t            var dragRect = draggable.getRect(draggableElement);\n\t\n\t            if (dropOverlap === 'center') {\n\t                var cx = dragRect.left + dragRect.width  / 2,\n\t                    cy = dragRect.top  + dragRect.height / 2;\n\t\n\t                dropped = cx >= rect.left && cx <= rect.right && cy >= rect.top && cy <= rect.bottom;\n\t            }\n\t\n\t            if (isNumber(dropOverlap)) {\n\t                var overlapArea  = (Math.max(0, Math.min(rect.right , dragRect.right ) - Math.max(rect.left, dragRect.left))\n\t                                  * Math.max(0, Math.min(rect.bottom, dragRect.bottom) - Math.max(rect.top , dragRect.top ))),\n\t                    overlapRatio = overlapArea / (dragRect.width * dragRect.height);\n\t\n\t                dropped = overlapRatio >= dropOverlap;\n\t            }\n\t\n\t            if (this.options.drop.checker) {\n\t                dropped = this.options.drop.checker(dragEvent, event, dropped, this, dropElement, draggable, draggableElement);\n\t            }\n\t\n\t            return dropped;\n\t        },\n\t\n\t        /*\\\n\t         * Interactable.dropChecker\n\t         [ method ]\n\t         *\n\t         * DEPRECATED. Use interactable.dropzone({ checker: function... }) instead.\n\t         *\n\t         * Gets or sets the function used to check if a dragged element is\n\t         * over this Interactable.\n\t         *\n\t         - checker (function) #optional The function that will be called when checking for a drop\n\t         = (Function | Interactable) The checker function or this Interactable\n\t         *\n\t         * The checker function takes the following arguments:\n\t         *\n\t         - dragEvent (InteractEvent) The related dragmove or dragend event\n\t         - event (TouchEvent | PointerEvent | MouseEvent) The user move/up/end Event related to the dragEvent\n\t         - dropped (boolean) The value from the default drop checker\n\t         - dropzone (Interactable) The dropzone interactable\n\t         - dropElement (Element) The dropzone element\n\t         - draggable (Interactable) The Interactable being dragged\n\t         - draggableElement (Element) The actual element that's being dragged\n\t         *\n\t         > Usage:\n\t         | interact(target)\n\t         | .dropChecker(function(dragEvent,         // related dragmove or dragend event\n\t         |                       event,             // TouchEvent/PointerEvent/MouseEvent\n\t         |                       dropped,           // bool result of the default checker\n\t         |                       dropzone,          // dropzone Interactable\n\t         |                       dropElement,       // dropzone elemnt\n\t         |                       draggable,         // draggable Interactable\n\t         |                       draggableElement) {// draggable element\n\t         |\n\t         |   return dropped && event.target.hasAttribute('allow-drop');\n\t         | }\n\t        \\*/\n\t        dropChecker: function (checker) {\n\t            if (isFunction(checker)) {\n\t                this.options.drop.checker = checker;\n\t\n\t                return this;\n\t            }\n\t            if (checker === null) {\n\t                delete this.options.getRect;\n\t\n\t                return this;\n\t            }\n\t\n\t            return this.options.drop.checker;\n\t        },\n\t\n\t        /*\\\n\t         * Interactable.accept\n\t         [ method ]\n\t         *\n\t         * Deprecated. add an `accept` property to the options object passed to\n\t         * @Interactable.dropzone instead.\n\t         *\n\t         * Gets or sets the Element or CSS selector match that this\n\t         * Interactable accepts if it is a dropzone.\n\t         *\n\t         - newValue (Element | string | null) #optional\n\t         * If it is an Element, then only that element can be dropped into this dropzone.\n\t         * If it is a string, the element being dragged must match it as a selector.\n\t         * If it is null, the accept options is cleared - it accepts any element.\n\t         *\n\t         = (string | Element | null | Interactable) The current accept option if given `undefined` or this Interactable\n\t        \\*/\n\t        accept: function (newValue) {\n\t            if (isElement(newValue)) {\n\t                this.options.drop.accept = newValue;\n\t\n\t                return this;\n\t            }\n\t\n\t            // test if it is a valid CSS selector\n\t            if (trySelector(newValue)) {\n\t                this.options.drop.accept = newValue;\n\t\n\t                return this;\n\t            }\n\t\n\t            if (newValue === null) {\n\t                delete this.options.drop.accept;\n\t\n\t                return this;\n\t            }\n\t\n\t            return this.options.drop.accept;\n\t        },\n\t\n\t        /*\\\n\t         * Interactable.resizable\n\t         [ method ]\n\t         *\n\t         * Gets or sets whether resize actions can be performed on the\n\t         * Interactable\n\t         *\n\t         = (boolean) Indicates if this can be the target of resize elements\n\t         | var isResizeable = interact('input[type=text]').resizable();\n\t         * or\n\t         - options (boolean | object) #optional true/false or An object with event listeners to be fired on resize events (object makes the Interactable resizable)\n\t         = (object) This Interactable\n\t         | interact(element).resizable({\n\t         |     onstart: function (event) {},\n\t         |     onmove : function (event) {},\n\t         |     onend  : function (event) {},\n\t         |\n\t         |     edges: {\n\t         |       top   : true,       // Use pointer coords to check for resize.\n\t         |       left  : false,      // Disable resizing from left edge.\n\t         |       bottom: '.resize-s',// Resize if pointer target matches selector\n\t         |       right : handleEl    // Resize if pointer target is the given Element\n\t         |     },\n\t         |\n\t         |     // Width and height can be adjusted independently. When `true`, width and\n\t         |     // height are adjusted at a 1:1 ratio.\n\t         |     square: false,\n\t         |\n\t         |     // Width and height can be adjusted independently. When `true`, width and\n\t         |     // height maintain the aspect ratio they had when resizing started.\n\t         |     preserveAspectRatio: false,\n\t         |\n\t         |     // a value of 'none' will limit the resize rect to a minimum of 0x0\n\t         |     // 'negate' will allow the rect to have negative width/height\n\t         |     // 'reposition' will keep the width/height positive by swapping\n\t         |     // the top and bottom edges and/or swapping the left and right edges\n\t         |     invert: 'none' || 'negate' || 'reposition'\n\t         |\n\t         |     // limit multiple resizes.\n\t         |     // See the explanation in the @Interactable.draggable example\n\t         |     max: Infinity,\n\t         |     maxPerElement: 1,\n\t         | });\n\t        \\*/\n\t        resizable: function (options) {\n\t            if (isObject(options)) {\n\t                this.options.resize.enabled = options.enabled === false? false: true;\n\t                this.setPerAction('resize', options);\n\t                this.setOnEvents('resize', options);\n\t\n\t                if (/^x$|^y$|^xy$/.test(options.axis)) {\n\t                    this.options.resize.axis = options.axis;\n\t                }\n\t                else if (options.axis === null) {\n\t                    this.options.resize.axis = defaultOptions.resize.axis;\n\t                }\n\t\n\t                if (isBool(options.preserveAspectRatio)) {\n\t                    this.options.resize.preserveAspectRatio = options.preserveAspectRatio;\n\t                }\n\t                else if (isBool(options.square)) {\n\t                    this.options.resize.square = options.square;\n\t                }\n\t\n\t                return this;\n\t            }\n\t            if (isBool(options)) {\n\t                this.options.resize.enabled = options;\n\t\n\t                return this;\n\t            }\n\t            return this.options.resize;\n\t        },\n\t\n\t        /*\\\n\t         * Interactable.squareResize\n\t         [ method ]\n\t         *\n\t         * Deprecated. Add a `square: true || false` property to @Interactable.resizable instead\n\t         *\n\t         * Gets or sets whether resizing is forced 1:1 aspect\n\t         *\n\t         = (boolean) Current setting\n\t         *\n\t         * or\n\t         *\n\t         - newValue (boolean) #optional\n\t         = (object) this Interactable\n\t        \\*/\n\t        squareResize: function (newValue) {\n\t            if (isBool(newValue)) {\n\t                this.options.resize.square = newValue;\n\t\n\t                return this;\n\t            }\n\t\n\t            if (newValue === null) {\n\t                delete this.options.resize.square;\n\t\n\t                return this;\n\t            }\n\t\n\t            return this.options.resize.square;\n\t        },\n\t\n\t        /*\\\n\t         * Interactable.gesturable\n\t         [ method ]\n\t         *\n\t         * Gets or sets whether multitouch gestures can be performed on the\n\t         * Interactable's element\n\t         *\n\t         = (boolean) Indicates if this can be the target of gesture events\n\t         | var isGestureable = interact(element).gesturable();\n\t         * or\n\t         - options (boolean | object) #optional true/false or An object with event listeners to be fired on gesture events (makes the Interactable gesturable)\n\t         = (object) this Interactable\n\t         | interact(element).gesturable({\n\t         |     onstart: function (event) {},\n\t         |     onmove : function (event) {},\n\t         |     onend  : function (event) {},\n\t         |\n\t         |     // limit multiple gestures.\n\t         |     // See the explanation in @Interactable.draggable example\n\t         |     max: Infinity,\n\t         |     maxPerElement: 1,\n\t         | });\n\t        \\*/\n\t        gesturable: function (options) {\n\t            if (isObject(options)) {\n\t                this.options.gesture.enabled = options.enabled === false? false: true;\n\t                this.setPerAction('gesture', options);\n\t                this.setOnEvents('gesture', options);\n\t\n\t                return this;\n\t            }\n\t\n\t            if (isBool(options)) {\n\t                this.options.gesture.enabled = options;\n\t\n\t                return this;\n\t            }\n\t\n\t            return this.options.gesture;\n\t        },\n\t\n\t        /*\\\n\t         * Interactable.autoScroll\n\t         [ method ]\n\t         **\n\t         * Deprecated. Add an `autoscroll` property to the options object\n\t         * passed to @Interactable.draggable or @Interactable.resizable instead.\n\t         *\n\t         * Returns or sets whether dragging and resizing near the edges of the\n\t         * window/container trigger autoScroll for this Interactable\n\t         *\n\t         = (object) Object with autoScroll properties\n\t         *\n\t         * or\n\t         *\n\t         - options (object | boolean) #optional\n\t         * options can be:\n\t         * - an object with margin, distance and interval properties,\n\t         * - true or false to enable or disable autoScroll or\n\t         = (Interactable) this Interactable\n\t        \\*/\n\t        autoScroll: function (options) {\n\t            if (isObject(options)) {\n\t                options = extend({ actions: ['drag', 'resize']}, options);\n\t            }\n\t            else if (isBool(options)) {\n\t                options = { actions: ['drag', 'resize'], enabled: options };\n\t            }\n\t\n\t            return this.setOptions('autoScroll', options);\n\t        },\n\t\n\t        /*\\\n\t         * Interactable.snap\n\t         [ method ]\n\t         **\n\t         * Deprecated. Add a `snap` property to the options object passed\n\t         * to @Interactable.draggable or @Interactable.resizable instead.\n\t         *\n\t         * Returns or sets if and how action coordinates are snapped. By\n\t         * default, snapping is relative to the pointer coordinates. You can\n\t         * change this by setting the\n\t         * [`elementOrigin`](https://github.com/taye/interact.js/pull/72).\n\t         **\n\t         = (boolean | object) `false` if snap is disabled; object with snap properties if snap is enabled\n\t         **\n\t         * or\n\t         **\n\t         - options (object | boolean | null) #optional\n\t         = (Interactable) this Interactable\n\t         > Usage\n\t         | interact(document.querySelector('#thing')).snap({\n\t         |     targets: [\n\t         |         // snap to this specific point\n\t         |         {\n\t         |             x: 100,\n\t         |             y: 100,\n\t         |             range: 25\n\t         |         },\n\t         |         // give this function the x and y page coords and snap to the object returned\n\t         |         function (x, y) {\n\t         |             return {\n\t         |                 x: x,\n\t         |                 y: (75 + 50 * Math.sin(x * 0.04)),\n\t         |                 range: 40\n\t         |             };\n\t         |         },\n\t         |         // create a function that snaps to a grid\n\t         |         interact.createSnapGrid({\n\t         |             x: 50,\n\t         |             y: 50,\n\t         |             range: 10,              // optional\n\t         |             offset: { x: 5, y: 10 } // optional\n\t         |         })\n\t         |     ],\n\t         |     // do not snap during normal movement.\n\t         |     // Instead, trigger only one snapped move event\n\t         |     // immediately before the end event.\n\t         |     endOnly: true,\n\t         |\n\t         |     relativePoints: [\n\t         |         { x: 0, y: 0 },  // snap relative to the top left of the element\n\t         |         { x: 1, y: 1 },  // and also to the bottom right\n\t         |     ],  \n\t         |\n\t         |     // offset the snap target coordinates\n\t         |     // can be an object with x/y or 'startCoords'\n\t         |     offset: { x: 50, y: 50 }\n\t         |   }\n\t         | });\n\t        \\*/\n\t        snap: function (options) {\n\t            var ret = this.setOptions('snap', options);\n\t\n\t            if (ret === this) { return this; }\n\t\n\t            return ret.drag;\n\t        },\n\t\n\t        setOptions: function (option, options) {\n\t            var actions = options && isArray(options.actions)\n\t                    ? options.actions\n\t                    : ['drag'];\n\t\n\t            var i;\n\t\n\t            if (isObject(options) || isBool(options)) {\n\t                for (i = 0; i < actions.length; i++) {\n\t                    var action = /resize/.test(actions[i])? 'resize' : actions[i];\n\t\n\t                    if (!isObject(this.options[action])) { continue; }\n\t\n\t                    var thisOption = this.options[action][option];\n\t\n\t                    if (isObject(options)) {\n\t                        extend(thisOption, options);\n\t                        thisOption.enabled = options.enabled === false? false: true;\n\t\n\t                        if (option === 'snap') {\n\t                            if (thisOption.mode === 'grid') {\n\t                                thisOption.targets = [\n\t                                    interact.createSnapGrid(extend({\n\t                                        offset: thisOption.gridOffset || { x: 0, y: 0 }\n\t                                    }, thisOption.grid || {}))\n\t                                ];\n\t                            }\n\t                            else if (thisOption.mode === 'anchor') {\n\t                                thisOption.targets = thisOption.anchors;\n\t                            }\n\t                            else if (thisOption.mode === 'path') {\n\t                                thisOption.targets = thisOption.paths;\n\t                            }\n\t\n\t                            if ('elementOrigin' in options) {\n\t                                thisOption.relativePoints = [options.elementOrigin];\n\t                            }\n\t                        }\n\t                    }\n\t                    else if (isBool(options)) {\n\t                        thisOption.enabled = options;\n\t                    }\n\t                }\n\t\n\t                return this;\n\t            }\n\t\n\t            var ret = {},\n\t                allActions = ['drag', 'resize', 'gesture'];\n\t\n\t            for (i = 0; i < allActions.length; i++) {\n\t                if (option in defaultOptions[allActions[i]]) {\n\t                    ret[allActions[i]] = this.options[allActions[i]][option];\n\t                }\n\t            }\n\t\n\t            return ret;\n\t        },\n\t\n\t\n\t        /*\\\n\t         * Interactable.inertia\n\t         [ method ]\n\t         **\n\t         * Deprecated. Add an `inertia` property to the options object passed\n\t         * to @Interactable.draggable or @Interactable.resizable instead.\n\t         *\n\t         * Returns or sets if and how events continue to run after the pointer is released\n\t         **\n\t         = (boolean | object) `false` if inertia is disabled; `object` with inertia properties if inertia is enabled\n\t         **\n\t         * or\n\t         **\n\t         - options (object | boolean | null) #optional\n\t         = (Interactable) this Interactable\n\t         > Usage\n\t         | // enable and use default settings\n\t         | interact(element).inertia(true);\n\t         |\n\t         | // enable and use custom settings\n\t         | interact(element).inertia({\n\t         |     // value greater than 0\n\t         |     // high values slow the object down more quickly\n\t         |     resistance     : 16,\n\t         |\n\t         |     // the minimum launch speed (pixels per second) that results in inertia start\n\t         |     minSpeed       : 200,\n\t         |\n\t         |     // inertia will stop when the object slows down to this speed\n\t         |     endSpeed       : 20,\n\t         |\n\t         |     // boolean; should actions be resumed when the pointer goes down during inertia\n\t         |     allowResume    : true,\n\t         |\n\t         |     // boolean; should the jump when resuming from inertia be ignored in event.dx/dy\n\t         |     zeroResumeDelta: false,\n\t         |\n\t         |     // if snap/restrict are set to be endOnly and inertia is enabled, releasing\n\t         |     // the pointer without triggering inertia will animate from the release\n\t         |     // point to the snaped/restricted point in the given amount of time (ms)\n\t         |     smoothEndDuration: 300,\n\t         |\n\t         |     // an array of action types that can have inertia (no gesture)\n\t         |     actions        : ['drag', 'resize']\n\t         | });\n\t         |\n\t         | // reset custom settings and use all defaults\n\t         | interact(element).inertia(null);\n\t        \\*/\n\t        inertia: function (options) {\n\t            var ret = this.setOptions('inertia', options);\n\t\n\t            if (ret === this) { return this; }\n\t\n\t            return ret.drag;\n\t        },\n\t\n\t        getAction: function (pointer, event, interaction, element) {\n\t            var action = this.defaultActionChecker(pointer, interaction, element);\n\t\n\t            if (this.options.actionChecker) {\n\t                return this.options.actionChecker(pointer, event, action, this, element, interaction);\n\t            }\n\t\n\t            return action;\n\t        },\n\t\n\t        defaultActionChecker: defaultActionChecker,\n\t\n\t        /*\\\n\t         * Interactable.actionChecker\n\t         [ method ]\n\t         *\n\t         * Gets or sets the function used to check action to be performed on\n\t         * pointerDown\n\t         *\n\t         - checker (function | null) #optional A function which takes a pointer event, defaultAction string, interactable, element and interaction as parameters and returns an object with name property 'drag' 'resize' or 'gesture' and optionally an `edges` object with boolean 'top', 'left', 'bottom' and right props.\n\t         = (Function | Interactable) The checker function or this Interactable\n\t         *\n\t         | interact('.resize-drag')\n\t         |   .resizable(true)\n\t         |   .draggable(true)\n\t         |   .actionChecker(function (pointer, event, action, interactable, element, interaction) {\n\t         |\n\t         |   if (interact.matchesSelector(event.target, '.drag-handle') {\n\t         |     // force drag with handle target\n\t         |     action.name = drag;\n\t         |   }\n\t         |   else {\n\t         |     // resize from the top and right edges\n\t         |     action.name  = 'resize';\n\t         |     action.edges = { top: true, right: true };\n\t         |   }\n\t         |\n\t         |   return action;\n\t         | });\n\t        \\*/\n\t        actionChecker: function (checker) {\n\t            if (isFunction(checker)) {\n\t                this.options.actionChecker = checker;\n\t\n\t                return this;\n\t            }\n\t\n\t            if (checker === null) {\n\t                delete this.options.actionChecker;\n\t\n\t                return this;\n\t            }\n\t\n\t            return this.options.actionChecker;\n\t        },\n\t\n\t        /*\\\n\t         * Interactable.getRect\n\t         [ method ]\n\t         *\n\t         * The default function to get an Interactables bounding rect. Can be\n\t         * overridden using @Interactable.rectChecker.\n\t         *\n\t         - element (Element) #optional The element to measure.\n\t         = (object) The object's bounding rectangle.\n\t         o {\n\t         o     top   : 0,\n\t         o     left  : 0,\n\t         o     bottom: 0,\n\t         o     right : 0,\n\t         o     width : 0,\n\t         o     height: 0\n\t         o }\n\t        \\*/\n\t        getRect: function rectCheck (element) {\n\t            element = element || this._element;\n\t\n\t            if (this.selector && !(isElement(element))) {\n\t                element = this._context.querySelector(this.selector);\n\t            }\n\t\n\t            return getElementRect(element);\n\t        },\n\t\n\t        /*\\\n\t         * Interactable.rectChecker\n\t         [ method ]\n\t         *\n\t         * Returns or sets the function used to calculate the interactable's\n\t         * element's rectangle\n\t         *\n\t         - checker (function) #optional A function which returns this Interactable's bounding rectangle. See @Interactable.getRect\n\t         = (function | object) The checker function or this Interactable\n\t        \\*/\n\t        rectChecker: function (checker) {\n\t            if (isFunction(checker)) {\n\t                this.getRect = checker;\n\t\n\t                return this;\n\t            }\n\t\n\t            if (checker === null) {\n\t                delete this.options.getRect;\n\t\n\t                return this;\n\t            }\n\t\n\t            return this.getRect;\n\t        },\n\t\n\t        /*\\\n\t         * Interactable.styleCursor\n\t         [ method ]\n\t         *\n\t         * Returns or sets whether the action that would be performed when the\n\t         * mouse on the element are checked on `mousemove` so that the cursor\n\t         * may be styled appropriately\n\t         *\n\t         - newValue (boolean) #optional\n\t         = (boolean | Interactable) The current setting or this Interactable\n\t        \\*/\n\t        styleCursor: function (newValue) {\n\t            if (isBool(newValue)) {\n\t                this.options.styleCursor = newValue;\n\t\n\t                return this;\n\t            }\n\t\n\t            if (newValue === null) {\n\t                delete this.options.styleCursor;\n\t\n\t                return this;\n\t            }\n\t\n\t            return this.options.styleCursor;\n\t        },\n\t\n\t        /*\\\n\t         * Interactable.preventDefault\n\t         [ method ]\n\t         *\n\t         * Returns or sets whether to prevent the browser's default behaviour\n\t         * in response to pointer events. Can be set to:\n\t         *  - `'always'` to always prevent\n\t         *  - `'never'` to never prevent\n\t         *  - `'auto'` to let interact.js try to determine what would be best\n\t         *\n\t         - newValue (string) #optional `true`, `false` or `'auto'`\n\t         = (string | Interactable) The current setting or this Interactable\n\t        \\*/\n\t        preventDefault: function (newValue) {\n\t            if (/^(always|never|auto)$/.test(newValue)) {\n\t                this.options.preventDefault = newValue;\n\t                return this;\n\t            }\n\t\n\t            if (isBool(newValue)) {\n\t                this.options.preventDefault = newValue? 'always' : 'never';\n\t                return this;\n\t            }\n\t\n\t            return this.options.preventDefault;\n\t        },\n\t\n\t        /*\\\n\t         * Interactable.origin\n\t         [ method ]\n\t         *\n\t         * Gets or sets the origin of the Interactable's element.  The x and y\n\t         * of the origin will be subtracted from action event coordinates.\n\t         *\n\t         - origin (object | string) #optional An object eg. { x: 0, y: 0 } or string 'parent', 'self' or any CSS selector\n\t         * OR\n\t         - origin (Element) #optional An HTML or SVG Element whose rect will be used\n\t         **\n\t         = (object) The current origin or this Interactable\n\t        \\*/\n\t        origin: function (newValue) {\n\t            if (trySelector(newValue)) {\n\t                this.options.origin = newValue;\n\t                return this;\n\t            }\n\t            else if (isObject(newValue)) {\n\t                this.options.origin = newValue;\n\t                return this;\n\t            }\n\t\n\t            return this.options.origin;\n\t        },\n\t\n\t        /*\\\n\t         * Interactable.deltaSource\n\t         [ method ]\n\t         *\n\t         * Returns or sets the mouse coordinate types used to calculate the\n\t         * movement of the pointer.\n\t         *\n\t         - newValue (string) #optional Use 'client' if you will be scrolling while interacting; Use 'page' if you want autoScroll to work\n\t         = (string | object) The current deltaSource or this Interactable\n\t        \\*/\n\t        deltaSource: function (newValue) {\n\t            if (newValue === 'page' || newValue === 'client') {\n\t                this.options.deltaSource = newValue;\n\t\n\t                return this;\n\t            }\n\t\n\t            return this.options.deltaSource;\n\t        },\n\t\n\t        /*\\\n\t         * Interactable.restrict\n\t         [ method ]\n\t         **\n\t         * Deprecated. Add a `restrict` property to the options object passed to\n\t         * @Interactable.draggable, @Interactable.resizable or @Interactable.gesturable instead.\n\t         *\n\t         * Returns or sets the rectangles within which actions on this\n\t         * interactable (after snap calculations) are restricted. By default,\n\t         * restricting is relative to the pointer coordinates. You can change\n\t         * this by setting the\n\t         * [`elementRect`](https://github.com/taye/interact.js/pull/72).\n\t         **\n\t         - options (object) #optional an object with keys drag, resize, and/or gesture whose values are rects, Elements, CSS selectors, or 'parent' or 'self'\n\t         = (object) The current restrictions object or this Interactable\n\t         **\n\t         | interact(element).restrict({\n\t         |     // the rect will be `interact.getElementRect(element.parentNode)`\n\t         |     drag: element.parentNode,\n\t         |\n\t         |     // x and y are relative to the the interactable's origin\n\t         |     resize: { x: 100, y: 100, width: 200, height: 200 }\n\t         | })\n\t         |\n\t         | interact('.draggable').restrict({\n\t         |     // the rect will be the selected element's parent\n\t         |     drag: 'parent',\n\t         |\n\t         |     // do not restrict during normal movement.\n\t         |     // Instead, trigger only one restricted move event\n\t         |     // immediately before the end event.\n\t         |     endOnly: true,\n\t         |\n\t         |     // https://github.com/taye/interact.js/pull/72#issue-41813493\n\t         |     elementRect: { top: 0, left: 0, bottom: 1, right: 1 }\n\t         | });\n\t        \\*/\n\t        restrict: function (options) {\n\t            if (!isObject(options)) {\n\t                return this.setOptions('restrict', options);\n\t            }\n\t\n\t            var actions = ['drag', 'resize', 'gesture'],\n\t                ret;\n\t\n\t            for (var i = 0; i < actions.length; i++) {\n\t                var action = actions[i];\n\t\n\t                if (action in options) {\n\t                    var perAction = extend({\n\t                            actions: [action],\n\t                            restriction: options[action]\n\t                        }, options);\n\t\n\t                    ret = this.setOptions('restrict', perAction);\n\t                }\n\t            }\n\t\n\t            return ret;\n\t        },\n\t\n\t        /*\\\n\t         * Interactable.context\n\t         [ method ]\n\t         *\n\t         * Gets the selector context Node of the Interactable. The default is `window.document`.\n\t         *\n\t         = (Node) The context Node of this Interactable\n\t         **\n\t        \\*/\n\t        context: function () {\n\t            return this._context;\n\t        },\n\t\n\t        _context: document,\n\t\n\t        /*\\\n\t         * Interactable.ignoreFrom\n\t         [ method ]\n\t         *\n\t         * If the target of the `mousedown`, `pointerdown` or `touchstart`\n\t         * event or any of it's parents match the given CSS selector or\n\t         * Element, no drag/resize/gesture is started.\n\t         *\n\t         - newValue (string | Element | null) #optional a CSS selector string, an Element or `null` to not ignore any elements\n\t         = (string | Element | object) The current ignoreFrom value or this Interactable\n\t         **\n\t         | interact(element, { ignoreFrom: document.getElementById('no-action') });\n\t         | // or\n\t         | interact(element).ignoreFrom('input, textarea, a');\n\t        \\*/\n\t        ignoreFrom: function (newValue) {\n\t            if (trySelector(newValue)) {            // CSS selector to match event.target\n\t                this.options.ignoreFrom = newValue;\n\t                return this;\n\t            }\n\t\n\t            if (isElement(newValue)) {              // specific element\n\t                this.options.ignoreFrom = newValue;\n\t                return this;\n\t            }\n\t\n\t            return this.options.ignoreFrom;\n\t        },\n\t\n\t        /*\\\n\t         * Interactable.allowFrom\n\t         [ method ]\n\t         *\n\t         * A drag/resize/gesture is started only If the target of the\n\t         * `mousedown`, `pointerdown` or `touchstart` event or any of it's\n\t         * parents match the given CSS selector or Element.\n\t         *\n\t         - newValue (string | Element | null) #optional a CSS selector string, an Element or `null` to allow from any element\n\t         = (string | Element | object) The current allowFrom value or this Interactable\n\t         **\n\t         | interact(element, { allowFrom: document.getElementById('drag-handle') });\n\t         | // or\n\t         | interact(element).allowFrom('.handle');\n\t        \\*/\n\t        allowFrom: function (newValue) {\n\t            if (trySelector(newValue)) {            // CSS selector to match event.target\n\t                this.options.allowFrom = newValue;\n\t                return this;\n\t            }\n\t\n\t            if (isElement(newValue)) {              // specific element\n\t                this.options.allowFrom = newValue;\n\t                return this;\n\t            }\n\t\n\t            return this.options.allowFrom;\n\t        },\n\t\n\t        /*\\\n\t         * Interactable.element\n\t         [ method ]\n\t         *\n\t         * If this is not a selector Interactable, it returns the element this\n\t         * interactable represents\n\t         *\n\t         = (Element) HTML / SVG Element\n\t        \\*/\n\t        element: function () {\n\t            return this._element;\n\t        },\n\t\n\t        /*\\\n\t         * Interactable.fire\n\t         [ method ]\n\t         *\n\t         * Calls listeners for the given InteractEvent type bound globally\n\t         * and directly to this Interactable\n\t         *\n\t         - iEvent (InteractEvent) The InteractEvent object to be fired on this Interactable\n\t         = (Interactable) this Interactable\n\t        \\*/\n\t        fire: function (iEvent) {\n\t            if (!(iEvent && iEvent.type) || !contains(eventTypes, iEvent.type)) {\n\t                return this;\n\t            }\n\t\n\t            var listeners,\n\t                i,\n\t                len,\n\t                onEvent = 'on' + iEvent.type,\n\t                funcName = '';\n\t\n\t            // Interactable#on() listeners\n\t            if (iEvent.type in this._iEvents) {\n\t                listeners = this._iEvents[iEvent.type];\n\t\n\t                for (i = 0, len = listeners.length; i < len && !iEvent.immediatePropagationStopped; i++) {\n\t                    funcName = listeners[i].name;\n\t                    listeners[i](iEvent);\n\t                }\n\t            }\n\t\n\t            // interactable.onevent listener\n\t            if (isFunction(this[onEvent])) {\n\t                funcName = this[onEvent].name;\n\t                this[onEvent](iEvent);\n\t            }\n\t\n\t            // interact.on() listeners\n\t            if (iEvent.type in globalEvents && (listeners = globalEvents[iEvent.type]))  {\n\t\n\t                for (i = 0, len = listeners.length; i < len && !iEvent.immediatePropagationStopped; i++) {\n\t                    funcName = listeners[i].name;\n\t                    listeners[i](iEvent);\n\t                }\n\t            }\n\t\n\t            return this;\n\t        },\n\t\n\t        /*\\\n\t         * Interactable.on\n\t         [ method ]\n\t         *\n\t         * Binds a listener for an InteractEvent or DOM event.\n\t         *\n\t         - eventType  (string | array | object) The types of events to listen for\n\t         - listener   (function) The function to be called on the given event(s)\n\t         - useCapture (boolean) #optional useCapture flag for addEventListener\n\t         = (object) This Interactable\n\t        \\*/\n\t        on: function (eventType, listener, useCapture) {\n\t            var i;\n\t\n\t            if (isString(eventType) && eventType.search(' ') !== -1) {\n\t                eventType = eventType.trim().split(/ +/);\n\t            }\n\t\n\t            if (isArray(eventType)) {\n\t                for (i = 0; i < eventType.length; i++) {\n\t                    this.on(eventType[i], listener, useCapture);\n\t                }\n\t\n\t                return this;\n\t            }\n\t\n\t            if (isObject(eventType)) {\n\t                for (var prop in eventType) {\n\t                    this.on(prop, eventType[prop], listener);\n\t                }\n\t\n\t                return this;\n\t            }\n\t\n\t            if (eventType === 'wheel') {\n\t                eventType = wheelEvent;\n\t            }\n\t\n\t            // convert to boolean\n\t            useCapture = useCapture? true: false;\n\t\n\t            if (contains(eventTypes, eventType)) {\n\t                // if this type of event was never bound to this Interactable\n\t                if (!(eventType in this._iEvents)) {\n\t                    this._iEvents[eventType] = [listener];\n\t                }\n\t                else {\n\t                    this._iEvents[eventType].push(listener);\n\t                }\n\t            }\n\t            // delegated event for selector\n\t            else if (this.selector) {\n\t                if (!delegatedEvents[eventType]) {\n\t                    delegatedEvents[eventType] = {\n\t                        selectors: [],\n\t                        contexts : [],\n\t                        listeners: []\n\t                    };\n\t\n\t                    // add delegate listener functions\n\t                    for (i = 0; i < documents.length; i++) {\n\t                        events.add(documents[i], eventType, delegateListener);\n\t                        events.add(documents[i], eventType, delegateUseCapture, true);\n\t                    }\n\t                }\n\t\n\t                var delegated = delegatedEvents[eventType],\n\t                    index;\n\t\n\t                for (index = delegated.selectors.length - 1; index >= 0; index--) {\n\t                    if (delegated.selectors[index] === this.selector\n\t                        && delegated.contexts[index] === this._context) {\n\t                        break;\n\t                    }\n\t                }\n\t\n\t                if (index === -1) {\n\t                    index = delegated.selectors.length;\n\t\n\t                    delegated.selectors.push(this.selector);\n\t                    delegated.contexts .push(this._context);\n\t                    delegated.listeners.push([]);\n\t                }\n\t\n\t                // keep listener and useCapture flag\n\t                delegated.listeners[index].push([listener, useCapture]);\n\t            }\n\t            else {\n\t                events.add(this._element, eventType, listener, useCapture);\n\t            }\n\t\n\t            return this;\n\t        },\n\t\n\t        /*\\\n\t         * Interactable.off\n\t         [ method ]\n\t         *\n\t         * Removes an InteractEvent or DOM event listener\n\t         *\n\t         - eventType  (string | array | object) The types of events that were listened for\n\t         - listener   (function) The listener function to be removed\n\t         - useCapture (boolean) #optional useCapture flag for removeEventListener\n\t         = (object) This Interactable\n\t        \\*/\n\t        off: function (eventType, listener, useCapture) {\n\t            var i;\n\t\n\t            if (isString(eventType) && eventType.search(' ') !== -1) {\n\t                eventType = eventType.trim().split(/ +/);\n\t            }\n\t\n\t            if (isArray(eventType)) {\n\t                for (i = 0; i < eventType.length; i++) {\n\t                    this.off(eventType[i], listener, useCapture);\n\t                }\n\t\n\t                return this;\n\t            }\n\t\n\t            if (isObject(eventType)) {\n\t                for (var prop in eventType) {\n\t                    this.off(prop, eventType[prop], listener);\n\t                }\n\t\n\t                return this;\n\t            }\n\t\n\t            var eventList,\n\t                index = -1;\n\t\n\t            // convert to boolean\n\t            useCapture = useCapture? true: false;\n\t\n\t            if (eventType === 'wheel') {\n\t                eventType = wheelEvent;\n\t            }\n\t\n\t            // if it is an action event type\n\t            if (contains(eventTypes, eventType)) {\n\t                eventList = this._iEvents[eventType];\n\t\n\t                if (eventList && (index = indexOf(eventList, listener)) !== -1) {\n\t                    this._iEvents[eventType].splice(index, 1);\n\t                }\n\t            }\n\t            // delegated event\n\t            else if (this.selector) {\n\t                var delegated = delegatedEvents[eventType],\n\t                    matchFound = false;\n\t\n\t                if (!delegated) { return this; }\n\t\n\t                // count from last index of delegated to 0\n\t                for (index = delegated.selectors.length - 1; index >= 0; index--) {\n\t                    // look for matching selector and context Node\n\t                    if (delegated.selectors[index] === this.selector\n\t                        && delegated.contexts[index] === this._context) {\n\t\n\t                        var listeners = delegated.listeners[index];\n\t\n\t                        // each item of the listeners array is an array: [function, useCaptureFlag]\n\t                        for (i = listeners.length - 1; i >= 0; i--) {\n\t                            var fn = listeners[i][0],\n\t                                useCap = listeners[i][1];\n\t\n\t                            // check if the listener functions and useCapture flags match\n\t                            if (fn === listener && useCap === useCapture) {\n\t                                // remove the listener from the array of listeners\n\t                                listeners.splice(i, 1);\n\t\n\t                                // if all listeners for this interactable have been removed\n\t                                // remove the interactable from the delegated arrays\n\t                                if (!listeners.length) {\n\t                                    delegated.selectors.splice(index, 1);\n\t                                    delegated.contexts .splice(index, 1);\n\t                                    delegated.listeners.splice(index, 1);\n\t\n\t                                    // remove delegate function from context\n\t                                    events.remove(this._context, eventType, delegateListener);\n\t                                    events.remove(this._context, eventType, delegateUseCapture, true);\n\t\n\t                                    // remove the arrays if they are empty\n\t                                    if (!delegated.selectors.length) {\n\t                                        delegatedEvents[eventType] = null;\n\t                                    }\n\t                                }\n\t\n\t                                // only remove one listener\n\t                                matchFound = true;\n\t                                break;\n\t                            }\n\t                        }\n\t\n\t                        if (matchFound) { break; }\n\t                    }\n\t                }\n\t            }\n\t            // remove listener from this Interatable's element\n\t            else {\n\t                events.remove(this._element, eventType, listener, useCapture);\n\t            }\n\t\n\t            return this;\n\t        },\n\t\n\t        /*\\\n\t         * Interactable.set\n\t         [ method ]\n\t         *\n\t         * Reset the options of this Interactable\n\t         - options (object) The new settings to apply\n\t         = (object) This Interactable\n\t        \\*/\n\t        set: function (options) {\n\t            if (!isObject(options)) {\n\t                options = {};\n\t            }\n\t\n\t            this.options = extend({}, defaultOptions.base);\n\t\n\t            var i,\n\t                actions = ['drag', 'drop', 'resize', 'gesture'],\n\t                methods = ['draggable', 'dropzone', 'resizable', 'gesturable'],\n\t                perActions = extend(extend({}, defaultOptions.perAction), options[action] || {});\n\t\n\t            for (i = 0; i < actions.length; i++) {\n\t                var action = actions[i];\n\t\n\t                this.options[action] = extend({}, defaultOptions[action]);\n\t\n\t                this.setPerAction(action, perActions);\n\t\n\t                this[methods[i]](options[action]);\n\t            }\n\t\n\t            var settings = [\n\t                    'accept', 'actionChecker', 'allowFrom', 'deltaSource',\n\t                    'dropChecker', 'ignoreFrom', 'origin', 'preventDefault',\n\t                    'rectChecker', 'styleCursor'\n\t                ];\n\t\n\t            for (i = 0, len = settings.length; i < len; i++) {\n\t                var setting = settings[i];\n\t\n\t                this.options[setting] = defaultOptions.base[setting];\n\t\n\t                if (setting in options) {\n\t                    this[setting](options[setting]);\n\t                }\n\t            }\n\t\n\t            return this;\n\t        },\n\t\n\t        /*\\\n\t         * Interactable.unset\n\t         [ method ]\n\t         *\n\t         * Remove this interactable from the list of interactables and remove\n\t         * it's drag, drop, resize and gesture capabilities\n\t         *\n\t         = (object) @interact\n\t        \\*/\n\t        unset: function () {\n\t            events.remove(this._element, 'all');\n\t\n\t            if (!isString(this.selector)) {\n\t                events.remove(this, 'all');\n\t                if (this.options.styleCursor) {\n\t                    this._element.style.cursor = '';\n\t                }\n\t            }\n\t            else {\n\t                // remove delegated events\n\t                for (var type in delegatedEvents) {\n\t                    var delegated = delegatedEvents[type];\n\t\n\t                    for (var i = 0; i < delegated.selectors.length; i++) {\n\t                        if (delegated.selectors[i] === this.selector\n\t                            && delegated.contexts[i] === this._context) {\n\t\n\t                            delegated.selectors.splice(i, 1);\n\t                            delegated.contexts .splice(i, 1);\n\t                            delegated.listeners.splice(i, 1);\n\t\n\t                            // remove the arrays if they are empty\n\t                            if (!delegated.selectors.length) {\n\t                                delegatedEvents[type] = null;\n\t                            }\n\t                        }\n\t\n\t                        events.remove(this._context, type, delegateListener);\n\t                        events.remove(this._context, type, delegateUseCapture, true);\n\t\n\t                        break;\n\t                    }\n\t                }\n\t            }\n\t\n\t            this.dropzone(false);\n\t\n\t            interactables.splice(indexOf(interactables, this), 1);\n\t\n\t            return interact;\n\t        }\n\t    };\n\t\n\t    function warnOnce (method, message) {\n\t        var warned = false;\n\t\n\t        return function () {\n\t            if (!warned) {\n\t                window.console.warn(message);\n\t                warned = true;\n\t            }\n\t\n\t            return method.apply(this, arguments);\n\t        };\n\t    }\n\t\n\t    Interactable.prototype.snap = warnOnce(Interactable.prototype.snap,\n\t         'Interactable#snap is deprecated. See the new documentation for snapping at http://interactjs.io/docs/snapping');\n\t    Interactable.prototype.restrict = warnOnce(Interactable.prototype.restrict,\n\t         'Interactable#restrict is deprecated. See the new documentation for resticting at http://interactjs.io/docs/restriction');\n\t    Interactable.prototype.inertia = warnOnce(Interactable.prototype.inertia,\n\t         'Interactable#inertia is deprecated. See the new documentation for inertia at http://interactjs.io/docs/inertia');\n\t    Interactable.prototype.autoScroll = warnOnce(Interactable.prototype.autoScroll,\n\t         'Interactable#autoScroll is deprecated. See the new documentation for autoScroll at http://interactjs.io/docs/#autoscroll');\n\t    Interactable.prototype.squareResize = warnOnce(Interactable.prototype.squareResize,\n\t         'Interactable#squareResize is deprecated. See http://interactjs.io/docs/#resize-square');\n\t\n\t    Interactable.prototype.accept = warnOnce(Interactable.prototype.accept,\n\t         'Interactable#accept is deprecated. use Interactable#dropzone({ accept: target }) instead');\n\t    Interactable.prototype.dropChecker = warnOnce(Interactable.prototype.dropChecker,\n\t         'Interactable#dropChecker is deprecated. use Interactable#dropzone({ dropChecker: checkerFunction }) instead');\n\t    Interactable.prototype.context = warnOnce(Interactable.prototype.context,\n\t         'Interactable#context as a method is deprecated. It will soon be a DOM Node instead');\n\t\n\t    /*\\\n\t     * interact.isSet\n\t     [ method ]\n\t     *\n\t     * Check if an element has been set\n\t     - element (Element) The Element being searched for\n\t     = (boolean) Indicates if the element or CSS selector was previously passed to interact\n\t    \\*/\n\t    interact.isSet = function(element, options) {\n\t        return interactables.indexOfElement(element, options && options.context) !== -1;\n\t    };\n\t\n\t    /*\\\n\t     * interact.on\n\t     [ method ]\n\t     *\n\t     * Adds a global listener for an InteractEvent or adds a DOM event to\n\t     * `document`\n\t     *\n\t     - type       (string | array | object) The types of events to listen for\n\t     - listener   (function) The function to be called on the given event(s)\n\t     - useCapture (boolean) #optional useCapture flag for addEventListener\n\t     = (object) interact\n\t    \\*/\n\t    interact.on = function (type, listener, useCapture) {\n\t        if (isString(type) && type.search(' ') !== -1) {\n\t            type = type.trim().split(/ +/);\n\t        }\n\t\n\t        if (isArray(type)) {\n\t            for (var i = 0; i < type.length; i++) {\n\t                interact.on(type[i], listener, useCapture);\n\t            }\n\t\n\t            return interact;\n\t        }\n\t\n\t        if (isObject(type)) {\n\t            for (var prop in type) {\n\t                interact.on(prop, type[prop], listener);\n\t            }\n\t\n\t            return interact;\n\t        }\n\t\n\t        // if it is an InteractEvent type, add listener to globalEvents\n\t        if (contains(eventTypes, type)) {\n\t            // if this type of event was never bound\n\t            if (!globalEvents[type]) {\n\t                globalEvents[type] = [listener];\n\t            }\n\t            else {\n\t                globalEvents[type].push(listener);\n\t            }\n\t        }\n\t        // If non InteractEvent type, addEventListener to document\n\t        else {\n\t            events.add(document, type, listener, useCapture);\n\t        }\n\t\n\t        return interact;\n\t    };\n\t\n\t    /*\\\n\t     * interact.off\n\t     [ method ]\n\t     *\n\t     * Removes a global InteractEvent listener or DOM event from `document`\n\t     *\n\t     - type       (string | array | object) The types of events that were listened for\n\t     - listener   (function) The listener function to be removed\n\t     - useCapture (boolean) #optional useCapture flag for removeEventListener\n\t     = (object) interact\n\t     \\*/\n\t    interact.off = function (type, listener, useCapture) {\n\t        if (isString(type) && type.search(' ') !== -1) {\n\t            type = type.trim().split(/ +/);\n\t        }\n\t\n\t        if (isArray(type)) {\n\t            for (var i = 0; i < type.length; i++) {\n\t                interact.off(type[i], listener, useCapture);\n\t            }\n\t\n\t            return interact;\n\t        }\n\t\n\t        if (isObject(type)) {\n\t            for (var prop in type) {\n\t                interact.off(prop, type[prop], listener);\n\t            }\n\t\n\t            return interact;\n\t        }\n\t\n\t        if (!contains(eventTypes, type)) {\n\t            events.remove(document, type, listener, useCapture);\n\t        }\n\t        else {\n\t            var index;\n\t\n\t            if (type in globalEvents\n\t                && (index = indexOf(globalEvents[type], listener)) !== -1) {\n\t                globalEvents[type].splice(index, 1);\n\t            }\n\t        }\n\t\n\t        return interact;\n\t    };\n\t\n\t    /*\\\n\t     * interact.enableDragging\n\t     [ method ]\n\t     *\n\t     * Deprecated.\n\t     *\n\t     * Returns or sets whether dragging is enabled for any Interactables\n\t     *\n\t     - newValue (boolean) #optional `true` to allow the action; `false` to disable action for all Interactables\n\t     = (boolean | object) The current setting or interact\n\t    \\*/\n\t    interact.enableDragging = warnOnce(function (newValue) {\n\t        if (newValue !== null && newValue !== undefined) {\n\t            actionIsEnabled.drag = newValue;\n\t\n\t            return interact;\n\t        }\n\t        return actionIsEnabled.drag;\n\t    }, 'interact.enableDragging is deprecated and will soon be removed.');\n\t\n\t    /*\\\n\t     * interact.enableResizing\n\t     [ method ]\n\t     *\n\t     * Deprecated.\n\t     *\n\t     * Returns or sets whether resizing is enabled for any Interactables\n\t     *\n\t     - newValue (boolean) #optional `true` to allow the action; `false` to disable action for all Interactables\n\t     = (boolean | object) The current setting or interact\n\t    \\*/\n\t    interact.enableResizing = warnOnce(function (newValue) {\n\t        if (newValue !== null && newValue !== undefined) {\n\t            actionIsEnabled.resize = newValue;\n\t\n\t            return interact;\n\t        }\n\t        return actionIsEnabled.resize;\n\t    }, 'interact.enableResizing is deprecated and will soon be removed.');\n\t\n\t    /*\\\n\t     * interact.enableGesturing\n\t     [ method ]\n\t     *\n\t     * Deprecated.\n\t     *\n\t     * Returns or sets whether gesturing is enabled for any Interactables\n\t     *\n\t     - newValue (boolean) #optional `true` to allow the action; `false` to disable action for all Interactables\n\t     = (boolean | object) The current setting or interact\n\t    \\*/\n\t    interact.enableGesturing = warnOnce(function (newValue) {\n\t        if (newValue !== null && newValue !== undefined) {\n\t            actionIsEnabled.gesture = newValue;\n\t\n\t            return interact;\n\t        }\n\t        return actionIsEnabled.gesture;\n\t    }, 'interact.enableGesturing is deprecated and will soon be removed.');\n\t\n\t    interact.eventTypes = eventTypes;\n\t\n\t    /*\\\n\t     * interact.debug\n\t     [ method ]\n\t     *\n\t     * Returns debugging data\n\t     = (object) An object with properties that outline the current state and expose internal functions and variables\n\t    \\*/\n\t    interact.debug = function () {\n\t        var interaction = interactions[0] || new Interaction();\n\t\n\t        return {\n\t            interactions          : interactions,\n\t            target                : interaction.target,\n\t            dragging              : interaction.dragging,\n\t            resizing              : interaction.resizing,\n\t            gesturing             : interaction.gesturing,\n\t            prepared              : interaction.prepared,\n\t            matches               : interaction.matches,\n\t            matchElements         : interaction.matchElements,\n\t\n\t            prevCoords            : interaction.prevCoords,\n\t            startCoords           : interaction.startCoords,\n\t\n\t            pointerIds            : interaction.pointerIds,\n\t            pointers              : interaction.pointers,\n\t            addPointer            : listeners.addPointer,\n\t            removePointer         : listeners.removePointer,\n\t            recordPointer        : listeners.recordPointer,\n\t\n\t            snap                  : interaction.snapStatus,\n\t            restrict              : interaction.restrictStatus,\n\t            inertia               : interaction.inertiaStatus,\n\t\n\t            downTime              : interaction.downTimes[0],\n\t            downEvent             : interaction.downEvent,\n\t            downPointer           : interaction.downPointer,\n\t            prevEvent             : interaction.prevEvent,\n\t\n\t            Interactable          : Interactable,\n\t            interactables         : interactables,\n\t            pointerIsDown         : interaction.pointerIsDown,\n\t            defaultOptions        : defaultOptions,\n\t            defaultActionChecker  : defaultActionChecker,\n\t\n\t            actionCursors         : actionCursors,\n\t            dragMove              : listeners.dragMove,\n\t            resizeMove            : listeners.resizeMove,\n\t            gestureMove           : listeners.gestureMove,\n\t            pointerUp             : listeners.pointerUp,\n\t            pointerDown           : listeners.pointerDown,\n\t            pointerMove           : listeners.pointerMove,\n\t            pointerHover          : listeners.pointerHover,\n\t\n\t            eventTypes            : eventTypes,\n\t\n\t            events                : events,\n\t            globalEvents          : globalEvents,\n\t            delegatedEvents       : delegatedEvents,\n\t\n\t            prefixedPropREs       : prefixedPropREs\n\t        };\n\t    };\n\t\n\t    // expose the functions used to calculate multi-touch properties\n\t    interact.getPointerAverage = pointerAverage;\n\t    interact.getTouchBBox     = touchBBox;\n\t    interact.getTouchDistance = touchDistance;\n\t    interact.getTouchAngle    = touchAngle;\n\t\n\t    interact.getElementRect         = getElementRect;\n\t    interact.getElementClientRect   = getElementClientRect;\n\t    interact.matchesSelector        = matchesSelector;\n\t    interact.closest                = closest;\n\t\n\t    /*\\\n\t     * interact.margin\n\t     [ method ]\n\t     *\n\t     * Deprecated. Use `interact(target).resizable({ margin: number });` instead.\n\t     * Returns or sets the margin for autocheck resizing used in\n\t     * @Interactable.getAction. That is the distance from the bottom and right\n\t     * edges of an element clicking in which will start resizing\n\t     *\n\t     - newValue (number) #optional\n\t     = (number | interact) The current margin value or interact\n\t    \\*/\n\t    interact.margin = warnOnce(function (newvalue) {\n\t        if (isNumber(newvalue)) {\n\t            margin = newvalue;\n\t\n\t            return interact;\n\t        }\n\t        return margin;\n\t    },\n\t    'interact.margin is deprecated. Use interact(target).resizable({ margin: number }); instead.') ;\n\t\n\t    /*\\\n\t     * interact.supportsTouch\n\t     [ method ]\n\t     *\n\t     = (boolean) Whether or not the browser supports touch input\n\t    \\*/\n\t    interact.supportsTouch = function () {\n\t        return supportsTouch;\n\t    };\n\t\n\t    /*\\\n\t     * interact.supportsPointerEvent\n\t     [ method ]\n\t     *\n\t     = (boolean) Whether or not the browser supports PointerEvents\n\t    \\*/\n\t    interact.supportsPointerEvent = function () {\n\t        return supportsPointerEvent;\n\t    };\n\t\n\t    /*\\\n\t     * interact.stop\n\t     [ method ]\n\t     *\n\t     * Cancels all interactions (end events are not fired)\n\t     *\n\t     - event (Event) An event on which to call preventDefault()\n\t     = (object) interact\n\t    \\*/\n\t    interact.stop = function (event) {\n\t        for (var i = interactions.length - 1; i >= 0; i--) {\n\t            interactions[i].stop(event);\n\t        }\n\t\n\t        return interact;\n\t    };\n\t\n\t    /*\\\n\t     * interact.dynamicDrop\n\t     [ method ]\n\t     *\n\t     * Returns or sets whether the dimensions of dropzone elements are\n\t     * calculated on every dragmove or only on dragstart for the default\n\t     * dropChecker\n\t     *\n\t     - newValue (boolean) #optional True to check on each move. False to check only before start\n\t     = (boolean | interact) The current setting or interact\n\t    \\*/\n\t    interact.dynamicDrop = function (newValue) {\n\t        if (isBool(newValue)) {\n\t            //if (dragging && dynamicDrop !== newValue && !newValue) {\n\t                //calcRects(dropzones);\n\t            //}\n\t\n\t            dynamicDrop = newValue;\n\t\n\t            return interact;\n\t        }\n\t        return dynamicDrop;\n\t    };\n\t\n\t    /*\\\n\t     * interact.pointerMoveTolerance\n\t     [ method ]\n\t     * Returns or sets the distance the pointer must be moved before an action\n\t     * sequence occurs. This also affects tolerance for tap events.\n\t     *\n\t     - newValue (number) #optional The movement from the start position must be greater than this value\n\t     = (number | Interactable) The current setting or interact\n\t    \\*/\n\t    interact.pointerMoveTolerance = function (newValue) {\n\t        if (isNumber(newValue)) {\n\t            pointerMoveTolerance = newValue;\n\t\n\t            return this;\n\t        }\n\t\n\t        return pointerMoveTolerance;\n\t    };\n\t\n\t    /*\\\n\t     * interact.maxInteractions\n\t     [ method ]\n\t     **\n\t     * Returns or sets the maximum number of concurrent interactions allowed.\n\t     * By default only 1 interaction is allowed at a time (for backwards\n\t     * compatibility). To allow multiple interactions on the same Interactables\n\t     * and elements, you need to enable it in the draggable, resizable and\n\t     * gesturable `'max'` and `'maxPerElement'` options.\n\t     **\n\t     - newValue (number) #optional Any number. newValue <= 0 means no interactions.\n\t    \\*/\n\t    interact.maxInteractions = function (newValue) {\n\t        if (isNumber(newValue)) {\n\t            maxInteractions = newValue;\n\t\n\t            return this;\n\t        }\n\t\n\t        return maxInteractions;\n\t    };\n\t\n\t    interact.createSnapGrid = function (grid) {\n\t        return function (x, y) {\n\t            var offsetX = 0,\n\t                offsetY = 0;\n\t\n\t            if (isObject(grid.offset)) {\n\t                offsetX = grid.offset.x;\n\t                offsetY = grid.offset.y;\n\t            }\n\t\n\t            var gridx = Math.round((x - offsetX) / grid.x),\n\t                gridy = Math.round((y - offsetY) / grid.y),\n\t\n\t                newX = gridx * grid.x + offsetX,\n\t                newY = gridy * grid.y + offsetY;\n\t\n\t            return {\n\t                x: newX,\n\t                y: newY,\n\t                range: grid.range\n\t            };\n\t        };\n\t    };\n\t\n\t    function endAllInteractions (event) {\n\t        for (var i = 0; i < interactions.length; i++) {\n\t            interactions[i].pointerEnd(event, event);\n\t        }\n\t    }\n\t\n\t    function listenToDocument (doc) {\n\t        if (contains(documents, doc)) { return; }\n\t\n\t        var win = doc.defaultView || doc.parentWindow;\n\t\n\t        // add delegate event listener\n\t        for (var eventType in delegatedEvents) {\n\t            events.add(doc, eventType, delegateListener);\n\t            events.add(doc, eventType, delegateUseCapture, true);\n\t        }\n\t\n\t        if (supportsPointerEvent) {\n\t            if (PointerEvent === win.MSPointerEvent) {\n\t                pEventTypes = {\n\t                    up: 'MSPointerUp', down: 'MSPointerDown', over: 'mouseover',\n\t                    out: 'mouseout', move: 'MSPointerMove', cancel: 'MSPointerCancel' };\n\t            }\n\t            else {\n\t                pEventTypes = {\n\t                    up: 'pointerup', down: 'pointerdown', over: 'pointerover',\n\t                    out: 'pointerout', move: 'pointermove', cancel: 'pointercancel' };\n\t            }\n\t\n\t            events.add(doc, pEventTypes.down  , listeners.selectorDown );\n\t            events.add(doc, pEventTypes.move  , listeners.pointerMove  );\n\t            events.add(doc, pEventTypes.over  , listeners.pointerOver  );\n\t            events.add(doc, pEventTypes.out   , listeners.pointerOut   );\n\t            events.add(doc, pEventTypes.up    , listeners.pointerUp    );\n\t            events.add(doc, pEventTypes.cancel, listeners.pointerCancel);\n\t\n\t            // autoscroll\n\t            events.add(doc, pEventTypes.move, listeners.autoScrollMove);\n\t        }\n\t        else {\n\t            events.add(doc, 'mousedown', listeners.selectorDown);\n\t            events.add(doc, 'mousemove', listeners.pointerMove );\n\t            events.add(doc, 'mouseup'  , listeners.pointerUp   );\n\t            events.add(doc, 'mouseover', listeners.pointerOver );\n\t            events.add(doc, 'mouseout' , listeners.pointerOut  );\n\t\n\t            events.add(doc, 'touchstart' , listeners.selectorDown );\n\t            events.add(doc, 'touchmove'  , listeners.pointerMove  );\n\t            events.add(doc, 'touchend'   , listeners.pointerUp    );\n\t            events.add(doc, 'touchcancel', listeners.pointerCancel);\n\t\n\t            // autoscroll\n\t            events.add(doc, 'mousemove', listeners.autoScrollMove);\n\t            events.add(doc, 'touchmove', listeners.autoScrollMove);\n\t        }\n\t\n\t        events.add(win, 'blur', endAllInteractions);\n\t\n\t        try {\n\t            if (win.frameElement) {\n\t                var parentDoc = win.frameElement.ownerDocument,\n\t                    parentWindow = parentDoc.defaultView;\n\t\n\t                events.add(parentDoc   , 'mouseup'      , listeners.pointerEnd);\n\t                events.add(parentDoc   , 'touchend'     , listeners.pointerEnd);\n\t                events.add(parentDoc   , 'touchcancel'  , listeners.pointerEnd);\n\t                events.add(parentDoc   , 'pointerup'    , listeners.pointerEnd);\n\t                events.add(parentDoc   , 'MSPointerUp'  , listeners.pointerEnd);\n\t                events.add(parentWindow, 'blur'         , endAllInteractions );\n\t            }\n\t        }\n\t        catch (error) {\n\t            interact.windowParentError = error;\n\t        }\n\t\n\t        // prevent native HTML5 drag on interact.js target elements\n\t        events.add(doc, 'dragstart', function (event) {\n\t            for (var i = 0; i < interactions.length; i++) {\n\t                var interaction = interactions[i];\n\t\n\t                if (interaction.element\n\t                    && (interaction.element === event.target\n\t                        || nodeContains(interaction.element, event.target))) {\n\t\n\t                    interaction.checkAndPreventDefault(event, interaction.target, interaction.element);\n\t                    return;\n\t                }\n\t            }\n\t        });\n\t\n\t        if (events.useAttachEvent) {\n\t            // For IE's lack of Event#preventDefault\n\t            events.add(doc, 'selectstart', function (event) {\n\t                var interaction = interactions[0];\n\t\n\t                if (interaction.currentAction()) {\n\t                    interaction.checkAndPreventDefault(event);\n\t                }\n\t            });\n\t\n\t            // For IE's bad dblclick event sequence\n\t            events.add(doc, 'dblclick', doOnInteractions('ie8Dblclick'));\n\t        }\n\t\n\t        documents.push(doc);\n\t    }\n\t\n\t    listenToDocument(document);\n\t\n\t    function indexOf (array, target) {\n\t        for (var i = 0, len = array.length; i < len; i++) {\n\t            if (array[i] === target) {\n\t                return i;\n\t            }\n\t        }\n\t\n\t        return -1;\n\t    }\n\t\n\t    function contains (array, target) {\n\t        return indexOf(array, target) !== -1;\n\t    }\n\t\n\t    function matchesSelector (element, selector, nodeList) {\n\t        if (ie8MatchesSelector) {\n\t            return ie8MatchesSelector(element, selector, nodeList);\n\t        }\n\t\n\t        // remove /deep/ from selectors if shadowDOM polyfill is used\n\t        if (window !== realWindow) {\n\t            selector = selector.replace(/\\/deep\\//g, ' ');\n\t        }\n\t\n\t        return element[prefixedMatchesSelector](selector);\n\t    }\n\t\n\t    function matchesUpTo (element, selector, limit) {\n\t        while (isElement(element)) {\n\t            if (matchesSelector(element, selector)) {\n\t                return true;\n\t            }\n\t\n\t            element = parentElement(element);\n\t\n\t            if (element === limit) {\n\t                return matchesSelector(element, selector);\n\t            }\n\t        }\n\t\n\t        return false;\n\t    }\n\t\n\t    // For IE8's lack of an Element#matchesSelector\n\t    // taken from http://tanalin.com/en/blog/2012/12/matches-selector-ie8/ and modified\n\t    if (!(prefixedMatchesSelector in Element.prototype) || !isFunction(Element.prototype[prefixedMatchesSelector])) {\n\t        ie8MatchesSelector = function (element, selector, elems) {\n\t            elems = elems || element.parentNode.querySelectorAll(selector);\n\t\n\t            for (var i = 0, len = elems.length; i < len; i++) {\n\t                if (elems[i] === element) {\n\t                    return true;\n\t                }\n\t            }\n\t\n\t            return false;\n\t        };\n\t    }\n\t\n\t    // requestAnimationFrame polyfill\n\t    (function() {\n\t        var lastTime = 0,\n\t            vendors = ['ms', 'moz', 'webkit', 'o'];\n\t\n\t        for(var x = 0; x < vendors.length && !realWindow.requestAnimationFrame; ++x) {\n\t            reqFrame = realWindow[vendors[x]+'RequestAnimationFrame'];\n\t            cancelFrame = realWindow[vendors[x]+'CancelAnimationFrame'] || realWindow[vendors[x]+'CancelRequestAnimationFrame'];\n\t        }\n\t\n\t        if (!reqFrame) {\n\t            reqFrame = function(callback) {\n\t                var currTime = new Date().getTime(),\n\t                    timeToCall = Math.max(0, 16 - (currTime - lastTime)),\n\t                    id = setTimeout(function() { callback(currTime + timeToCall); },\n\t                  timeToCall);\n\t                lastTime = currTime + timeToCall;\n\t                return id;\n\t            };\n\t        }\n\t\n\t        if (!cancelFrame) {\n\t            cancelFrame = function(id) {\n\t                clearTimeout(id);\n\t            };\n\t        }\n\t    }());\n\t\n\t    /* global exports: true, module, define */\n\t\n\t    // http://documentcloud.github.io/underscore/docs/underscore.html#section-11\n\t    if (true) {\n\t        if (typeof module !== 'undefined' && module.exports) {\n\t            exports = module.exports = interact;\n\t        }\n\t        exports.interact = interact;\n\t    }\n\t    // AMD\n\t    else if (typeof define === 'function' && define.amd) {\n\t        define('interact', function() {\n\t            return interact;\n\t        });\n\t    }\n\t    else {\n\t        realWindow.interact = interact;\n\t    }\n\t\n\t} (typeof window === 'undefined'? undefined : window));\n\n\n/***/ },\n/* 2 */\n/***/ function(module, exports) {\n\n\t// removed by extract-text-webpack-plugin\n\n/***/ }\n/******/ ]);\n\n\n// WEBPACK FOOTER //\n// js/app.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap f6b06171e54967a3f49b","'use strict';\n\nrequire('../scss/main.scss');\n\nimport interact from 'interact.js';\n\n// This element will hold all dragged decorations\nlet draggedDecorations = document.getElementById('draggedDecorations');\n\nlet decorationInteractable = interact('.dragged-decorations .decoration')\n  .draggable({\n    inertia: true,\n    // Rectangular shapes aren't precise enough :/\n    // restrict: {\n    //   restriction: document.querySelector('.christmas-tree'),\n    //   endOnly: true,\n    // },\n    onmove: (event) => {\n      let target = event.target;\n          // keep the dragged position in the data-x/data-y attributes\n      let x = (parseFloat(target.getAttribute('data-x')) || 0) + event.dx;\n      let y = (parseFloat(target.getAttribute('data-y')) || 0) + event.dy;\n\n      // translate the element\n      // target.style.transform = 'translate(' + x + 'px, ' + y + 'px)';\n      target.style.transform = `translate(${x}px, ${y}px)`;\n\n      // update the position attributes\n      target.setAttribute('data-x', x);\n      target.setAttribute('data-y', y);\n    }\n  });\n\nlet decorationDrawerInteractable = interact('.decoration-drawer .decoration')\n  .on('move', function (event) {\n    let interaction = event.interaction;\n\n    if (interaction.pointerIsDown && !interaction.interacting()) {\n      let drawerDecoration = event.currentTarget;\n\n      // Create a clone of the decoration, which will actually be dragged around\n      let decoration = drawerDecoration.cloneNode(true);\n\n      // Get the position of the decoration in the drawer\n      let decorationPosition = drawerDecoration.getBoundingClientRect();\n\n      // Position the cloned decoration on top of the original\n      decoration.style.top = decorationPosition.top + 'px';\n      decoration.style.left = decorationPosition.left + 'px';\n\n      // Add the cloned decoration to the DOM\n      draggedDecorations.appendChild(decoration);\n\n      // Manually start a 'movedrag' event, for the newly cloned decoration\n      interaction.start({\n          name: 'drag'\n        },\n        decorationInteractable,\n        decoration\n      );\n    }\n  });\n\n\nlet thrashCanInteractable = interact('.thrash-can-container')\n  .dropzone({\n    accept: '.decoration',\n    ondrop: function (event) {\n      const decoration = event.relatedTarget;\n\n      // Thrash the decoration\n      draggedDecorations.removeChild(decoration);\n\n      // Close the thrash can\n      event.target.classList.remove('hovering');\n    },\n    ondragenter: (event) => {\n      // Put the decoration and thrash can in the 'Will be removed' state\n      event.target.classList.add('hovering');\n      event.relatedTarget.classList.add('removable');\n\n    },\n    ondragleave: (event) => {\n      // Remove the decoration and thrash from the'Will be removed' state\n      event.target.classList.remove('hovering');\n      event.relatedTarget.classList.remove('removable');\n    }\n  });\n\n\n\n// WEBPACK FOOTER //\n// ./src/js/main.js","/**\n * interact.js v1.2.8\n *\n * Copyright (c) 2012-2015 Taye Adeyemi <dev@taye.me>\n * Open source under the MIT License.\n * https://raw.github.com/taye/interact.js/master/LICENSE\n */\n(function (realWindow) {\n    'use strict';\n\n    // return early if there's no window to work with (eg. Node.js)\n    if (!realWindow) { return; }\n\n    var // get wrapped window if using Shadow DOM polyfill\n        window = (function () {\n            // create a TextNode\n            var el = realWindow.document.createTextNode('');\n\n            // check if it's wrapped by a polyfill\n            if (el.ownerDocument !== realWindow.document\n                && typeof realWindow.wrap === 'function'\n                && realWindow.wrap(el) === el) {\n                // return wrapped window\n                return realWindow.wrap(realWindow);\n            }\n\n            // no Shadow DOM polyfil or native implementation\n            return realWindow;\n        }()),\n\n        document           = window.document,\n        DocumentFragment   = window.DocumentFragment   || blank,\n        SVGElement         = window.SVGElement         || blank,\n        SVGSVGElement      = window.SVGSVGElement      || blank,\n        SVGElementInstance = window.SVGElementInstance || blank,\n        HTMLElement        = window.HTMLElement        || window.Element,\n\n        PointerEvent = (window.PointerEvent || window.MSPointerEvent),\n        pEventTypes,\n\n        hypot = Math.hypot || function (x, y) { return Math.sqrt(x * x + y * y); },\n\n        tmpXY = {},     // reduce object creation in getXY()\n\n        documents       = [],   // all documents being listened to\n\n        interactables   = [],   // all set interactables\n        interactions    = [],   // all interactions\n\n        dynamicDrop     = false,\n\n        // {\n        //      type: {\n        //          selectors: ['selector', ...],\n        //          contexts : [document, ...],\n        //          listeners: [[listener, useCapture], ...]\n        //      }\n        //  }\n        delegatedEvents = {},\n\n        defaultOptions = {\n            base: {\n                accept        : null,\n                actionChecker : null,\n                styleCursor   : true,\n                preventDefault: 'auto',\n                origin        : { x: 0, y: 0 },\n                deltaSource   : 'page',\n                allowFrom     : null,\n                ignoreFrom    : null,\n                _context      : document,\n                dropChecker   : null\n            },\n\n            drag: {\n                enabled: false,\n                manualStart: true,\n                max: Infinity,\n                maxPerElement: 1,\n\n                snap: null,\n                restrict: null,\n                inertia: null,\n                autoScroll: null,\n\n                axis: 'xy'\n            },\n\n            drop: {\n                enabled: false,\n                accept: null,\n                overlap: 'pointer'\n            },\n\n            resize: {\n                enabled: false,\n                manualStart: false,\n                max: Infinity,\n                maxPerElement: 1,\n\n                snap: null,\n                restrict: null,\n                inertia: null,\n                autoScroll: null,\n\n                square: false,\n                preserveAspectRatio: false,\n                axis: 'xy',\n\n                // use default margin\n                margin: NaN,\n\n                // object with props left, right, top, bottom which are\n                // true/false values to resize when the pointer is over that edge,\n                // CSS selectors to match the handles for each direction\n                // or the Elements for each handle\n                edges: null,\n\n                // a value of 'none' will limit the resize rect to a minimum of 0x0\n                // 'negate' will alow the rect to have negative width/height\n                // 'reposition' will keep the width/height positive by swapping\n                // the top and bottom edges and/or swapping the left and right edges\n                invert: 'none'\n            },\n\n            gesture: {\n                manualStart: false,\n                enabled: false,\n                max: Infinity,\n                maxPerElement: 1,\n\n                restrict: null\n            },\n\n            perAction: {\n                manualStart: false,\n                max: Infinity,\n                maxPerElement: 1,\n\n                snap: {\n                    enabled     : false,\n                    endOnly     : false,\n                    range       : Infinity,\n                    targets     : null,\n                    offsets     : null,\n\n                    relativePoints: null\n                },\n\n                restrict: {\n                    enabled: false,\n                    endOnly: false\n                },\n\n                autoScroll: {\n                    enabled     : false,\n                    container   : null,     // the item that is scrolled (Window or HTMLElement)\n                    margin      : 60,\n                    speed       : 300       // the scroll speed in pixels per second\n                },\n\n                inertia: {\n                    enabled          : false,\n                    resistance       : 10,    // the lambda in exponential decay\n                    minSpeed         : 100,   // target speed must be above this for inertia to start\n                    endSpeed         : 10,    // the speed at which inertia is slow enough to stop\n                    allowResume      : true,  // allow resuming an action in inertia phase\n                    zeroResumeDelta  : true,  // if an action is resumed after launch, set dx/dy to 0\n                    smoothEndDuration: 300    // animate to snap/restrict endOnly if there's no inertia\n                }\n            },\n\n            _holdDuration: 600\n        },\n\n        // Things related to autoScroll\n        autoScroll = {\n            interaction: null,\n            i: null,    // the handle returned by window.setInterval\n            x: 0, y: 0, // Direction each pulse is to scroll in\n\n            // scroll the window by the values in scroll.x/y\n            scroll: function () {\n                var options = autoScroll.interaction.target.options[autoScroll.interaction.prepared.name].autoScroll,\n                    container = options.container || getWindow(autoScroll.interaction.element),\n                    now = new Date().getTime(),\n                    // change in time in seconds\n                    dtx = (now - autoScroll.prevTimeX) / 1000,\n                    dty = (now - autoScroll.prevTimeY) / 1000,\n                    vx, vy, sx, sy;\n\n                // displacement\n                if (options.velocity) {\n                  vx = options.velocity.x;\n                  vy = options.velocity.y;\n                }\n                else {\n                  vx = vy = options.speed\n                }\n \n                sx = vx * dtx;\n                sy = vy * dty;\n\n                if (sx >= 1 || sy >= 1) {\n                    if (isWindow(container)) {\n                        container.scrollBy(autoScroll.x * sx, autoScroll.y * sy);\n                    }\n                    else if (container) {\n                        container.scrollLeft += autoScroll.x * sx;\n                        container.scrollTop  += autoScroll.y * sy;\n                    }\n\n                    if (sx >=1) autoScroll.prevTimeX = now;\n                    if (sy >= 1) autoScroll.prevTimeY = now;\n                }\n\n                if (autoScroll.isScrolling) {\n                    cancelFrame(autoScroll.i);\n                    autoScroll.i = reqFrame(autoScroll.scroll);\n                }\n            },\n\n            isScrolling: false,\n            prevTimeX: 0,\n            prevTimeY: 0,\n\n            start: function (interaction) {\n                autoScroll.isScrolling = true;\n                cancelFrame(autoScroll.i);\n\n                autoScroll.interaction = interaction;\n                autoScroll.prevTimeX = new Date().getTime();\n                autoScroll.prevTimeY = new Date().getTime();\n                autoScroll.i = reqFrame(autoScroll.scroll);\n            },\n\n            stop: function () {\n                autoScroll.isScrolling = false;\n                cancelFrame(autoScroll.i);\n            }\n        },\n\n        // Does the browser support touch input?\n        supportsTouch = (('ontouchstart' in window) || window.DocumentTouch && document instanceof window.DocumentTouch),\n\n        // Does the browser support PointerEvents\n        // Avoid PointerEvent bugs introduced in Chrome 55\n        supportsPointerEvent = PointerEvent && !/Chrome/.test(navigator.userAgent),\n\n        // Less Precision with touch input\n        margin = supportsTouch || supportsPointerEvent? 20: 10,\n\n        pointerMoveTolerance = 1,\n\n        // for ignoring browser's simulated mouse events\n        prevTouchTime = 0,\n\n        // Allow this many interactions to happen simultaneously\n        maxInteractions = Infinity,\n\n        // Check if is IE9 or older\n        actionCursors = (document.all && !window.atob) ? {\n            drag    : 'move',\n            resizex : 'e-resize',\n            resizey : 's-resize',\n            resizexy: 'se-resize',\n\n            resizetop        : 'n-resize',\n            resizeleft       : 'w-resize',\n            resizebottom     : 's-resize',\n            resizeright      : 'e-resize',\n            resizetopleft    : 'se-resize',\n            resizebottomright: 'se-resize',\n            resizetopright   : 'ne-resize',\n            resizebottomleft : 'ne-resize',\n\n            gesture : ''\n        } : {\n            drag    : 'move',\n            resizex : 'ew-resize',\n            resizey : 'ns-resize',\n            resizexy: 'nwse-resize',\n\n            resizetop        : 'ns-resize',\n            resizeleft       : 'ew-resize',\n            resizebottom     : 'ns-resize',\n            resizeright      : 'ew-resize',\n            resizetopleft    : 'nwse-resize',\n            resizebottomright: 'nwse-resize',\n            resizetopright   : 'nesw-resize',\n            resizebottomleft : 'nesw-resize',\n\n            gesture : ''\n        },\n\n        actionIsEnabled = {\n            drag   : true,\n            resize : true,\n            gesture: true\n        },\n\n        // because Webkit and Opera still use 'mousewheel' event type\n        wheelEvent = 'onmousewheel' in document? 'mousewheel': 'wheel',\n\n        eventTypes = [\n            'dragstart',\n            'dragmove',\n            'draginertiastart',\n            'dragend',\n            'dragenter',\n            'dragleave',\n            'dropactivate',\n            'dropdeactivate',\n            'dropmove',\n            'drop',\n            'resizestart',\n            'resizemove',\n            'resizeinertiastart',\n            'resizeend',\n            'gesturestart',\n            'gesturemove',\n            'gestureinertiastart',\n            'gestureend',\n\n            'down',\n            'move',\n            'up',\n            'cancel',\n            'tap',\n            'doubletap',\n            'hold'\n        ],\n\n        globalEvents = {},\n\n        // Opera Mobile must be handled differently\n        isOperaMobile = navigator.appName == 'Opera' &&\n            supportsTouch &&\n            navigator.userAgent.match('Presto'),\n\n        // scrolling doesn't change the result of getClientRects on iOS 7\n        isIOS7 = (/iP(hone|od|ad)/.test(navigator.platform)\n                         && /OS 7[^\\d]/.test(navigator.appVersion)),\n\n        // prefix matchesSelector\n        prefixedMatchesSelector = 'matches' in Element.prototype?\n                'matches': 'webkitMatchesSelector' in Element.prototype?\n                    'webkitMatchesSelector': 'mozMatchesSelector' in Element.prototype?\n                        'mozMatchesSelector': 'oMatchesSelector' in Element.prototype?\n                            'oMatchesSelector': 'msMatchesSelector',\n\n        // will be polyfill function if browser is IE8\n        ie8MatchesSelector,\n\n        // native requestAnimationFrame or polyfill\n        reqFrame = realWindow.requestAnimationFrame,\n        cancelFrame = realWindow.cancelAnimationFrame,\n\n        // Events wrapper\n        events = (function () {\n            var useAttachEvent = ('attachEvent' in window) && !('addEventListener' in window),\n                addEvent       = useAttachEvent?  'attachEvent': 'addEventListener',\n                removeEvent    = useAttachEvent?  'detachEvent': 'removeEventListener',\n                on             = useAttachEvent? 'on': '',\n\n                elements          = [],\n                targets           = [],\n                attachedListeners = [];\n\n            function add (element, type, listener, useCapture) {\n                var elementIndex = indexOf(elements, element),\n                    target = targets[elementIndex];\n\n                if (!target) {\n                    target = {\n                        events: {},\n                        typeCount: 0\n                    };\n\n                    elementIndex = elements.push(element) - 1;\n                    targets.push(target);\n\n                    attachedListeners.push((useAttachEvent ? {\n                            supplied: [],\n                            wrapped : [],\n                            useCount: []\n                        } : null));\n                }\n\n                if (!target.events[type]) {\n                    target.events[type] = [];\n                    target.typeCount++;\n                }\n\n                if (!contains(target.events[type], listener)) {\n                    var ret;\n\n                    if (useAttachEvent) {\n                        var listeners = attachedListeners[elementIndex],\n                            listenerIndex = indexOf(listeners.supplied, listener);\n\n                        var wrapped = listeners.wrapped[listenerIndex] || function (event) {\n                            if (!event.immediatePropagationStopped) {\n                                event.target = event.srcElement;\n                                event.currentTarget = element;\n\n                                event.preventDefault = event.preventDefault || preventDef;\n                                event.stopPropagation = event.stopPropagation || stopProp;\n                                event.stopImmediatePropagation = event.stopImmediatePropagation || stopImmProp;\n\n                                if (/mouse|click/.test(event.type)) {\n                                    event.pageX = event.clientX + getWindow(element).document.documentElement.scrollLeft;\n                                    event.pageY = event.clientY + getWindow(element).document.documentElement.scrollTop;\n                                }\n\n                                listener(event);\n                            }\n                        };\n\n                        ret = element[addEvent](on + type, wrapped, Boolean(useCapture));\n\n                        if (listenerIndex === -1) {\n                            listeners.supplied.push(listener);\n                            listeners.wrapped.push(wrapped);\n                            listeners.useCount.push(1);\n                        }\n                        else {\n                            listeners.useCount[listenerIndex]++;\n                        }\n                    }\n                    else {\n                        ret = element[addEvent](type, listener, useCapture || false);\n                    }\n                    target.events[type].push(listener);\n\n                    return ret;\n                }\n            }\n\n            function remove (element, type, listener, useCapture) {\n                var i,\n                    elementIndex = indexOf(elements, element),\n                    target = targets[elementIndex],\n                    listeners,\n                    listenerIndex,\n                    wrapped = listener;\n\n                if (!target || !target.events) {\n                    return;\n                }\n\n                if (useAttachEvent) {\n                    listeners = attachedListeners[elementIndex];\n                    listenerIndex = indexOf(listeners.supplied, listener);\n                    wrapped = listeners.wrapped[listenerIndex];\n                }\n\n                if (type === 'all') {\n                    for (type in target.events) {\n                        if (target.events.hasOwnProperty(type)) {\n                            remove(element, type, 'all');\n                        }\n                    }\n                    return;\n                }\n\n                if (target.events[type]) {\n                    var len = target.events[type].length;\n\n                    if (listener === 'all') {\n                        for (i = 0; i < len; i++) {\n                            remove(element, type, target.events[type][i], Boolean(useCapture));\n                        }\n                        return;\n                    } else {\n                        for (i = 0; i < len; i++) {\n                            if (target.events[type][i] === listener) {\n                                element[removeEvent](on + type, wrapped, useCapture || false);\n                                target.events[type].splice(i, 1);\n\n                                if (useAttachEvent && listeners) {\n                                    listeners.useCount[listenerIndex]--;\n                                    if (listeners.useCount[listenerIndex] === 0) {\n                                        listeners.supplied.splice(listenerIndex, 1);\n                                        listeners.wrapped.splice(listenerIndex, 1);\n                                        listeners.useCount.splice(listenerIndex, 1);\n                                    }\n                                }\n\n                                break;\n                            }\n                        }\n                    }\n\n                    if (target.events[type] && target.events[type].length === 0) {\n                        target.events[type] = null;\n                        target.typeCount--;\n                    }\n                }\n\n                if (!target.typeCount) {\n                    targets.splice(elementIndex, 1);\n                    elements.splice(elementIndex, 1);\n                    attachedListeners.splice(elementIndex, 1);\n                }\n            }\n\n            function preventDef () {\n                this.returnValue = false;\n            }\n\n            function stopProp () {\n                this.cancelBubble = true;\n            }\n\n            function stopImmProp () {\n                this.cancelBubble = true;\n                this.immediatePropagationStopped = true;\n            }\n\n            return {\n                add: add,\n                remove: remove,\n                useAttachEvent: useAttachEvent,\n\n                _elements: elements,\n                _targets: targets,\n                _attachedListeners: attachedListeners\n            };\n        }());\n\n    function blank () {}\n\n    function isElement (o) {\n        if (!o || (typeof o !== 'object')) { return false; }\n\n        var _window = getWindow(o) || window;\n\n        return (/object|function/.test(typeof _window.Element)\n            ? o instanceof _window.Element //DOM2\n            : o.nodeType === 1 && typeof o.nodeName === \"string\");\n    }\n    function isWindow (thing) { return thing === window || !!(thing && thing.Window) && (thing instanceof thing.Window); }\n    function isDocFrag (thing) { return !!thing && thing instanceof DocumentFragment; }\n    function isArray (thing) {\n        return isObject(thing)\n                && (typeof thing.length !== undefined)\n                && isFunction(thing.splice);\n    }\n    function isObject   (thing) { return !!thing && (typeof thing === 'object'); }\n    function isFunction (thing) { return typeof thing === 'function'; }\n    function isNumber   (thing) { return typeof thing === 'number'  ; }\n    function isBool     (thing) { return typeof thing === 'boolean' ; }\n    function isString   (thing) { return typeof thing === 'string'  ; }\n\n    function trySelector (value) {\n        if (!isString(value)) { return false; }\n\n        // an exception will be raised if it is invalid\n        document.querySelector(value);\n        return true;\n    }\n\n    function extend (dest, source) {\n        for (var prop in source) {\n            dest[prop] = source[prop];\n        }\n        return dest;\n    }\n\n    var prefixedPropREs = {\n      webkit: /(Movement[XY]|Radius[XY]|RotationAngle|Force)$/\n    };\n\n    function pointerExtend (dest, source) {\n        for (var prop in source) {\n          var deprecated = false;\n\n          // skip deprecated prefixed properties\n          for (var vendor in prefixedPropREs) {\n            if (prop.indexOf(vendor) === 0 && prefixedPropREs[vendor].test(prop)) {\n              deprecated = true;\n              break;\n            }\n          }\n\n          if (!deprecated) {\n            dest[prop] = source[prop];\n          }\n        }\n        return dest;\n    }\n\n    function copyCoords (dest, src) {\n        dest.page = dest.page || {};\n        dest.page.x = src.page.x;\n        dest.page.y = src.page.y;\n\n        dest.client = dest.client || {};\n        dest.client.x = src.client.x;\n        dest.client.y = src.client.y;\n\n        dest.timeStamp = src.timeStamp;\n    }\n\n    function setEventXY (targetObj, pointers, interaction) {\n        var pointer = (pointers.length > 1\n                       ? pointerAverage(pointers)\n                       : pointers[0]);\n\n        getPageXY(pointer, tmpXY, interaction);\n        targetObj.page.x = tmpXY.x;\n        targetObj.page.y = tmpXY.y;\n\n        getClientXY(pointer, tmpXY, interaction);\n        targetObj.client.x = tmpXY.x;\n        targetObj.client.y = tmpXY.y;\n\n        targetObj.timeStamp = new Date().getTime();\n    }\n\n    function setEventDeltas (targetObj, prev, cur) {\n        targetObj.page.x     = cur.page.x      - prev.page.x;\n        targetObj.page.y     = cur.page.y      - prev.page.y;\n        targetObj.client.x   = cur.client.x    - prev.client.x;\n        targetObj.client.y   = cur.client.y    - prev.client.y;\n        targetObj.timeStamp = new Date().getTime() - prev.timeStamp;\n\n        // set pointer velocity\n        var dt = Math.max(targetObj.timeStamp / 1000, 0.001);\n        targetObj.page.speed   = hypot(targetObj.page.x, targetObj.page.y) / dt;\n        targetObj.page.vx      = targetObj.page.x / dt;\n        targetObj.page.vy      = targetObj.page.y / dt;\n\n        targetObj.client.speed = hypot(targetObj.client.x, targetObj.page.y) / dt;\n        targetObj.client.vx    = targetObj.client.x / dt;\n        targetObj.client.vy    = targetObj.client.y / dt;\n    }\n\n    function isNativePointer (pointer) {\n        return (pointer instanceof window.Event\n            || (supportsTouch && window.Touch && pointer instanceof window.Touch));\n    }\n\n    // Get specified X/Y coords for mouse or event.touches[0]\n    function getXY (type, pointer, xy) {\n        xy = xy || {};\n        type = type || 'page';\n\n        xy.x = pointer[type + 'X'];\n        xy.y = pointer[type + 'Y'];\n\n        return xy;\n    }\n\n    function getPageXY (pointer, page) {\n        page = page || {};\n\n        // Opera Mobile handles the viewport and scrolling oddly\n        if (isOperaMobile && isNativePointer(pointer)) {\n            getXY('screen', pointer, page);\n\n            page.x += window.scrollX;\n            page.y += window.scrollY;\n        }\n        else {\n            getXY('page', pointer, page);\n        }\n\n        return page;\n    }\n\n    function getClientXY (pointer, client) {\n        client = client || {};\n\n        if (isOperaMobile && isNativePointer(pointer)) {\n            // Opera Mobile handles the viewport and scrolling oddly\n            getXY('screen', pointer, client);\n        }\n        else {\n          getXY('client', pointer, client);\n        }\n\n        return client;\n    }\n\n    function getScrollXY (win) {\n        win = win || window;\n        return {\n            x: win.scrollX || win.document.documentElement.scrollLeft,\n            y: win.scrollY || win.document.documentElement.scrollTop\n        };\n    }\n\n    function getPointerId (pointer) {\n        return isNumber(pointer.pointerId)? pointer.pointerId : pointer.identifier;\n    }\n\n    function getActualElement (element) {\n        return (element instanceof SVGElementInstance\n            ? element.correspondingUseElement\n            : element);\n    }\n\n    function getWindow (node) {\n        if (isWindow(node)) {\n            return node;\n        }\n\n        var rootNode = (node.ownerDocument || node);\n\n        return rootNode.defaultView || rootNode.parentWindow || window;\n    }\n\n    function getElementClientRect (element) {\n        var clientRect = (element instanceof SVGElement\n                            ? element.getBoundingClientRect()\n                            : element.getClientRects()[0]);\n\n        return clientRect && {\n            left  : clientRect.left,\n            right : clientRect.right,\n            top   : clientRect.top,\n            bottom: clientRect.bottom,\n            width : clientRect.width || clientRect.right - clientRect.left,\n            height: clientRect.height || clientRect.bottom - clientRect.top\n        };\n    }\n\n    function getElementRect (element) {\n        var clientRect = getElementClientRect(element);\n\n        if (!isIOS7 && clientRect) {\n            var scroll = getScrollXY(getWindow(element));\n\n            clientRect.left   += scroll.x;\n            clientRect.right  += scroll.x;\n            clientRect.top    += scroll.y;\n            clientRect.bottom += scroll.y;\n        }\n\n        return clientRect;\n    }\n\n    function getTouchPair (event) {\n        var touches = [];\n\n        // array of touches is supplied\n        if (isArray(event)) {\n            touches[0] = event[0];\n            touches[1] = event[1];\n        }\n        // an event\n        else {\n            if (event.type === 'touchend') {\n                if (event.touches.length === 1) {\n                    touches[0] = event.touches[0];\n                    touches[1] = event.changedTouches[0];\n                }\n                else if (event.touches.length === 0) {\n                    touches[0] = event.changedTouches[0];\n                    touches[1] = event.changedTouches[1];\n                }\n            }\n            else {\n                touches[0] = event.touches[0];\n                touches[1] = event.touches[1];\n            }\n        }\n\n        return touches;\n    }\n\n    function pointerAverage (pointers) {\n        var average = {\n            pageX  : 0,\n            pageY  : 0,\n            clientX: 0,\n            clientY: 0,\n            screenX: 0,\n            screenY: 0\n        };\n        var prop;\n\n        for (var i = 0; i < pointers.length; i++) {\n            for (prop in average) {\n                average[prop] += pointers[i][prop];\n            }\n        }\n        for (prop in average) {\n            average[prop] /= pointers.length;\n        }\n\n        return average;\n    }\n\n    function touchBBox (event) {\n        if (!event.length && !(event.touches && event.touches.length > 1)) {\n            return;\n        }\n\n        var touches = getTouchPair(event),\n            minX = Math.min(touches[0].pageX, touches[1].pageX),\n            minY = Math.min(touches[0].pageY, touches[1].pageY),\n            maxX = Math.max(touches[0].pageX, touches[1].pageX),\n            maxY = Math.max(touches[0].pageY, touches[1].pageY);\n\n        return {\n            x: minX,\n            y: minY,\n            left: minX,\n            top: minY,\n            width: maxX - minX,\n            height: maxY - minY\n        };\n    }\n\n    function touchDistance (event, deltaSource) {\n        deltaSource = deltaSource || defaultOptions.deltaSource;\n\n        var sourceX = deltaSource + 'X',\n            sourceY = deltaSource + 'Y',\n            touches = getTouchPair(event);\n\n\n        var dx = touches[0][sourceX] - touches[1][sourceX],\n            dy = touches[0][sourceY] - touches[1][sourceY];\n\n        return hypot(dx, dy);\n    }\n\n    function touchAngle (event, prevAngle, deltaSource) {\n        deltaSource = deltaSource || defaultOptions.deltaSource;\n\n        var sourceX = deltaSource + 'X',\n            sourceY = deltaSource + 'Y',\n            touches = getTouchPair(event),\n            dx = touches[0][sourceX] - touches[1][sourceX],\n            dy = touches[0][sourceY] - touches[1][sourceY],\n            angle = 180 * Math.atan(dy / dx) / Math.PI;\n\n        if (isNumber(prevAngle)) {\n            var dr = angle - prevAngle,\n                drClamped = dr % 360;\n\n            if (drClamped > 315) {\n                angle -= 360 + (angle / 360)|0 * 360;\n            }\n            else if (drClamped > 135) {\n                angle -= 180 + (angle / 360)|0 * 360;\n            }\n            else if (drClamped < -315) {\n                angle += 360 + (angle / 360)|0 * 360;\n            }\n            else if (drClamped < -135) {\n                angle += 180 + (angle / 360)|0 * 360;\n            }\n        }\n\n        return  angle;\n    }\n\n    function getOriginXY (interactable, element) {\n        var origin = interactable\n                ? interactable.options.origin\n                : defaultOptions.origin;\n\n        if (origin === 'parent') {\n            origin = parentElement(element);\n        }\n        else if (origin === 'self') {\n            origin = interactable.getRect(element);\n        }\n        else if (trySelector(origin)) {\n            origin = closest(element, origin) || { x: 0, y: 0 };\n        }\n\n        if (isFunction(origin)) {\n            origin = origin(interactable && element);\n        }\n\n        if (isElement(origin))  {\n            origin = getElementRect(origin);\n        }\n\n        origin.x = ('x' in origin)? origin.x : origin.left;\n        origin.y = ('y' in origin)? origin.y : origin.top;\n\n        return origin;\n    }\n\n    // http://stackoverflow.com/a/5634528/2280888\n    function _getQBezierValue(t, p1, p2, p3) {\n        var iT = 1 - t;\n        return iT * iT * p1 + 2 * iT * t * p2 + t * t * p3;\n    }\n\n    function getQuadraticCurvePoint(startX, startY, cpX, cpY, endX, endY, position) {\n        return {\n            x:  _getQBezierValue(position, startX, cpX, endX),\n            y:  _getQBezierValue(position, startY, cpY, endY)\n        };\n    }\n\n    // http://gizma.com/easing/\n    function easeOutQuad (t, b, c, d) {\n        t /= d;\n        return -c * t*(t-2) + b;\n    }\n\n    function nodeContains (parent, child) {\n        while (child) {\n            if (child === parent) {\n                return true;\n            }\n\n            child = child.parentNode;\n        }\n\n        return false;\n    }\n\n    function closest (child, selector) {\n        var parent = parentElement(child);\n\n        while (isElement(parent)) {\n            if (matchesSelector(parent, selector)) { return parent; }\n\n            parent = parentElement(parent);\n        }\n\n        return null;\n    }\n\n    function parentElement (node) {\n        var parent = node.parentNode;\n\n        if (isDocFrag(parent)) {\n            // skip past #shado-root fragments\n            while ((parent = parent.host) && isDocFrag(parent)) {}\n\n            return parent;\n        }\n\n        return parent;\n    }\n\n    function inContext (interactable, element) {\n        return interactable._context === element.ownerDocument\n                || nodeContains(interactable._context, element);\n    }\n\n    function testIgnore (interactable, interactableElement, element) {\n        var ignoreFrom = interactable.options.ignoreFrom;\n\n        if (!ignoreFrom || !isElement(element)) { return false; }\n\n        if (isString(ignoreFrom)) {\n            return matchesUpTo(element, ignoreFrom, interactableElement);\n        }\n        else if (isElement(ignoreFrom)) {\n            return nodeContains(ignoreFrom, element);\n        }\n\n        return false;\n    }\n\n    function testAllow (interactable, interactableElement, element) {\n        var allowFrom = interactable.options.allowFrom;\n\n        if (!allowFrom) { return true; }\n\n        if (!isElement(element)) { return false; }\n\n        if (isString(allowFrom)) {\n            return matchesUpTo(element, allowFrom, interactableElement);\n        }\n        else if (isElement(allowFrom)) {\n            return nodeContains(allowFrom, element);\n        }\n\n        return false;\n    }\n\n    function checkAxis (axis, interactable) {\n        if (!interactable) { return false; }\n\n        var thisAxis = interactable.options.drag.axis;\n\n        return (axis === 'xy' || thisAxis === 'xy' || thisAxis === axis);\n    }\n\n    function checkSnap (interactable, action) {\n        var options = interactable.options;\n\n        if (/^resize/.test(action)) {\n            action = 'resize';\n        }\n\n        return options[action].snap && options[action].snap.enabled;\n    }\n\n    function checkRestrict (interactable, action) {\n        var options = interactable.options;\n\n        if (/^resize/.test(action)) {\n            action = 'resize';\n        }\n\n        return  options[action].restrict && options[action].restrict.enabled;\n    }\n\n    function checkAutoScroll (interactable, action) {\n        var options = interactable.options;\n\n        if (/^resize/.test(action)) {\n            action = 'resize';\n        }\n\n        return  options[action].autoScroll && options[action].autoScroll.enabled;\n    }\n\n    function withinInteractionLimit (interactable, element, action) {\n        var options = interactable.options,\n            maxActions = options[action.name].max,\n            maxPerElement = options[action.name].maxPerElement,\n            activeInteractions = 0,\n            targetCount = 0,\n            targetElementCount = 0;\n\n        for (var i = 0, len = interactions.length; i < len; i++) {\n            var interaction = interactions[i],\n                otherAction = interaction.prepared.name,\n                active = interaction.interacting();\n\n            if (!active) { continue; }\n\n            activeInteractions++;\n\n            if (activeInteractions >= maxInteractions) {\n                return false;\n            }\n\n            if (interaction.target !== interactable) { continue; }\n\n            targetCount += (otherAction === action.name)|0;\n\n            if (targetCount >= maxActions) {\n                return false;\n            }\n\n            if (interaction.element === element) {\n                targetElementCount++;\n\n                if (otherAction !== action.name || targetElementCount >= maxPerElement) {\n                    return false;\n                }\n            }\n        }\n\n        return maxInteractions > 0;\n    }\n\n    // Test for the element that's \"above\" all other qualifiers\n    function indexOfDeepestElement (elements) {\n        var dropzone,\n            deepestZone = elements[0],\n            index = deepestZone? 0: -1,\n            parent,\n            deepestZoneParents = [],\n            dropzoneParents = [],\n            child,\n            i,\n            n;\n\n        for (i = 1; i < elements.length; i++) {\n            dropzone = elements[i];\n\n            // an element might belong to multiple selector dropzones\n            if (!dropzone || dropzone === deepestZone) {\n                continue;\n            }\n\n            if (!deepestZone) {\n                deepestZone = dropzone;\n                index = i;\n                continue;\n            }\n\n            // check if the deepest or current are document.documentElement or document.rootElement\n            // - if the current dropzone is, do nothing and continue\n            if (dropzone.parentNode === dropzone.ownerDocument) {\n                continue;\n            }\n            // - if deepest is, update with the current dropzone and continue to next\n            else if (deepestZone.parentNode === dropzone.ownerDocument) {\n                deepestZone = dropzone;\n                index = i;\n                continue;\n            }\n\n            if (!deepestZoneParents.length) {\n                parent = deepestZone;\n                while (parent.parentNode && parent.parentNode !== parent.ownerDocument) {\n                    deepestZoneParents.unshift(parent);\n                    parent = parent.parentNode;\n                }\n            }\n\n            // if this element is an svg element and the current deepest is\n            // an HTMLElement\n            if (deepestZone instanceof HTMLElement\n                && dropzone instanceof SVGElement\n                && !(dropzone instanceof SVGSVGElement)) {\n\n                if (dropzone === deepestZone.parentNode) {\n                    continue;\n                }\n\n                parent = dropzone.ownerSVGElement;\n            }\n            else {\n                parent = dropzone;\n            }\n\n            dropzoneParents = [];\n\n            while (parent.parentNode !== parent.ownerDocument) {\n                dropzoneParents.unshift(parent);\n                parent = parent.parentNode;\n            }\n\n            n = 0;\n\n            // get (position of last common ancestor) + 1\n            while (dropzoneParents[n] && dropzoneParents[n] === deepestZoneParents[n]) {\n                n++;\n            }\n\n            var parents = [\n                dropzoneParents[n - 1],\n                dropzoneParents[n],\n                deepestZoneParents[n]\n            ];\n\n            child = parents[0].lastChild;\n\n            while (child) {\n                if (child === parents[1]) {\n                    deepestZone = dropzone;\n                    index = i;\n                    deepestZoneParents = [];\n\n                    break;\n                }\n                else if (child === parents[2]) {\n                    break;\n                }\n\n                child = child.previousSibling;\n            }\n        }\n\n        return index;\n    }\n\n    function Interaction () {\n        this.target          = null; // current interactable being interacted with\n        this.element         = null; // the target element of the interactable\n        this.dropTarget      = null; // the dropzone a drag target might be dropped into\n        this.dropElement     = null; // the element at the time of checking\n        this.prevDropTarget  = null; // the dropzone that was recently dragged away from\n        this.prevDropElement = null; // the element at the time of checking\n\n        this.prepared        = {     // action that's ready to be fired on next move event\n            name : null,\n            axis : null,\n            edges: null\n        };\n\n        this.matches         = [];   // all selectors that are matched by target element\n        this.matchElements   = [];   // corresponding elements\n\n        this.inertiaStatus = {\n            active       : false,\n            smoothEnd    : false,\n            ending       : false,\n\n            startEvent: null,\n            upCoords: {},\n\n            xe: 0, ye: 0,\n            sx: 0, sy: 0,\n\n            t0: 0,\n            vx0: 0, vys: 0,\n            duration: 0,\n\n            resumeDx: 0,\n            resumeDy: 0,\n\n            lambda_v0: 0,\n            one_ve_v0: 0,\n            i  : null\n        };\n\n        if (isFunction(Function.prototype.bind)) {\n            this.boundInertiaFrame = this.inertiaFrame.bind(this);\n            this.boundSmoothEndFrame = this.smoothEndFrame.bind(this);\n        }\n        else {\n            var that = this;\n\n            this.boundInertiaFrame = function () { return that.inertiaFrame(); };\n            this.boundSmoothEndFrame = function () { return that.smoothEndFrame(); };\n        }\n\n        this.activeDrops = {\n            dropzones: [],      // the dropzones that are mentioned below\n            elements : [],      // elements of dropzones that accept the target draggable\n            rects    : []       // the rects of the elements mentioned above\n        };\n\n        // keep track of added pointers\n        this.pointers    = [];\n        this.pointerIds  = [];\n        this.downTargets = [];\n        this.downTimes   = [];\n        this.holdTimers  = [];\n\n        // Previous native pointer move event coordinates\n        this.prevCoords = {\n            page     : { x: 0, y: 0 },\n            client   : { x: 0, y: 0 },\n            timeStamp: 0\n        };\n        // current native pointer move event coordinates\n        this.curCoords = {\n            page     : { x: 0, y: 0 },\n            client   : { x: 0, y: 0 },\n            timeStamp: 0\n        };\n\n        // Starting InteractEvent pointer coordinates\n        this.startCoords = {\n            page     : { x: 0, y: 0 },\n            client   : { x: 0, y: 0 },\n            timeStamp: 0\n        };\n\n        // Change in coordinates and time of the pointer\n        this.pointerDelta = {\n            page     : { x: 0, y: 0, vx: 0, vy: 0, speed: 0 },\n            client   : { x: 0, y: 0, vx: 0, vy: 0, speed: 0 },\n            timeStamp: 0\n        };\n\n        this.downEvent   = null;    // pointerdown/mousedown/touchstart event\n        this.downPointer = {};\n\n        this._eventTarget    = null;\n        this._curEventTarget = null;\n\n        this.prevEvent = null;      // previous action event\n        this.tapTime   = 0;         // time of the most recent tap event\n        this.prevTap   = null;\n\n        this.startOffset    = { left: 0, right: 0, top: 0, bottom: 0 };\n        this.restrictOffset = { left: 0, right: 0, top: 0, bottom: 0 };\n        this.snapOffsets    = [];\n\n        this.gesture = {\n            start: { x: 0, y: 0 },\n\n            startDistance: 0,   // distance between two touches of touchStart\n            prevDistance : 0,\n            distance     : 0,\n\n            scale: 1,           // gesture.distance / gesture.startDistance\n\n            startAngle: 0,      // angle of line joining two touches\n            prevAngle : 0       // angle of the previous gesture event\n        };\n\n        this.snapStatus = {\n            x       : 0, y       : 0,\n            dx      : 0, dy      : 0,\n            realX   : 0, realY   : 0,\n            snappedX: 0, snappedY: 0,\n            targets : [],\n            locked  : false,\n            changed : false\n        };\n\n        this.restrictStatus = {\n            dx         : 0, dy         : 0,\n            restrictedX: 0, restrictedY: 0,\n            snap       : null,\n            restricted : false,\n            changed    : false\n        };\n\n        this.restrictStatus.snap = this.snapStatus;\n\n        this.pointerIsDown   = false;\n        this.pointerWasMoved = false;\n        this.gesturing       = false;\n        this.dragging        = false;\n        this.resizing        = false;\n        this.resizeAxes      = 'xy';\n\n        this.mouse = false;\n\n        interactions.push(this);\n    }\n\n    Interaction.prototype = {\n        getPageXY  : function (pointer, xy) { return   getPageXY(pointer, xy, this); },\n        getClientXY: function (pointer, xy) { return getClientXY(pointer, xy, this); },\n        setEventXY : function (target, ptr) { return  setEventXY(target, ptr, this); },\n\n        pointerOver: function (pointer, event, eventTarget) {\n            if (this.prepared.name || !this.mouse) { return; }\n\n            var curMatches = [],\n                curMatchElements = [],\n                prevTargetElement = this.element;\n\n            this.addPointer(pointer);\n\n            if (this.target\n                && (testIgnore(this.target, this.element, eventTarget)\n                    || !testAllow(this.target, this.element, eventTarget))) {\n                // if the eventTarget should be ignored or shouldn't be allowed\n                // clear the previous target\n                this.target = null;\n                this.element = null;\n                this.matches = [];\n                this.matchElements = [];\n            }\n\n            var elementInteractable = interactables.get(eventTarget),\n                elementAction = (elementInteractable\n                                 && !testIgnore(elementInteractable, eventTarget, eventTarget)\n                                 && testAllow(elementInteractable, eventTarget, eventTarget)\n                                 && validateAction(\n                                     elementInteractable.getAction(pointer, event, this, eventTarget),\n                                     elementInteractable));\n\n            if (elementAction && !withinInteractionLimit(elementInteractable, eventTarget, elementAction)) {\n                 elementAction = null;\n            }\n\n            function pushCurMatches (interactable, selector) {\n                if (interactable\n                    && inContext(interactable, eventTarget)\n                    && !testIgnore(interactable, eventTarget, eventTarget)\n                    && testAllow(interactable, eventTarget, eventTarget)\n                    && matchesSelector(eventTarget, selector)) {\n\n                    curMatches.push(interactable);\n                    curMatchElements.push(eventTarget);\n                }\n            }\n\n            if (elementAction) {\n                this.target = elementInteractable;\n                this.element = eventTarget;\n                this.matches = [];\n                this.matchElements = [];\n            }\n            else {\n                interactables.forEachSelector(pushCurMatches);\n\n                if (this.validateSelector(pointer, event, curMatches, curMatchElements)) {\n                    this.matches = curMatches;\n                    this.matchElements = curMatchElements;\n\n                    this.pointerHover(pointer, event, this.matches, this.matchElements);\n                    events.add(eventTarget,\n                                        supportsPointerEvent? pEventTypes.move : 'mousemove',\n                                        listeners.pointerHover);\n                }\n                else if (this.target) {\n                    if (nodeContains(prevTargetElement, eventTarget)) {\n                        this.pointerHover(pointer, event, this.matches, this.matchElements);\n                        events.add(this.element,\n                                            supportsPointerEvent? pEventTypes.move : 'mousemove',\n                                            listeners.pointerHover);\n                    }\n                    else {\n                        this.target = null;\n                        this.element = null;\n                        this.matches = [];\n                        this.matchElements = [];\n                    }\n                }\n            }\n        },\n\n        // Check what action would be performed on pointerMove target if a mouse\n        // button were pressed and change the cursor accordingly\n        pointerHover: function (pointer, event, eventTarget, curEventTarget, matches, matchElements) {\n            var target = this.target;\n\n            if (!this.prepared.name && this.mouse) {\n\n                var action;\n\n                // update pointer coords for defaultActionChecker to use\n                this.setEventXY(this.curCoords, [pointer]);\n\n                if (matches) {\n                    action = this.validateSelector(pointer, event, matches, matchElements);\n                }\n                else if (target) {\n                    action = validateAction(target.getAction(this.pointers[0], event, this, this.element), this.target);\n                }\n\n                if (target && target.options.styleCursor) {\n                    if (action) {\n                        target._doc.documentElement.style.cursor = getActionCursor(action);\n                    }\n                    else {\n                        target._doc.documentElement.style.cursor = '';\n                    }\n                }\n            }\n            else if (this.prepared.name) {\n                this.checkAndPreventDefault(event, target, this.element);\n            }\n        },\n\n        pointerOut: function (pointer, event, eventTarget) {\n            if (this.prepared.name) { return; }\n\n            // Remove temporary event listeners for selector Interactables\n            if (!interactables.get(eventTarget)) {\n                events.remove(eventTarget,\n                                       supportsPointerEvent? pEventTypes.move : 'mousemove',\n                                       listeners.pointerHover);\n            }\n\n            if (this.target && this.target.options.styleCursor && !this.interacting()) {\n                this.target._doc.documentElement.style.cursor = '';\n            }\n        },\n\n        selectorDown: function (pointer, event, eventTarget, curEventTarget) {\n            var that = this,\n                // copy event to be used in timeout for IE8\n                eventCopy = events.useAttachEvent? extend({}, event) : event,\n                element = eventTarget,\n                pointerIndex = this.addPointer(pointer),\n                action;\n\n            this.holdTimers[pointerIndex] = setTimeout(function () {\n                that.pointerHold(events.useAttachEvent? eventCopy : pointer, eventCopy, eventTarget, curEventTarget);\n            }, defaultOptions._holdDuration);\n\n            this.pointerIsDown = true;\n\n            // Check if the down event hits the current inertia target\n            if (this.inertiaStatus.active && this.target.selector) {\n                // climb up the DOM tree from the event target\n                while (isElement(element)) {\n\n                    // if this element is the current inertia target element\n                    if (element === this.element\n                        // and the prospective action is the same as the ongoing one\n                        && validateAction(this.target.getAction(pointer, event, this, this.element), this.target).name === this.prepared.name) {\n\n                        // stop inertia so that the next move will be a normal one\n                        cancelFrame(this.inertiaStatus.i);\n                        this.inertiaStatus.active = false;\n\n                        this.collectEventTargets(pointer, event, eventTarget, 'down');\n                        return;\n                    }\n                    element = parentElement(element);\n                }\n            }\n\n            // do nothing if interacting\n            if (this.interacting()) {\n                this.collectEventTargets(pointer, event, eventTarget, 'down');\n                return;\n            }\n\n            function pushMatches (interactable, selector, context) {\n                var elements = ie8MatchesSelector\n                    ? context.querySelectorAll(selector)\n                    : undefined;\n\n                if (inContext(interactable, element)\n                    && !testIgnore(interactable, element, eventTarget)\n                    && testAllow(interactable, element, eventTarget)\n                    && matchesSelector(element, selector, elements)) {\n\n                    that.matches.push(interactable);\n                    that.matchElements.push(element);\n                }\n            }\n\n            // update pointer coords for defaultActionChecker to use\n            this.setEventXY(this.curCoords, [pointer]);\n            this.downEvent = event;\n\n            while (isElement(element) && !action) {\n                this.matches = [];\n                this.matchElements = [];\n\n                interactables.forEachSelector(pushMatches);\n\n                action = this.validateSelector(pointer, event, this.matches, this.matchElements);\n                element = parentElement(element);\n            }\n\n            if (action) {\n                this.prepared.name  = action.name;\n                this.prepared.axis  = action.axis;\n                this.prepared.edges = action.edges;\n\n                this.collectEventTargets(pointer, event, eventTarget, 'down');\n\n                return this.pointerDown(pointer, event, eventTarget, curEventTarget, action);\n            }\n            else {\n                // do these now since pointerDown isn't being called from here\n                this.downTimes[pointerIndex] = new Date().getTime();\n                this.downTargets[pointerIndex] = eventTarget;\n                pointerExtend(this.downPointer, pointer);\n\n                copyCoords(this.prevCoords, this.curCoords);\n                this.pointerWasMoved = false;\n            }\n\n            this.collectEventTargets(pointer, event, eventTarget, 'down');\n        },\n\n        // Determine action to be performed on next pointerMove and add appropriate\n        // style and event Listeners\n        pointerDown: function (pointer, event, eventTarget, curEventTarget, forceAction) {\n            if (!forceAction && !this.inertiaStatus.active && this.pointerWasMoved && this.prepared.name) {\n                this.checkAndPreventDefault(event, this.target, this.element);\n\n                return;\n            }\n\n            this.pointerIsDown = true;\n            this.downEvent = event;\n\n            var pointerIndex = this.addPointer(pointer),\n                action;\n\n            // If it is the second touch of a multi-touch gesture, keep the\n            // target the same and get a new action if a target was set by the\n            // first touch\n            if (this.pointerIds.length > 1 && this.target._element === this.element) {\n                var newAction = validateAction(forceAction || this.target.getAction(pointer, event, this, this.element), this.target);\n\n                if (withinInteractionLimit(this.target, this.element, newAction)) {\n                    action = newAction;\n                }\n\n                this.prepared.name = null;\n            }\n            // Otherwise, set the target if there is no action prepared\n            else if (!this.prepared.name) {\n                var interactable = interactables.get(curEventTarget);\n\n                if (interactable\n                    && !testIgnore(interactable, curEventTarget, eventTarget)\n                    && testAllow(interactable, curEventTarget, eventTarget)\n                    && (action = validateAction(forceAction || interactable.getAction(pointer, event, this, curEventTarget), interactable, eventTarget))\n                    && withinInteractionLimit(interactable, curEventTarget, action)) {\n                    this.target = interactable;\n                    this.element = curEventTarget;\n                }\n            }\n\n            var target = this.target,\n                options = target && target.options;\n\n            if (target && (forceAction || !this.prepared.name)) {\n                action = action || validateAction(forceAction || target.getAction(pointer, event, this, curEventTarget), target, this.element);\n\n                this.setEventXY(this.startCoords, this.pointers);\n\n                if (!action) { return; }\n\n                if (options.styleCursor) {\n                    target._doc.documentElement.style.cursor = getActionCursor(action);\n                }\n\n                this.resizeAxes = action.name === 'resize'? action.axis : null;\n\n                if (action === 'gesture' && this.pointerIds.length < 2) {\n                    action = null;\n                }\n\n                this.prepared.name  = action.name;\n                this.prepared.axis  = action.axis;\n                this.prepared.edges = action.edges;\n\n                this.snapStatus.snappedX = this.snapStatus.snappedY =\n                    this.restrictStatus.restrictedX = this.restrictStatus.restrictedY = NaN;\n\n                this.downTimes[pointerIndex] = new Date().getTime();\n                this.downTargets[pointerIndex] = eventTarget;\n                pointerExtend(this.downPointer, pointer);\n\n                copyCoords(this.prevCoords, this.startCoords);\n                this.pointerWasMoved = false;\n\n                this.checkAndPreventDefault(event, target, this.element);\n            }\n            // if inertia is active try to resume action\n            else if (this.inertiaStatus.active\n                && curEventTarget === this.element\n                && validateAction(target.getAction(pointer, event, this, this.element), target).name === this.prepared.name) {\n\n                cancelFrame(this.inertiaStatus.i);\n                this.inertiaStatus.active = false;\n\n                this.checkAndPreventDefault(event, target, this.element);\n            }\n        },\n\n        setModifications: function (coords, preEnd) {\n            var target         = this.target,\n                shouldMove     = true,\n                shouldSnap     = checkSnap(target, this.prepared.name)     && (!target.options[this.prepared.name].snap.endOnly     || preEnd),\n                shouldRestrict = checkRestrict(target, this.prepared.name) && (!target.options[this.prepared.name].restrict.endOnly || preEnd);\n\n            if (shouldSnap    ) { this.setSnapping   (coords); } else { this.snapStatus    .locked     = false; }\n            if (shouldRestrict) { this.setRestriction(coords); } else { this.restrictStatus.restricted = false; }\n\n            if (shouldSnap && this.snapStatus.locked && !this.snapStatus.changed) {\n                shouldMove = shouldRestrict && this.restrictStatus.restricted && this.restrictStatus.changed;\n            }\n            else if (shouldRestrict && this.restrictStatus.restricted && !this.restrictStatus.changed) {\n                shouldMove = false;\n            }\n\n            return shouldMove;\n        },\n\n        setStartOffsets: function (action, interactable, element) {\n            var rect = interactable.getRect(element),\n                origin = getOriginXY(interactable, element),\n                snap = interactable.options[this.prepared.name].snap,\n                restrict = interactable.options[this.prepared.name].restrict,\n                width, height;\n\n            if (rect) {\n                this.startOffset.left = this.startCoords.page.x - rect.left;\n                this.startOffset.top  = this.startCoords.page.y - rect.top;\n\n                this.startOffset.right  = rect.right  - this.startCoords.page.x;\n                this.startOffset.bottom = rect.bottom - this.startCoords.page.y;\n\n                if ('width' in rect) { width = rect.width; }\n                else { width = rect.right - rect.left; }\n                if ('height' in rect) { height = rect.height; }\n                else { height = rect.bottom - rect.top; }\n            }\n            else {\n                this.startOffset.left = this.startOffset.top = this.startOffset.right = this.startOffset.bottom = 0;\n            }\n\n            this.snapOffsets.splice(0);\n\n            var snapOffset = snap && snap.offset === 'startCoords'\n                                ? {\n                                    x: this.startCoords.page.x - origin.x,\n                                    y: this.startCoords.page.y - origin.y\n                                }\n                                : snap && snap.offset || { x: 0, y: 0 };\n\n            if (rect && snap && snap.relativePoints && snap.relativePoints.length) {\n                for (var i = 0; i < snap.relativePoints.length; i++) {\n                    this.snapOffsets.push({\n                        x: this.startOffset.left - (width  * snap.relativePoints[i].x) + snapOffset.x,\n                        y: this.startOffset.top  - (height * snap.relativePoints[i].y) + snapOffset.y\n                    });\n                }\n            }\n            else {\n                this.snapOffsets.push(snapOffset);\n            }\n\n            if (rect && restrict.elementRect) {\n                this.restrictOffset.left = this.startOffset.left - (width  * restrict.elementRect.left);\n                this.restrictOffset.top  = this.startOffset.top  - (height * restrict.elementRect.top);\n\n                this.restrictOffset.right  = this.startOffset.right  - (width  * (1 - restrict.elementRect.right));\n                this.restrictOffset.bottom = this.startOffset.bottom - (height * (1 - restrict.elementRect.bottom));\n            }\n            else {\n                this.restrictOffset.left = this.restrictOffset.top = this.restrictOffset.right = this.restrictOffset.bottom = 0;\n            }\n        },\n\n        /*\\\n         * Interaction.start\n         [ method ]\n         *\n         * Start an action with the given Interactable and Element as tartgets. The\n         * action must be enabled for the target Interactable and an appropriate number\n         * of pointers must be held down  1 for drag/resize, 2 for gesture.\n         *\n         * Use it with `interactable.<action>able({ manualStart: false })` to always\n         * [start actions manually](https://github.com/taye/interact.js/issues/114)\n         *\n         - action       (object)  The action to be performed - drag, resize, etc.\n         - interactable (Interactable) The Interactable to target\n         - element      (Element) The DOM Element to target\n         = (object) interact\n         **\n         | interact(target)\n         |   .draggable({\n         |     // disable the default drag start by down->move\n         |     manualStart: true\n         |   })\n         |   // start dragging after the user holds the pointer down\n         |   .on('hold', function (event) {\n         |     var interaction = event.interaction;\n         |\n         |     if (!interaction.interacting()) {\n         |       interaction.start({ name: 'drag' },\n         |                         event.interactable,\n         |                         event.currentTarget);\n         |     }\n         | });\n        \\*/\n        start: function (action, interactable, element) {\n            if (this.interacting()\n                || !this.pointerIsDown\n                || this.pointerIds.length < (action.name === 'gesture'? 2 : 1)) {\n                return;\n            }\n\n            // if this interaction had been removed after stopping\n            // add it back\n            if (indexOf(interactions, this) === -1) {\n                interactions.push(this);\n            }\n\n            // set the startCoords if there was no prepared action\n            if (!this.prepared.name) {\n                this.setEventXY(this.startCoords, this.pointers);\n            }\n\n            this.prepared.name  = action.name;\n            this.prepared.axis  = action.axis;\n            this.prepared.edges = action.edges;\n            this.target         = interactable;\n            this.element        = element;\n\n            this.setStartOffsets(action.name, interactable, element);\n            this.setModifications(this.startCoords.page);\n\n            this.prevEvent = this[this.prepared.name + 'Start'](this.downEvent);\n        },\n\n        pointerMove: function (pointer, event, eventTarget, curEventTarget, preEnd) {\n            if (this.inertiaStatus.active) {\n                var pageUp   = this.inertiaStatus.upCoords.page;\n                var clientUp = this.inertiaStatus.upCoords.client;\n\n                var inertiaPosition = {\n                    pageX  : pageUp.x   + this.inertiaStatus.sx,\n                    pageY  : pageUp.y   + this.inertiaStatus.sy,\n                    clientX: clientUp.x + this.inertiaStatus.sx,\n                    clientY: clientUp.y + this.inertiaStatus.sy\n                };\n\n                this.setEventXY(this.curCoords, [inertiaPosition]);\n            }\n            else {\n                this.recordPointer(pointer);\n                this.setEventXY(this.curCoords, this.pointers);\n            }\n\n            var duplicateMove = (this.curCoords.page.x === this.prevCoords.page.x\n                                 && this.curCoords.page.y === this.prevCoords.page.y\n                                 && this.curCoords.client.x === this.prevCoords.client.x\n                                 && this.curCoords.client.y === this.prevCoords.client.y);\n\n            var dx, dy,\n                pointerIndex = this.mouse? 0 : indexOf(this.pointerIds, getPointerId(pointer));\n\n            // register movement greater than pointerMoveTolerance\n            if (this.pointerIsDown && !this.pointerWasMoved) {\n                dx = this.curCoords.client.x - this.startCoords.client.x;\n                dy = this.curCoords.client.y - this.startCoords.client.y;\n\n                this.pointerWasMoved = hypot(dx, dy) > pointerMoveTolerance;\n            }\n\n            if (!duplicateMove && (!this.pointerIsDown || this.pointerWasMoved)) {\n                if (this.pointerIsDown) {\n                    clearTimeout(this.holdTimers[pointerIndex]);\n                }\n\n                this.collectEventTargets(pointer, event, eventTarget, 'move');\n            }\n\n            if (!this.pointerIsDown) { return; }\n\n            if (duplicateMove && this.pointerWasMoved && !preEnd) {\n                this.checkAndPreventDefault(event, this.target, this.element);\n                return;\n            }\n\n            // set pointer coordinate, time changes and speeds\n            setEventDeltas(this.pointerDelta, this.prevCoords, this.curCoords);\n\n            if (!this.prepared.name) { return; }\n\n            if (this.pointerWasMoved\n                // ignore movement while inertia is active\n                && (!this.inertiaStatus.active || (pointer instanceof InteractEvent && /inertiastart/.test(pointer.type)))) {\n\n                // if just starting an action, calculate the pointer speed now\n                if (!this.interacting()) {\n                    setEventDeltas(this.pointerDelta, this.prevCoords, this.curCoords);\n\n                    // check if a drag is in the correct axis\n                    if (this.prepared.name === 'drag') {\n                        var absX = Math.abs(dx),\n                            absY = Math.abs(dy),\n                            targetAxis = this.target.options.drag.axis,\n                            axis = (absX > absY ? 'x' : absX < absY ? 'y' : 'xy');\n\n                        // if the movement isn't in the axis of the interactable\n                        if (axis !== 'xy' && targetAxis !== 'xy' && targetAxis !== axis) {\n                            // cancel the prepared action\n                            this.prepared.name = null;\n\n                            // then try to get a drag from another ineractable\n\n                            var element = eventTarget;\n\n                            // check element interactables\n                            while (isElement(element)) {\n                                var elementInteractable = interactables.get(element);\n\n                                if (elementInteractable\n                                    && elementInteractable !== this.target\n                                    && !elementInteractable.options.drag.manualStart\n                                    && elementInteractable.getAction(this.downPointer, this.downEvent, this, element).name === 'drag'\n                                    && checkAxis(axis, elementInteractable)) {\n\n                                    this.prepared.name = 'drag';\n                                    this.target = elementInteractable;\n                                    this.element = element;\n                                    break;\n                                }\n\n                                element = parentElement(element);\n                            }\n\n                            // if there's no drag from element interactables,\n                            // check the selector interactables\n                            if (!this.prepared.name) {\n                                var thisInteraction = this;\n\n                                var getDraggable = function (interactable, selector, context) {\n                                    var elements = ie8MatchesSelector\n                                        ? context.querySelectorAll(selector)\n                                        : undefined;\n\n                                    if (interactable === thisInteraction.target) { return; }\n\n                                    if (inContext(interactable, eventTarget)\n                                        && !interactable.options.drag.manualStart\n                                        && !testIgnore(interactable, element, eventTarget)\n                                        && testAllow(interactable, element, eventTarget)\n                                        && matchesSelector(element, selector, elements)\n                                        && interactable.getAction(thisInteraction.downPointer, thisInteraction.downEvent, thisInteraction, element).name === 'drag'\n                                        && checkAxis(axis, interactable)\n                                        && withinInteractionLimit(interactable, element, 'drag')) {\n\n                                        return interactable;\n                                    }\n                                };\n\n                                element = eventTarget;\n\n                                while (isElement(element)) {\n                                    var selectorInteractable = interactables.forEachSelector(getDraggable);\n\n                                    if (selectorInteractable) {\n                                        this.prepared.name = 'drag';\n                                        this.target = selectorInteractable;\n                                        this.element = element;\n                                        break;\n                                    }\n\n                                    element = parentElement(element);\n                                }\n                            }\n                        }\n                    }\n                }\n\n                var starting = !!this.prepared.name && !this.interacting();\n\n                if (starting\n                    && (this.target.options[this.prepared.name].manualStart\n                        || !withinInteractionLimit(this.target, this.element, this.prepared))) {\n                    this.stop(event);\n                    return;\n                }\n\n                if (this.prepared.name && this.target) {\n                    if (starting) {\n                        this.start(this.prepared, this.target, this.element);\n                    }\n\n                    var shouldMove = this.setModifications(this.curCoords.page, preEnd);\n\n                    // move if snapping or restriction doesn't prevent it\n                    if (shouldMove || starting) {\n                        this.prevEvent = this[this.prepared.name + 'Move'](event);\n                    }\n\n                    this.checkAndPreventDefault(event, this.target, this.element);\n                }\n            }\n\n            copyCoords(this.prevCoords, this.curCoords);\n\n            if (this.dragging || this.resizing) {\n                this.autoScrollMove(pointer);\n            }\n        },\n\n        dragStart: function (event) {\n            var dragEvent = new InteractEvent(this, event, 'drag', 'start', this.element);\n\n            this.dragging = true;\n            this.target.fire(dragEvent);\n\n            // reset active dropzones\n            this.activeDrops.dropzones = [];\n            this.activeDrops.elements  = [];\n            this.activeDrops.rects     = [];\n\n            if (!this.dynamicDrop) {\n                this.setActiveDrops(this.element);\n            }\n\n            var dropEvents = this.getDropEvents(event, dragEvent);\n\n            if (dropEvents.activate) {\n                this.fireActiveDrops(dropEvents.activate);\n            }\n\n            return dragEvent;\n        },\n\n        dragMove: function (event) {\n            var target = this.target,\n                dragEvent  = new InteractEvent(this, event, 'drag', 'move', this.element),\n                draggableElement = this.element,\n                drop = this.getDrop(dragEvent, event, draggableElement);\n\n            this.dropTarget = drop.dropzone;\n            this.dropElement = drop.element;\n\n            var dropEvents = this.getDropEvents(event, dragEvent);\n\n            target.fire(dragEvent);\n\n            if (dropEvents.leave) { this.prevDropTarget.fire(dropEvents.leave); }\n            if (dropEvents.enter) {     this.dropTarget.fire(dropEvents.enter); }\n            if (dropEvents.move ) {     this.dropTarget.fire(dropEvents.move ); }\n\n            this.prevDropTarget  = this.dropTarget;\n            this.prevDropElement = this.dropElement;\n\n            return dragEvent;\n        },\n\n        resizeStart: function (event) {\n            var resizeEvent = new InteractEvent(this, event, 'resize', 'start', this.element);\n\n            if (this.prepared.edges) {\n                var startRect = this.target.getRect(this.element);\n\n                /*\n                 * When using the `resizable.square` or `resizable.preserveAspectRatio` options, resizing from one edge\n                 * will affect another. E.g. with `resizable.square`, resizing to make the right edge larger will make\n                 * the bottom edge larger by the same amount. We call these 'linked' edges. Any linked edges will depend\n                 * on the active edges and the edge being interacted with.\n                 */\n                if (this.target.options.resize.square || this.target.options.resize.preserveAspectRatio) {\n                    var linkedEdges = extend({}, this.prepared.edges);\n\n                    linkedEdges.top    = linkedEdges.top    || (linkedEdges.left   && !linkedEdges.bottom);\n                    linkedEdges.left   = linkedEdges.left   || (linkedEdges.top    && !linkedEdges.right );\n                    linkedEdges.bottom = linkedEdges.bottom || (linkedEdges.right  && !linkedEdges.top   );\n                    linkedEdges.right  = linkedEdges.right  || (linkedEdges.bottom && !linkedEdges.left  );\n\n                    this.prepared._linkedEdges = linkedEdges;\n                }\n                else {\n                    this.prepared._linkedEdges = null;\n                }\n\n                // if using `resizable.preserveAspectRatio` option, record aspect ratio at the start of the resize\n                if (this.target.options.resize.preserveAspectRatio) {\n                    this.resizeStartAspectRatio = startRect.width / startRect.height;\n                }\n\n                this.resizeRects = {\n                    start     : startRect,\n                    current   : extend({}, startRect),\n                    restricted: extend({}, startRect),\n                    previous  : extend({}, startRect),\n                    delta     : {\n                        left: 0, right : 0, width : 0,\n                        top : 0, bottom: 0, height: 0\n                    }\n                };\n\n                resizeEvent.rect = this.resizeRects.restricted;\n                resizeEvent.deltaRect = this.resizeRects.delta;\n            }\n\n            this.target.fire(resizeEvent);\n\n            this.resizing = true;\n\n            return resizeEvent;\n        },\n\n        resizeMove: function (event) {\n            var resizeEvent = new InteractEvent(this, event, 'resize', 'move', this.element);\n\n            var edges = this.prepared.edges,\n                invert = this.target.options.resize.invert,\n                invertible = invert === 'reposition' || invert === 'negate';\n\n            if (edges) {\n                var dx = resizeEvent.dx,\n                    dy = resizeEvent.dy,\n\n                    start      = this.resizeRects.start,\n                    current    = this.resizeRects.current,\n                    restricted = this.resizeRects.restricted,\n                    delta      = this.resizeRects.delta,\n                    previous   = extend(this.resizeRects.previous, restricted),\n\n                    originalEdges = edges;\n\n                // `resize.preserveAspectRatio` takes precedence over `resize.square`\n                if (this.target.options.resize.preserveAspectRatio) {\n                    var resizeStartAspectRatio = this.resizeStartAspectRatio;\n\n                    edges = this.prepared._linkedEdges;\n\n                    if ((originalEdges.left && originalEdges.bottom)\n                        || (originalEdges.right && originalEdges.top)) {\n                        dy = -dx / resizeStartAspectRatio;\n                    }\n                    else if (originalEdges.left || originalEdges.right) { dy = dx / resizeStartAspectRatio; }\n                    else if (originalEdges.top || originalEdges.bottom) { dx = dy * resizeStartAspectRatio; }\n                }\n                else if (this.target.options.resize.square) {\n                    edges = this.prepared._linkedEdges;\n\n                    if ((originalEdges.left && originalEdges.bottom)\n                        || (originalEdges.right && originalEdges.top)) {\n                        dy = -dx;\n                    }\n                    else if (originalEdges.left || originalEdges.right) { dy = dx; }\n                    else if (originalEdges.top || originalEdges.bottom) { dx = dy; }\n                }\n\n                // update the 'current' rect without modifications\n                if (edges.top   ) { current.top    += dy; }\n                if (edges.bottom) { current.bottom += dy; }\n                if (edges.left  ) { current.left   += dx; }\n                if (edges.right ) { current.right  += dx; }\n\n                if (invertible) {\n                    // if invertible, copy the current rect\n                    extend(restricted, current);\n\n                    if (invert === 'reposition') {\n                        // swap edge values if necessary to keep width/height positive\n                        var swap;\n\n                        if (restricted.top > restricted.bottom) {\n                            swap = restricted.top;\n\n                            restricted.top = restricted.bottom;\n                            restricted.bottom = swap;\n                        }\n                        if (restricted.left > restricted.right) {\n                            swap = restricted.left;\n\n                            restricted.left = restricted.right;\n                            restricted.right = swap;\n                        }\n                    }\n                }\n                else {\n                    // if not invertible, restrict to minimum of 0x0 rect\n                    restricted.top    = Math.min(current.top, start.bottom);\n                    restricted.bottom = Math.max(current.bottom, start.top);\n                    restricted.left   = Math.min(current.left, start.right);\n                    restricted.right  = Math.max(current.right, start.left);\n                }\n\n                restricted.width  = restricted.right  - restricted.left;\n                restricted.height = restricted.bottom - restricted.top ;\n\n                for (var edge in restricted) {\n                    delta[edge] = restricted[edge] - previous[edge];\n                }\n\n                resizeEvent.edges = this.prepared.edges;\n                resizeEvent.rect = restricted;\n                resizeEvent.deltaRect = delta;\n            }\n\n            this.target.fire(resizeEvent);\n\n            return resizeEvent;\n        },\n\n        gestureStart: function (event) {\n            var gestureEvent = new InteractEvent(this, event, 'gesture', 'start', this.element);\n\n            gestureEvent.ds = 0;\n\n            this.gesture.startDistance = this.gesture.prevDistance = gestureEvent.distance;\n            this.gesture.startAngle = this.gesture.prevAngle = gestureEvent.angle;\n            this.gesture.scale = 1;\n\n            this.gesturing = true;\n\n            this.target.fire(gestureEvent);\n\n            return gestureEvent;\n        },\n\n        gestureMove: function (event) {\n            if (!this.pointerIds.length) {\n                return this.prevEvent;\n            }\n\n            var gestureEvent;\n\n            gestureEvent = new InteractEvent(this, event, 'gesture', 'move', this.element);\n            gestureEvent.ds = gestureEvent.scale - this.gesture.scale;\n\n            this.target.fire(gestureEvent);\n\n            this.gesture.prevAngle = gestureEvent.angle;\n            this.gesture.prevDistance = gestureEvent.distance;\n\n            if (gestureEvent.scale !== Infinity &&\n                gestureEvent.scale !== null &&\n                gestureEvent.scale !== undefined  &&\n                !isNaN(gestureEvent.scale)) {\n\n                this.gesture.scale = gestureEvent.scale;\n            }\n\n            return gestureEvent;\n        },\n\n        pointerHold: function (pointer, event, eventTarget) {\n            this.collectEventTargets(pointer, event, eventTarget, 'hold');\n        },\n\n        pointerUp: function (pointer, event, eventTarget, curEventTarget) {\n            var pointerIndex = this.mouse? 0 : indexOf(this.pointerIds, getPointerId(pointer));\n\n            clearTimeout(this.holdTimers[pointerIndex]);\n\n            this.collectEventTargets(pointer, event, eventTarget, 'up' );\n            this.collectEventTargets(pointer, event, eventTarget, 'tap');\n\n            this.pointerEnd(pointer, event, eventTarget, curEventTarget);\n\n            this.removePointer(pointer);\n        },\n\n        pointerCancel: function (pointer, event, eventTarget, curEventTarget) {\n            var pointerIndex = this.mouse? 0 : indexOf(this.pointerIds, getPointerId(pointer));\n\n            clearTimeout(this.holdTimers[pointerIndex]);\n\n            this.collectEventTargets(pointer, event, eventTarget, 'cancel');\n            this.pointerEnd(pointer, event, eventTarget, curEventTarget);\n\n            this.removePointer(pointer);\n        },\n\n        // http://www.quirksmode.org/dom/events/click.html\n        // >Events leading to dblclick\n        //\n        // IE8 doesn't fire down event before dblclick.\n        // This workaround tries to fire a tap and doubletap after dblclick\n        ie8Dblclick: function (pointer, event, eventTarget) {\n            if (this.prevTap\n                && event.clientX === this.prevTap.clientX\n                && event.clientY === this.prevTap.clientY\n                && eventTarget   === this.prevTap.target) {\n\n                this.downTargets[0] = eventTarget;\n                this.downTimes[0] = new Date().getTime();\n                this.collectEventTargets(pointer, event, eventTarget, 'tap');\n            }\n        },\n\n        // End interact move events and stop auto-scroll unless inertia is enabled\n        pointerEnd: function (pointer, event, eventTarget, curEventTarget) {\n            var endEvent,\n                target = this.target,\n                options = target && target.options,\n                inertiaOptions = options && this.prepared.name && options[this.prepared.name].inertia,\n                inertiaStatus = this.inertiaStatus;\n\n            if (this.interacting()) {\n\n                if (inertiaStatus.active && !inertiaStatus.ending) { return; }\n\n                var pointerSpeed,\n                    now = new Date().getTime(),\n                    inertiaPossible = false,\n                    inertia = false,\n                    smoothEnd = false,\n                    endSnap = checkSnap(target, this.prepared.name) && options[this.prepared.name].snap.endOnly,\n                    endRestrict = checkRestrict(target, this.prepared.name) && options[this.prepared.name].restrict.endOnly,\n                    dx = 0,\n                    dy = 0,\n                    startEvent;\n\n                if (this.dragging) {\n                    if      (options.drag.axis === 'x' ) { pointerSpeed = Math.abs(this.pointerDelta.client.vx); }\n                    else if (options.drag.axis === 'y' ) { pointerSpeed = Math.abs(this.pointerDelta.client.vy); }\n                    else   /*options.drag.axis === 'xy'*/{ pointerSpeed = this.pointerDelta.client.speed; }\n                }\n                else {\n                    pointerSpeed = this.pointerDelta.client.speed;\n                }\n\n                // check if inertia should be started\n                inertiaPossible = (inertiaOptions && inertiaOptions.enabled\n                                   && this.prepared.name !== 'gesture'\n                                   && event !== inertiaStatus.startEvent);\n\n                inertia = (inertiaPossible\n                           && (now - this.curCoords.timeStamp) < 50\n                           && pointerSpeed > inertiaOptions.minSpeed\n                           && pointerSpeed > inertiaOptions.endSpeed);\n\n                if (inertiaPossible && !inertia && (endSnap || endRestrict)) {\n\n                    var snapRestrict = {};\n\n                    snapRestrict.snap = snapRestrict.restrict = snapRestrict;\n\n                    if (endSnap) {\n                        this.setSnapping(this.curCoords.page, snapRestrict);\n                        if (snapRestrict.locked) {\n                            dx += snapRestrict.dx;\n                            dy += snapRestrict.dy;\n                        }\n                    }\n\n                    if (endRestrict) {\n                        this.setRestriction(this.curCoords.page, snapRestrict);\n                        if (snapRestrict.restricted) {\n                            dx += snapRestrict.dx;\n                            dy += snapRestrict.dy;\n                        }\n                    }\n\n                    if (dx || dy) {\n                        smoothEnd = true;\n                    }\n                }\n\n                if (inertia || smoothEnd) {\n                    copyCoords(inertiaStatus.upCoords, this.curCoords);\n\n                    this.pointers[0] = inertiaStatus.startEvent = startEvent =\n                        new InteractEvent(this, event, this.prepared.name, 'inertiastart', this.element);\n\n                    inertiaStatus.t0 = now;\n\n                    target.fire(inertiaStatus.startEvent);\n\n                    if (inertia) {\n                        inertiaStatus.vx0 = this.pointerDelta.client.vx;\n                        inertiaStatus.vy0 = this.pointerDelta.client.vy;\n                        inertiaStatus.v0 = pointerSpeed;\n\n                        this.calcInertia(inertiaStatus);\n\n                        var page = extend({}, this.curCoords.page),\n                            origin = getOriginXY(target, this.element),\n                            statusObject;\n\n                        page.x = page.x + inertiaStatus.xe - origin.x;\n                        page.y = page.y + inertiaStatus.ye - origin.y;\n\n                        statusObject = {\n                            useStatusXY: true,\n                            x: page.x,\n                            y: page.y,\n                            dx: 0,\n                            dy: 0,\n                            snap: null\n                        };\n\n                        statusObject.snap = statusObject;\n\n                        dx = dy = 0;\n\n                        if (endSnap) {\n                            var snap = this.setSnapping(this.curCoords.page, statusObject);\n\n                            if (snap.locked) {\n                                dx += snap.dx;\n                                dy += snap.dy;\n                            }\n                        }\n\n                        if (endRestrict) {\n                            var restrict = this.setRestriction(this.curCoords.page, statusObject);\n\n                            if (restrict.restricted) {\n                                dx += restrict.dx;\n                                dy += restrict.dy;\n                            }\n                        }\n\n                        inertiaStatus.modifiedXe += dx;\n                        inertiaStatus.modifiedYe += dy;\n\n                        inertiaStatus.i = reqFrame(this.boundInertiaFrame);\n                    }\n                    else {\n                        inertiaStatus.smoothEnd = true;\n                        inertiaStatus.xe = dx;\n                        inertiaStatus.ye = dy;\n\n                        inertiaStatus.sx = inertiaStatus.sy = 0;\n\n                        inertiaStatus.i = reqFrame(this.boundSmoothEndFrame);\n                    }\n\n                    inertiaStatus.active = true;\n                    return;\n                }\n\n                if (endSnap || endRestrict) {\n                    // fire a move event at the snapped coordinates\n                    this.pointerMove(pointer, event, eventTarget, curEventTarget, true);\n                }\n            }\n\n            if (this.dragging) {\n                endEvent = new InteractEvent(this, event, 'drag', 'end', this.element);\n\n                var draggableElement = this.element,\n                    drop = this.getDrop(endEvent, event, draggableElement);\n\n                this.dropTarget = drop.dropzone;\n                this.dropElement = drop.element;\n\n                var dropEvents = this.getDropEvents(event, endEvent);\n\n                if (dropEvents.leave) { this.prevDropTarget.fire(dropEvents.leave); }\n                if (dropEvents.enter) {     this.dropTarget.fire(dropEvents.enter); }\n                if (dropEvents.drop ) {     this.dropTarget.fire(dropEvents.drop ); }\n                if (dropEvents.deactivate) {\n                    this.fireActiveDrops(dropEvents.deactivate);\n                }\n\n                target.fire(endEvent);\n            }\n            else if (this.resizing) {\n                endEvent = new InteractEvent(this, event, 'resize', 'end', this.element);\n                target.fire(endEvent);\n            }\n            else if (this.gesturing) {\n                endEvent = new InteractEvent(this, event, 'gesture', 'end', this.element);\n                target.fire(endEvent);\n            }\n\n            this.stop(event);\n        },\n\n        collectDrops: function (element) {\n            var drops = [],\n                elements = [],\n                i;\n\n            element = element || this.element;\n\n            // collect all dropzones and their elements which qualify for a drop\n            for (i = 0; i < interactables.length; i++) {\n                if (!interactables[i].options.drop.enabled) { continue; }\n\n                var current = interactables[i],\n                    accept = current.options.drop.accept;\n\n                // test the draggable element against the dropzone's accept setting\n                if ((isElement(accept) && accept !== element)\n                    || (isString(accept)\n                        && !matchesSelector(element, accept))) {\n\n                    continue;\n                }\n\n                // query for new elements if necessary\n                var dropElements = current.selector? current._context.querySelectorAll(current.selector) : [current._element];\n\n                for (var j = 0, len = dropElements.length; j < len; j++) {\n                    var currentElement = dropElements[j];\n\n                    if (currentElement === element) {\n                        continue;\n                    }\n\n                    drops.push(current);\n                    elements.push(currentElement);\n                }\n            }\n\n            return {\n                dropzones: drops,\n                elements: elements\n            };\n        },\n\n        fireActiveDrops: function (event) {\n            var i,\n                current,\n                currentElement,\n                prevElement;\n\n            // loop through all active dropzones and trigger event\n            for (i = 0; i < this.activeDrops.dropzones.length; i++) {\n                current = this.activeDrops.dropzones[i];\n                currentElement = this.activeDrops.elements [i];\n\n                // prevent trigger of duplicate events on same element\n                if (currentElement !== prevElement) {\n                    // set current element as event target\n                    event.target = currentElement;\n                    current.fire(event);\n                }\n                prevElement = currentElement;\n            }\n        },\n\n        // Collect a new set of possible drops and save them in activeDrops.\n        // setActiveDrops should always be called when a drag has just started or a\n        // drag event happens while dynamicDrop is true\n        setActiveDrops: function (dragElement) {\n            // get dropzones and their elements that could receive the draggable\n            var possibleDrops = this.collectDrops(dragElement, true);\n\n            this.activeDrops.dropzones = possibleDrops.dropzones;\n            this.activeDrops.elements  = possibleDrops.elements;\n            this.activeDrops.rects     = [];\n\n            for (var i = 0; i < this.activeDrops.dropzones.length; i++) {\n                this.activeDrops.rects[i] = this.activeDrops.dropzones[i].getRect(this.activeDrops.elements[i]);\n            }\n        },\n\n        getDrop: function (dragEvent, event, dragElement) {\n            var validDrops = [];\n\n            if (dynamicDrop) {\n                this.setActiveDrops(dragElement);\n            }\n\n            // collect all dropzones and their elements which qualify for a drop\n            for (var j = 0; j < this.activeDrops.dropzones.length; j++) {\n                var current        = this.activeDrops.dropzones[j],\n                    currentElement = this.activeDrops.elements [j],\n                    rect           = this.activeDrops.rects    [j];\n\n                validDrops.push(current.dropCheck(dragEvent, event, this.target, dragElement, currentElement, rect)\n                                ? currentElement\n                                : null);\n            }\n\n            // get the most appropriate dropzone based on DOM depth and order\n            var dropIndex = indexOfDeepestElement(validDrops),\n                dropzone  = this.activeDrops.dropzones[dropIndex] || null,\n                element   = this.activeDrops.elements [dropIndex] || null;\n\n            return {\n                dropzone: dropzone,\n                element: element\n            };\n        },\n\n        getDropEvents: function (pointerEvent, dragEvent) {\n            var dropEvents = {\n                enter     : null,\n                leave     : null,\n                activate  : null,\n                deactivate: null,\n                move      : null,\n                drop      : null\n            };\n\n            if (this.dropElement !== this.prevDropElement) {\n                // if there was a prevDropTarget, create a dragleave event\n                if (this.prevDropTarget) {\n                    dropEvents.leave = {\n                        target       : this.prevDropElement,\n                        dropzone     : this.prevDropTarget,\n                        relatedTarget: dragEvent.target,\n                        draggable    : dragEvent.interactable,\n                        dragEvent    : dragEvent,\n                        interaction  : this,\n                        timeStamp    : dragEvent.timeStamp,\n                        type         : 'dragleave'\n                    };\n\n                    dragEvent.dragLeave = this.prevDropElement;\n                    dragEvent.prevDropzone = this.prevDropTarget;\n                }\n                // if the dropTarget is not null, create a dragenter event\n                if (this.dropTarget) {\n                    dropEvents.enter = {\n                        target       : this.dropElement,\n                        dropzone     : this.dropTarget,\n                        relatedTarget: dragEvent.target,\n                        draggable    : dragEvent.interactable,\n                        dragEvent    : dragEvent,\n                        interaction  : this,\n                        timeStamp    : dragEvent.timeStamp,\n                        type         : 'dragenter'\n                    };\n\n                    dragEvent.dragEnter = this.dropElement;\n                    dragEvent.dropzone = this.dropTarget;\n                }\n            }\n\n            if (dragEvent.type === 'dragend' && this.dropTarget) {\n                dropEvents.drop = {\n                    target       : this.dropElement,\n                    dropzone     : this.dropTarget,\n                    relatedTarget: dragEvent.target,\n                    draggable    : dragEvent.interactable,\n                    dragEvent    : dragEvent,\n                    interaction  : this,\n                    timeStamp    : dragEvent.timeStamp,\n                    type         : 'drop'\n                };\n\n                dragEvent.dropzone = this.dropTarget;\n            }\n            if (dragEvent.type === 'dragstart') {\n                dropEvents.activate = {\n                    target       : null,\n                    dropzone     : null,\n                    relatedTarget: dragEvent.target,\n                    draggable    : dragEvent.interactable,\n                    dragEvent    : dragEvent,\n                    interaction  : this,\n                    timeStamp    : dragEvent.timeStamp,\n                    type         : 'dropactivate'\n                };\n            }\n            if (dragEvent.type === 'dragend') {\n                dropEvents.deactivate = {\n                    target       : null,\n                    dropzone     : null,\n                    relatedTarget: dragEvent.target,\n                    draggable    : dragEvent.interactable,\n                    dragEvent    : dragEvent,\n                    interaction  : this,\n                    timeStamp    : dragEvent.timeStamp,\n                    type         : 'dropdeactivate'\n                };\n            }\n            if (dragEvent.type === 'dragmove' && this.dropTarget) {\n                dropEvents.move = {\n                    target       : this.dropElement,\n                    dropzone     : this.dropTarget,\n                    relatedTarget: dragEvent.target,\n                    draggable    : dragEvent.interactable,\n                    dragEvent    : dragEvent,\n                    interaction  : this,\n                    dragmove     : dragEvent,\n                    timeStamp    : dragEvent.timeStamp,\n                    type         : 'dropmove'\n                };\n                dragEvent.dropzone = this.dropTarget;\n            }\n\n            return dropEvents;\n        },\n\n        currentAction: function () {\n            return (this.dragging && 'drag') || (this.resizing && 'resize') || (this.gesturing && 'gesture') || null;\n        },\n\n        interacting: function () {\n            return this.dragging || this.resizing || this.gesturing;\n        },\n\n        clearTargets: function () {\n            this.target = this.element = null;\n\n            this.dropTarget = this.dropElement = this.prevDropTarget = this.prevDropElement = null;\n        },\n\n        stop: function (event) {\n            if (this.interacting()) {\n                autoScroll.stop();\n                this.matches = [];\n                this.matchElements = [];\n\n                var target = this.target;\n\n                if (target.options.styleCursor) {\n                    target._doc.documentElement.style.cursor = '';\n                }\n\n                // prevent Default only if were previously interacting\n                if (event && isFunction(event.preventDefault)) {\n                    this.checkAndPreventDefault(event, target, this.element);\n                }\n\n                if (this.dragging) {\n                    this.activeDrops.dropzones = this.activeDrops.elements = this.activeDrops.rects = null;\n                }\n            }\n\n            this.clearTargets();\n\n            this.pointerIsDown = this.snapStatus.locked = this.dragging = this.resizing = this.gesturing = false;\n            this.prepared.name = this.prevEvent = null;\n            this.inertiaStatus.resumeDx = this.inertiaStatus.resumeDy = 0;\n\n            // remove pointers if their ID isn't in this.pointerIds\n            for (var i = 0; i < this.pointers.length; i++) {\n                if (indexOf(this.pointerIds, getPointerId(this.pointers[i])) === -1) {\n                    this.pointers.splice(i, 1);\n                }\n            }\n        },\n\n        inertiaFrame: function () {\n            var inertiaStatus = this.inertiaStatus,\n                options = this.target.options[this.prepared.name].inertia,\n                lambda = options.resistance,\n                t = new Date().getTime() / 1000 - inertiaStatus.t0;\n\n            if (t < inertiaStatus.te) {\n\n                var progress =  1 - (Math.exp(-lambda * t) - inertiaStatus.lambda_v0) / inertiaStatus.one_ve_v0;\n\n                if (inertiaStatus.modifiedXe === inertiaStatus.xe && inertiaStatus.modifiedYe === inertiaStatus.ye) {\n                    inertiaStatus.sx = inertiaStatus.xe * progress;\n                    inertiaStatus.sy = inertiaStatus.ye * progress;\n                }\n                else {\n                    var quadPoint = getQuadraticCurvePoint(\n                            0, 0,\n                            inertiaStatus.xe, inertiaStatus.ye,\n                            inertiaStatus.modifiedXe, inertiaStatus.modifiedYe,\n                            progress);\n\n                    inertiaStatus.sx = quadPoint.x;\n                    inertiaStatus.sy = quadPoint.y;\n                }\n\n                this.pointerMove(inertiaStatus.startEvent, inertiaStatus.startEvent);\n\n                inertiaStatus.i = reqFrame(this.boundInertiaFrame);\n            }\n            else {\n                inertiaStatus.ending = true;\n\n                inertiaStatus.sx = inertiaStatus.modifiedXe;\n                inertiaStatus.sy = inertiaStatus.modifiedYe;\n\n                this.pointerMove(inertiaStatus.startEvent, inertiaStatus.startEvent);\n                this.pointerEnd(inertiaStatus.startEvent, inertiaStatus.startEvent);\n\n                inertiaStatus.active = inertiaStatus.ending = false;\n            }\n        },\n\n        smoothEndFrame: function () {\n            var inertiaStatus = this.inertiaStatus,\n                t = new Date().getTime() - inertiaStatus.t0,\n                duration = this.target.options[this.prepared.name].inertia.smoothEndDuration;\n\n            if (t < duration) {\n                inertiaStatus.sx = easeOutQuad(t, 0, inertiaStatus.xe, duration);\n                inertiaStatus.sy = easeOutQuad(t, 0, inertiaStatus.ye, duration);\n\n                this.pointerMove(inertiaStatus.startEvent, inertiaStatus.startEvent);\n\n                inertiaStatus.i = reqFrame(this.boundSmoothEndFrame);\n            }\n            else {\n                inertiaStatus.ending = true;\n\n                inertiaStatus.sx = inertiaStatus.xe;\n                inertiaStatus.sy = inertiaStatus.ye;\n\n                this.pointerMove(inertiaStatus.startEvent, inertiaStatus.startEvent);\n                this.pointerEnd(inertiaStatus.startEvent, inertiaStatus.startEvent);\n\n                inertiaStatus.smoothEnd =\n                  inertiaStatus.active = inertiaStatus.ending = false;\n            }\n        },\n\n        addPointer: function (pointer) {\n            var id = getPointerId(pointer),\n                index = this.mouse? 0 : indexOf(this.pointerIds, id);\n\n            if (index === -1) {\n                index = this.pointerIds.length;\n            }\n\n            this.pointerIds[index] = id;\n            this.pointers[index] = pointer;\n\n            return index;\n        },\n\n        removePointer: function (pointer) {\n            var id = getPointerId(pointer),\n                index = this.mouse? 0 : indexOf(this.pointerIds, id);\n\n            if (index === -1) { return; }\n\n            this.pointers   .splice(index, 1);\n            this.pointerIds .splice(index, 1);\n            this.downTargets.splice(index, 1);\n            this.downTimes  .splice(index, 1);\n            this.holdTimers .splice(index, 1);\n        },\n\n        recordPointer: function (pointer) {\n            var index = this.mouse? 0: indexOf(this.pointerIds, getPointerId(pointer));\n\n            if (index === -1) { return; }\n\n            this.pointers[index] = pointer;\n        },\n\n        collectEventTargets: function (pointer, event, eventTarget, eventType) {\n            var pointerIndex = this.mouse? 0 : indexOf(this.pointerIds, getPointerId(pointer));\n\n            // do not fire a tap event if the pointer was moved before being lifted\n            if (eventType === 'tap' && (this.pointerWasMoved\n                // or if the pointerup target is different to the pointerdown target\n                || !(this.downTargets[pointerIndex] && this.downTargets[pointerIndex] === eventTarget))) {\n                return;\n            }\n\n            var targets = [],\n                elements = [],\n                element = eventTarget;\n\n            function collectSelectors (interactable, selector, context) {\n                var els = ie8MatchesSelector\n                        ? context.querySelectorAll(selector)\n                        : undefined;\n\n                if (interactable._iEvents[eventType]\n                    && isElement(element)\n                    && inContext(interactable, element)\n                    && !testIgnore(interactable, element, eventTarget)\n                    && testAllow(interactable, element, eventTarget)\n                    && matchesSelector(element, selector, els)) {\n\n                    targets.push(interactable);\n                    elements.push(element);\n                }\n            }\n\n            while (element) {\n                if (interact.isSet(element) && interact(element)._iEvents[eventType]) {\n                    targets.push(interact(element));\n                    elements.push(element);\n                }\n\n                interactables.forEachSelector(collectSelectors);\n\n                element = parentElement(element);\n            }\n\n            // create the tap event even if there are no listeners so that\n            // doubletap can still be created and fired\n            if (targets.length || eventType === 'tap') {\n                this.firePointers(pointer, event, eventTarget, targets, elements, eventType);\n            }\n        },\n\n        firePointers: function (pointer, event, eventTarget, targets, elements, eventType) {\n            var pointerIndex = this.mouse? 0 : indexOf(this.pointerIds, getPointerId(pointer)),\n                pointerEvent = {},\n                i,\n                // for tap events\n                interval, createNewDoubleTap;\n\n            // if it's a doubletap then the event properties would have been\n            // copied from the tap event and provided as the pointer argument\n            if (eventType === 'doubletap') {\n                pointerEvent = pointer;\n            }\n            else {\n                pointerExtend(pointerEvent, event);\n                if (event !== pointer) {\n                    pointerExtend(pointerEvent, pointer);\n                }\n\n                pointerEvent.preventDefault           = preventOriginalDefault;\n                pointerEvent.stopPropagation          = InteractEvent.prototype.stopPropagation;\n                pointerEvent.stopImmediatePropagation = InteractEvent.prototype.stopImmediatePropagation;\n                pointerEvent.interaction              = this;\n\n                pointerEvent.timeStamp       = new Date().getTime();\n                pointerEvent.originalEvent   = event;\n                pointerEvent.originalPointer = pointer;\n                pointerEvent.type            = eventType;\n                pointerEvent.pointerId       = getPointerId(pointer);\n                pointerEvent.pointerType     = this.mouse? 'mouse' : !supportsPointerEvent? 'touch'\n                                                    : isString(pointer.pointerType)\n                                                        ? pointer.pointerType\n                                                        : [,,'touch', 'pen', 'mouse'][pointer.pointerType];\n            }\n\n            if (eventType === 'tap') {\n                pointerEvent.dt = pointerEvent.timeStamp - this.downTimes[pointerIndex];\n\n                interval = pointerEvent.timeStamp - this.tapTime;\n                createNewDoubleTap = !!(this.prevTap && this.prevTap.type !== 'doubletap'\n                       && this.prevTap.target === pointerEvent.target\n                       && interval < 500);\n\n                pointerEvent.double = createNewDoubleTap;\n\n                this.tapTime = pointerEvent.timeStamp;\n            }\n\n            for (i = 0; i < targets.length; i++) {\n                pointerEvent.currentTarget = elements[i];\n                pointerEvent.interactable = targets[i];\n                targets[i].fire(pointerEvent);\n\n                if (pointerEvent.immediatePropagationStopped\n                    ||(pointerEvent.propagationStopped && elements[i + 1] !== pointerEvent.currentTarget)) {\n                    break;\n                }\n            }\n\n            if (createNewDoubleTap) {\n                var doubleTap = {};\n\n                extend(doubleTap, pointerEvent);\n\n                doubleTap.dt   = interval;\n                doubleTap.type = 'doubletap';\n\n                this.collectEventTargets(doubleTap, event, eventTarget, 'doubletap');\n\n                this.prevTap = doubleTap;\n            }\n            else if (eventType === 'tap') {\n                this.prevTap = pointerEvent;\n            }\n        },\n\n        validateSelector: function (pointer, event, matches, matchElements) {\n            for (var i = 0, len = matches.length; i < len; i++) {\n                var match = matches[i],\n                    matchElement = matchElements[i],\n                    action = validateAction(match.getAction(pointer, event, this, matchElement), match);\n\n                if (action && withinInteractionLimit(match, matchElement, action)) {\n                    this.target = match;\n                    this.element = matchElement;\n\n                    return action;\n                }\n            }\n        },\n\n        setSnapping: function (pageCoords, status) {\n            var snap = this.target.options[this.prepared.name].snap,\n                targets = [],\n                target,\n                page,\n                i;\n\n            status = status || this.snapStatus;\n\n            if (status.useStatusXY) {\n                page = { x: status.x, y: status.y };\n            }\n            else {\n                var origin = getOriginXY(this.target, this.element);\n\n                page = extend({}, pageCoords);\n\n                page.x -= origin.x;\n                page.y -= origin.y;\n            }\n\n            status.realX = page.x;\n            status.realY = page.y;\n\n            page.x = page.x - this.inertiaStatus.resumeDx;\n            page.y = page.y - this.inertiaStatus.resumeDy;\n\n            var len = snap.targets? snap.targets.length : 0;\n\n            for (var relIndex = 0; relIndex < this.snapOffsets.length; relIndex++) {\n                var relative = {\n                    x: page.x - this.snapOffsets[relIndex].x,\n                    y: page.y - this.snapOffsets[relIndex].y\n                };\n\n                for (i = 0; i < len; i++) {\n                    if (isFunction(snap.targets[i])) {\n                        target = snap.targets[i](relative.x, relative.y, this);\n                    }\n                    else {\n                        target = snap.targets[i];\n                    }\n\n                    if (!target) { continue; }\n\n                    targets.push({\n                        x: isNumber(target.x) ? (target.x + this.snapOffsets[relIndex].x) : relative.x,\n                        y: isNumber(target.y) ? (target.y + this.snapOffsets[relIndex].y) : relative.y,\n\n                        range: isNumber(target.range)? target.range: snap.range\n                    });\n                }\n            }\n\n            var closest = {\n                    target: null,\n                    inRange: false,\n                    distance: 0,\n                    range: 0,\n                    dx: 0,\n                    dy: 0\n                };\n\n            for (i = 0, len = targets.length; i < len; i++) {\n                target = targets[i];\n\n                var range = target.range,\n                    dx = target.x - page.x,\n                    dy = target.y - page.y,\n                    distance = hypot(dx, dy),\n                    inRange = distance <= range;\n\n                // Infinite targets count as being out of range\n                // compared to non infinite ones that are in range\n                if (range === Infinity && closest.inRange && closest.range !== Infinity) {\n                    inRange = false;\n                }\n\n                if (!closest.target || (inRange\n                    // is the closest target in range?\n                    ? (closest.inRange && range !== Infinity\n                        // the pointer is relatively deeper in this target\n                        ? distance / range < closest.distance / closest.range\n                        // this target has Infinite range and the closest doesn't\n                        : (range === Infinity && closest.range !== Infinity)\n                            // OR this target is closer that the previous closest\n                            || distance < closest.distance)\n                    // The other is not in range and the pointer is closer to this target\n                    : (!closest.inRange && distance < closest.distance))) {\n\n                    if (range === Infinity) {\n                        inRange = true;\n                    }\n\n                    closest.target = target;\n                    closest.distance = distance;\n                    closest.range = range;\n                    closest.inRange = inRange;\n                    closest.dx = dx;\n                    closest.dy = dy;\n\n                    status.range = range;\n                }\n            }\n\n            var snapChanged;\n\n            if (closest.target) {\n                snapChanged = (status.snappedX !== closest.target.x || status.snappedY !== closest.target.y);\n\n                status.snappedX = closest.target.x;\n                status.snappedY = closest.target.y;\n            }\n            else {\n                snapChanged = true;\n\n                status.snappedX = NaN;\n                status.snappedY = NaN;\n            }\n\n            status.dx = closest.dx;\n            status.dy = closest.dy;\n\n            status.changed = (snapChanged || (closest.inRange && !status.locked));\n            status.locked = closest.inRange;\n\n            return status;\n        },\n\n        setRestriction: function (pageCoords, status) {\n            var target = this.target,\n                restrict = target && target.options[this.prepared.name].restrict,\n                restriction = restrict && restrict.restriction,\n                page;\n\n            if (!restriction) {\n                return status;\n            }\n\n            status = status || this.restrictStatus;\n\n            page = status.useStatusXY\n                    ? page = { x: status.x, y: status.y }\n                    : page = extend({}, pageCoords);\n\n            if (status.snap && status.snap.locked) {\n                page.x += status.snap.dx || 0;\n                page.y += status.snap.dy || 0;\n            }\n\n            page.x -= this.inertiaStatus.resumeDx;\n            page.y -= this.inertiaStatus.resumeDy;\n\n            status.dx = 0;\n            status.dy = 0;\n            status.restricted = false;\n\n            var rect, restrictedX, restrictedY;\n\n            if (isString(restriction)) {\n                if (restriction === 'parent') {\n                    restriction = parentElement(this.element);\n                }\n                else if (restriction === 'self') {\n                    restriction = target.getRect(this.element);\n                }\n                else {\n                    restriction = closest(this.element, restriction);\n                }\n\n                if (!restriction) { return status; }\n            }\n\n            if (isFunction(restriction)) {\n                restriction = restriction(page.x, page.y, this.element);\n            }\n\n            if (isElement(restriction)) {\n                restriction = getElementRect(restriction);\n            }\n\n            rect = restriction;\n\n            if (!restriction) {\n                restrictedX = page.x;\n                restrictedY = page.y;\n            }\n            // object is assumed to have\n            // x, y, width, height or\n            // left, top, right, bottom\n            else if ('x' in restriction && 'y' in restriction) {\n                restrictedX = Math.max(Math.min(rect.x + rect.width  - this.restrictOffset.right , page.x), rect.x + this.restrictOffset.left);\n                restrictedY = Math.max(Math.min(rect.y + rect.height - this.restrictOffset.bottom, page.y), rect.y + this.restrictOffset.top );\n            }\n            else {\n                restrictedX = Math.max(Math.min(rect.right  - this.restrictOffset.right , page.x), rect.left + this.restrictOffset.left);\n                restrictedY = Math.max(Math.min(rect.bottom - this.restrictOffset.bottom, page.y), rect.top  + this.restrictOffset.top );\n            }\n\n            status.dx = restrictedX - page.x;\n            status.dy = restrictedY - page.y;\n\n            status.changed = status.restrictedX !== restrictedX || status.restrictedY !== restrictedY;\n            status.restricted = !!(status.dx || status.dy);\n\n            status.restrictedX = restrictedX;\n            status.restrictedY = restrictedY;\n\n            return status;\n        },\n\n        checkAndPreventDefault: function (event, interactable, element) {\n            if (!(interactable = interactable || this.target)) { return; }\n\n            var options = interactable.options,\n                prevent = options.preventDefault;\n\n            if (prevent === 'auto' && element && !/^(input|select|textarea)$/i.test(event.target.nodeName)) {\n                // do not preventDefault on pointerdown if the prepared action is a drag\n                // and dragging can only start from a certain direction - this allows\n                // a touch to pan the viewport if a drag isn't in the right direction\n                if (/down|start/i.test(event.type)\n                    && this.prepared.name === 'drag' && options.drag.axis !== 'xy') {\n\n                    return;\n                }\n\n                // with manualStart, only preventDefault while interacting\n                if (options[this.prepared.name] && options[this.prepared.name].manualStart\n                    && !this.interacting()) {\n                    return;\n                }\n\n                event.preventDefault();\n                return;\n            }\n\n            if (prevent === 'always') {\n                event.preventDefault();\n                return;\n            }\n        },\n\n        calcInertia: function (status) {\n            var inertiaOptions = this.target.options[this.prepared.name].inertia,\n                lambda = inertiaOptions.resistance,\n                inertiaDur = -Math.log(inertiaOptions.endSpeed / status.v0) / lambda;\n\n            status.x0 = this.prevEvent.pageX;\n            status.y0 = this.prevEvent.pageY;\n            status.t0 = status.startEvent.timeStamp / 1000;\n            status.sx = status.sy = 0;\n\n            status.modifiedXe = status.xe = (status.vx0 - inertiaDur) / lambda;\n            status.modifiedYe = status.ye = (status.vy0 - inertiaDur) / lambda;\n            status.te = inertiaDur;\n\n            status.lambda_v0 = lambda / status.v0;\n            status.one_ve_v0 = 1 - inertiaOptions.endSpeed / status.v0;\n        },\n\n        autoScrollMove: function (pointer) {\n            if (!(this.interacting()\n                && checkAutoScroll(this.target, this.prepared.name))) {\n                return;\n            }\n\n            if (this.inertiaStatus.active) {\n                autoScroll.x = autoScroll.y = 0;\n                return;\n            }\n\n            var top,\n                right,\n                bottom,\n                left,\n                options = this.target.options[this.prepared.name].autoScroll,\n                container = options.container || getWindow(this.element);\n\n            if (isWindow(container)) {\n                left   = pointer.clientX < autoScroll.margin;\n                top    = pointer.clientY < autoScroll.margin;\n                right  = pointer.clientX > container.innerWidth  - autoScroll.margin;\n                bottom = pointer.clientY > container.innerHeight - autoScroll.margin;\n            }\n            else {\n                var rect = getElementClientRect(container);\n\n                left   = pointer.clientX < rect.left   + autoScroll.margin;\n                top    = pointer.clientY < rect.top    + autoScroll.margin;\n                right  = pointer.clientX > rect.right  - autoScroll.margin;\n                bottom = pointer.clientY > rect.bottom - autoScroll.margin;\n            }\n\n            autoScroll.x = (right ? 1: left? -1: 0);\n            autoScroll.y = (bottom? 1:  top? -1: 0);\n\n            if (!autoScroll.isScrolling) {\n                // set the autoScroll properties to those of the target\n                autoScroll.margin = options.margin;\n                autoScroll.speed  = options.speed;\n\n                autoScroll.start(this);\n            }\n        },\n\n        _updateEventTargets: function (target, currentTarget) {\n            this._eventTarget    = target;\n            this._curEventTarget = currentTarget;\n        }\n\n    };\n\n    function getInteractionFromPointer (pointer, eventType, eventTarget) {\n        var i = 0, len = interactions.length,\n            mouseEvent = (/mouse/i.test(pointer.pointerType || eventType)\n                          // MSPointerEvent.MSPOINTER_TYPE_MOUSE\n                          || pointer.pointerType === 4),\n            interaction;\n\n        var id = getPointerId(pointer);\n\n        // try to resume inertia with a new pointer\n        if (/down|start/i.test(eventType)) {\n            for (i = 0; i < len; i++) {\n                interaction = interactions[i];\n\n                var element = eventTarget;\n\n                if (interaction.inertiaStatus.active && interaction.target.options[interaction.prepared.name].inertia.allowResume\n                    && (interaction.mouse === mouseEvent)) {\n                    while (element) {\n                        // if the element is the interaction element\n                        if (element === interaction.element) {\n                            return interaction;\n                        }\n                        element = parentElement(element);\n                    }\n                }\n            }\n        }\n\n        // if it's a mouse interaction\n        if (mouseEvent || !(supportsTouch || supportsPointerEvent)) {\n\n            // find a mouse interaction that's not in inertia phase\n            for (i = 0; i < len; i++) {\n                if (interactions[i].mouse && !interactions[i].inertiaStatus.active) {\n                    return interactions[i];\n                }\n            }\n\n            // find any interaction specifically for mouse.\n            // if the eventType is a mousedown, and inertia is active\n            // ignore the interaction\n            for (i = 0; i < len; i++) {\n                if (interactions[i].mouse && !(/down/.test(eventType) && interactions[i].inertiaStatus.active)) {\n                    return interaction;\n                }\n            }\n\n            // create a new interaction for mouse\n            interaction = new Interaction();\n            interaction.mouse = true;\n\n            return interaction;\n        }\n\n        // get interaction that has this pointer\n        for (i = 0; i < len; i++) {\n            if (contains(interactions[i].pointerIds, id)) {\n                return interactions[i];\n            }\n        }\n\n        // at this stage, a pointerUp should not return an interaction\n        if (/up|end|out/i.test(eventType)) {\n            return null;\n        }\n\n        // get first idle interaction\n        for (i = 0; i < len; i++) {\n            interaction = interactions[i];\n\n            if ((!interaction.prepared.name || (interaction.target.options.gesture.enabled))\n                && !interaction.interacting()\n                && !(!mouseEvent && interaction.mouse)) {\n\n                return interaction;\n            }\n        }\n\n        return new Interaction();\n    }\n\n    function doOnInteractions (method) {\n        return (function (event) {\n            var interaction,\n                eventTarget = getActualElement(event.path\n                                               ? event.path[0]\n                                               : event.target),\n                curEventTarget = getActualElement(event.currentTarget),\n                i;\n\n            if (supportsTouch && /touch/.test(event.type)) {\n                prevTouchTime = new Date().getTime();\n\n                for (i = 0; i < event.changedTouches.length; i++) {\n                    var pointer = event.changedTouches[i];\n\n                    interaction = getInteractionFromPointer(pointer, event.type, eventTarget);\n\n                    if (!interaction) { continue; }\n\n                    interaction._updateEventTargets(eventTarget, curEventTarget);\n\n                    interaction[method](pointer, event, eventTarget, curEventTarget);\n                }\n            }\n            else {\n                if (!supportsPointerEvent && /mouse/.test(event.type)) {\n                    // ignore mouse events while touch interactions are active\n                    for (i = 0; i < interactions.length; i++) {\n                        if (!interactions[i].mouse && interactions[i].pointerIsDown) {\n                            return;\n                        }\n                    }\n\n                    // try to ignore mouse events that are simulated by the browser\n                    // after a touch event\n                    if (new Date().getTime() - prevTouchTime < 500) {\n                        return;\n                    }\n                }\n\n                interaction = getInteractionFromPointer(event, event.type, eventTarget);\n\n                if (!interaction) { return; }\n\n                interaction._updateEventTargets(eventTarget, curEventTarget);\n\n                interaction[method](event, event, eventTarget, curEventTarget);\n            }\n        });\n    }\n\n    function InteractEvent (interaction, event, action, phase, element, related) {\n        var client,\n            page,\n            target      = interaction.target,\n            snapStatus  = interaction.snapStatus,\n            restrictStatus  = interaction.restrictStatus,\n            pointers    = interaction.pointers,\n            deltaSource = (target && target.options || defaultOptions).deltaSource,\n            sourceX     = deltaSource + 'X',\n            sourceY     = deltaSource + 'Y',\n            options     = target? target.options: defaultOptions,\n            origin      = getOriginXY(target, element),\n            starting    = phase === 'start',\n            ending      = phase === 'end',\n            coords      = starting? interaction.startCoords : interaction.curCoords;\n\n        element = element || interaction.element;\n\n        page   = extend({}, coords.page);\n        client = extend({}, coords.client);\n\n        page.x -= origin.x;\n        page.y -= origin.y;\n\n        client.x -= origin.x;\n        client.y -= origin.y;\n\n        var relativePoints = options[action].snap && options[action].snap.relativePoints ;\n\n        if (checkSnap(target, action) && !(starting && relativePoints && relativePoints.length)) {\n            this.snap = {\n                range  : snapStatus.range,\n                locked : snapStatus.locked,\n                x      : snapStatus.snappedX,\n                y      : snapStatus.snappedY,\n                realX  : snapStatus.realX,\n                realY  : snapStatus.realY,\n                dx     : snapStatus.dx,\n                dy     : snapStatus.dy\n            };\n\n            if (snapStatus.locked) {\n                page.x += snapStatus.dx;\n                page.y += snapStatus.dy;\n                client.x += snapStatus.dx;\n                client.y += snapStatus.dy;\n            }\n        }\n\n        if (checkRestrict(target, action) && !(starting && options[action].restrict.elementRect) && restrictStatus.restricted) {\n            page.x += restrictStatus.dx;\n            page.y += restrictStatus.dy;\n            client.x += restrictStatus.dx;\n            client.y += restrictStatus.dy;\n\n            this.restrict = {\n                dx: restrictStatus.dx,\n                dy: restrictStatus.dy\n            };\n        }\n\n        this.pageX     = page.x;\n        this.pageY     = page.y;\n        this.clientX   = client.x;\n        this.clientY   = client.y;\n\n        this.x0        = interaction.startCoords.page.x - origin.x;\n        this.y0        = interaction.startCoords.page.y - origin.y;\n        this.clientX0  = interaction.startCoords.client.x - origin.x;\n        this.clientY0  = interaction.startCoords.client.y - origin.y;\n        this.ctrlKey   = event.ctrlKey;\n        this.altKey    = event.altKey;\n        this.shiftKey  = event.shiftKey;\n        this.metaKey   = event.metaKey;\n        this.button    = event.button;\n        this.buttons   = event.buttons;\n        this.target    = element;\n        this.t0        = interaction.downTimes[0];\n        this.type      = action + (phase || '');\n\n        this.interaction = interaction;\n        this.interactable = target;\n\n        var inertiaStatus = interaction.inertiaStatus;\n\n        if (inertiaStatus.active) {\n            this.detail = 'inertia';\n        }\n\n        if (related) {\n            this.relatedTarget = related;\n        }\n\n        // end event dx, dy is difference between start and end points\n        if (ending) {\n            if (deltaSource === 'client') {\n                this.dx = client.x - interaction.startCoords.client.x;\n                this.dy = client.y - interaction.startCoords.client.y;\n            }\n            else {\n                this.dx = page.x - interaction.startCoords.page.x;\n                this.dy = page.y - interaction.startCoords.page.y;\n            }\n        }\n        else if (starting) {\n            this.dx = 0;\n            this.dy = 0;\n        }\n        // copy properties from previousmove if starting inertia\n        else if (phase === 'inertiastart') {\n            this.dx = interaction.prevEvent.dx;\n            this.dy = interaction.prevEvent.dy;\n        }\n        else {\n            if (deltaSource === 'client') {\n                this.dx = client.x - interaction.prevEvent.clientX;\n                this.dy = client.y - interaction.prevEvent.clientY;\n            }\n            else {\n                this.dx = page.x - interaction.prevEvent.pageX;\n                this.dy = page.y - interaction.prevEvent.pageY;\n            }\n        }\n        if (interaction.prevEvent && interaction.prevEvent.detail === 'inertia'\n            && !inertiaStatus.active\n            && options[action].inertia && options[action].inertia.zeroResumeDelta) {\n\n            inertiaStatus.resumeDx += this.dx;\n            inertiaStatus.resumeDy += this.dy;\n\n            this.dx = this.dy = 0;\n        }\n\n        if (action === 'resize' && interaction.resizeAxes) {\n            if (options.resize.square) {\n                if (interaction.resizeAxes === 'y') {\n                    this.dx = this.dy;\n                }\n                else {\n                    this.dy = this.dx;\n                }\n                this.axes = 'xy';\n            }\n            else {\n                this.axes = interaction.resizeAxes;\n\n                if (interaction.resizeAxes === 'x') {\n                    this.dy = 0;\n                }\n                else if (interaction.resizeAxes === 'y') {\n                    this.dx = 0;\n                }\n            }\n        }\n        else if (action === 'gesture') {\n            this.touches = [pointers[0], pointers[1]];\n\n            if (starting) {\n                this.distance = touchDistance(pointers, deltaSource);\n                this.box      = touchBBox(pointers);\n                this.scale    = 1;\n                this.ds       = 0;\n                this.angle    = touchAngle(pointers, undefined, deltaSource);\n                this.da       = 0;\n            }\n            else if (ending || event instanceof InteractEvent) {\n                this.distance = interaction.prevEvent.distance;\n                this.box      = interaction.prevEvent.box;\n                this.scale    = interaction.prevEvent.scale;\n                this.ds       = this.scale - 1;\n                this.angle    = interaction.prevEvent.angle;\n                this.da       = this.angle - interaction.gesture.startAngle;\n            }\n            else {\n                this.distance = touchDistance(pointers, deltaSource);\n                this.box      = touchBBox(pointers);\n                this.scale    = this.distance / interaction.gesture.startDistance;\n                this.angle    = touchAngle(pointers, interaction.gesture.prevAngle, deltaSource);\n\n                this.ds = this.scale - interaction.gesture.prevScale;\n                this.da = this.angle - interaction.gesture.prevAngle;\n            }\n        }\n\n        if (starting) {\n            this.timeStamp = interaction.downTimes[0];\n            this.dt        = 0;\n            this.duration  = 0;\n            this.speed     = 0;\n            this.velocityX = 0;\n            this.velocityY = 0;\n        }\n        else if (phase === 'inertiastart') {\n            this.timeStamp = interaction.prevEvent.timeStamp;\n            this.dt        = interaction.prevEvent.dt;\n            this.duration  = interaction.prevEvent.duration;\n            this.speed     = interaction.prevEvent.speed;\n            this.velocityX = interaction.prevEvent.velocityX;\n            this.velocityY = interaction.prevEvent.velocityY;\n        }\n        else {\n            this.timeStamp = new Date().getTime();\n            this.dt        = this.timeStamp - interaction.prevEvent.timeStamp;\n            this.duration  = this.timeStamp - interaction.downTimes[0];\n\n            if (event instanceof InteractEvent) {\n                var dx = this[sourceX] - interaction.prevEvent[sourceX],\n                    dy = this[sourceY] - interaction.prevEvent[sourceY],\n                    dt = this.dt / 1000;\n\n                this.speed = hypot(dx, dy) / dt;\n                this.velocityX = dx / dt;\n                this.velocityY = dy / dt;\n            }\n            // if normal move or end event, use previous user event coords\n            else {\n                // speed and velocity in pixels per second\n                this.speed = interaction.pointerDelta[deltaSource].speed;\n                this.velocityX = interaction.pointerDelta[deltaSource].vx;\n                this.velocityY = interaction.pointerDelta[deltaSource].vy;\n            }\n        }\n\n        if ((ending || phase === 'inertiastart')\n            && interaction.prevEvent.speed > 600 && this.timeStamp - interaction.prevEvent.timeStamp < 150) {\n\n            var angle = 180 * Math.atan2(interaction.prevEvent.velocityY, interaction.prevEvent.velocityX) / Math.PI,\n                overlap = 22.5;\n\n            if (angle < 0) {\n                angle += 360;\n            }\n\n            var left = 135 - overlap <= angle && angle < 225 + overlap,\n                up   = 225 - overlap <= angle && angle < 315 + overlap,\n\n                right = !left && (315 - overlap <= angle || angle <  45 + overlap),\n                down  = !up   &&   45 - overlap <= angle && angle < 135 + overlap;\n\n            this.swipe = {\n                up   : up,\n                down : down,\n                left : left,\n                right: right,\n                angle: angle,\n                speed: interaction.prevEvent.speed,\n                velocity: {\n                    x: interaction.prevEvent.velocityX,\n                    y: interaction.prevEvent.velocityY\n                }\n            };\n        }\n    }\n\n    InteractEvent.prototype = {\n        preventDefault: blank,\n        stopImmediatePropagation: function () {\n            this.immediatePropagationStopped = this.propagationStopped = true;\n        },\n        stopPropagation: function () {\n            this.propagationStopped = true;\n        }\n    };\n\n    function preventOriginalDefault () {\n        this.originalEvent.preventDefault();\n    }\n\n    function getActionCursor (action) {\n        var cursor = '';\n\n        if (action.name === 'drag') {\n            cursor =  actionCursors.drag;\n        }\n        if (action.name === 'resize') {\n            if (action.axis) {\n                cursor =  actionCursors[action.name + action.axis];\n            }\n            else if (action.edges) {\n                var cursorKey = 'resize',\n                    edgeNames = ['top', 'bottom', 'left', 'right'];\n\n                for (var i = 0; i < 4; i++) {\n                    if (action.edges[edgeNames[i]]) {\n                        cursorKey += edgeNames[i];\n                    }\n                }\n\n                cursor = actionCursors[cursorKey];\n            }\n        }\n\n        return cursor;\n    }\n\n    function checkResizeEdge (name, value, page, element, interactableElement, rect, margin) {\n        // false, '', undefined, null\n        if (!value) { return false; }\n\n        // true value, use pointer coords and element rect\n        if (value === true) {\n            // if dimensions are negative, \"switch\" edges\n            var width = isNumber(rect.width)? rect.width : rect.right - rect.left,\n                height = isNumber(rect.height)? rect.height : rect.bottom - rect.top;\n\n            if (width < 0) {\n                if      (name === 'left' ) { name = 'right'; }\n                else if (name === 'right') { name = 'left' ; }\n            }\n            if (height < 0) {\n                if      (name === 'top'   ) { name = 'bottom'; }\n                else if (name === 'bottom') { name = 'top'   ; }\n            }\n\n            if (name === 'left'  ) { return page.x < ((width  >= 0? rect.left: rect.right ) + margin); }\n            if (name === 'top'   ) { return page.y < ((height >= 0? rect.top : rect.bottom) + margin); }\n\n            if (name === 'right' ) { return page.x > ((width  >= 0? rect.right : rect.left) - margin); }\n            if (name === 'bottom') { return page.y > ((height >= 0? rect.bottom: rect.top ) - margin); }\n        }\n\n        // the remaining checks require an element\n        if (!isElement(element)) { return false; }\n\n        return isElement(value)\n                    // the value is an element to use as a resize handle\n                    ? value === element\n                    // otherwise check if element matches value as selector\n                    : matchesUpTo(element, value, interactableElement);\n    }\n\n    function defaultActionChecker (pointer, interaction, element) {\n        var rect = this.getRect(element),\n            shouldResize = false,\n            action = null,\n            resizeAxes = null,\n            resizeEdges,\n            page = extend({}, interaction.curCoords.page),\n            options = this.options;\n\n        if (!rect) { return null; }\n\n        if (actionIsEnabled.resize && options.resize.enabled) {\n            var resizeOptions = options.resize;\n\n            resizeEdges = {\n                left: false, right: false, top: false, bottom: false\n            };\n\n            // if using resize.edges\n            if (isObject(resizeOptions.edges)) {\n                for (var edge in resizeEdges) {\n                    resizeEdges[edge] = checkResizeEdge(edge,\n                                                        resizeOptions.edges[edge],\n                                                        page,\n                                                        interaction._eventTarget,\n                                                        element,\n                                                        rect,\n                                                        resizeOptions.margin || margin);\n                }\n\n                resizeEdges.left = resizeEdges.left && !resizeEdges.right;\n                resizeEdges.top  = resizeEdges.top  && !resizeEdges.bottom;\n\n                shouldResize = resizeEdges.left || resizeEdges.right || resizeEdges.top || resizeEdges.bottom;\n            }\n            else {\n                var right  = options.resize.axis !== 'y' && page.x > (rect.right  - margin),\n                    bottom = options.resize.axis !== 'x' && page.y > (rect.bottom - margin);\n\n                shouldResize = right || bottom;\n                resizeAxes = (right? 'x' : '') + (bottom? 'y' : '');\n            }\n        }\n\n        action = shouldResize\n            ? 'resize'\n            : actionIsEnabled.drag && options.drag.enabled\n                ? 'drag'\n                : null;\n\n        if (actionIsEnabled.gesture\n            && interaction.pointerIds.length >=2\n            && !(interaction.dragging || interaction.resizing)) {\n            action = 'gesture';\n        }\n\n        if (action) {\n            return {\n                name: action,\n                axis: resizeAxes,\n                edges: resizeEdges\n            };\n        }\n\n        return null;\n    }\n\n    // Check if action is enabled globally and the current target supports it\n    // If so, return the validated action. Otherwise, return null\n    function validateAction (action, interactable) {\n        if (!isObject(action)) { return null; }\n\n        var actionName = action.name,\n            options = interactable.options;\n\n        if ((  (actionName  === 'resize'   && options.resize.enabled )\n            || (actionName      === 'drag'     && options.drag.enabled  )\n            || (actionName      === 'gesture'  && options.gesture.enabled))\n            && actionIsEnabled[actionName]) {\n\n            if (actionName === 'resize' || actionName === 'resizeyx') {\n                actionName = 'resizexy';\n            }\n\n            return action;\n        }\n        return null;\n    }\n\n    var listeners = {},\n        interactionListeners = [\n            'dragStart', 'dragMove', 'resizeStart', 'resizeMove', 'gestureStart', 'gestureMove',\n            'pointerOver', 'pointerOut', 'pointerHover', 'selectorDown',\n            'pointerDown', 'pointerMove', 'pointerUp', 'pointerCancel', 'pointerEnd',\n            'addPointer', 'removePointer', 'recordPointer', 'autoScrollMove'\n        ];\n\n    for (var i = 0, len = interactionListeners.length; i < len; i++) {\n        var name = interactionListeners[i];\n\n        listeners[name] = doOnInteractions(name);\n    }\n\n    // bound to the interactable context when a DOM event\n    // listener is added to a selector interactable\n    function delegateListener (event, useCapture) {\n        var fakeEvent = {},\n            delegated = delegatedEvents[event.type],\n            eventTarget = getActualElement(event.path\n                                           ? event.path[0]\n                                           : event.target),\n            element = eventTarget;\n\n        useCapture = useCapture? true: false;\n\n        // duplicate the event so that currentTarget can be changed\n        for (var prop in event) {\n            fakeEvent[prop] = event[prop];\n        }\n\n        fakeEvent.originalEvent = event;\n        fakeEvent.preventDefault = preventOriginalDefault;\n\n        // climb up document tree looking for selector matches\n        while (isElement(element)) {\n            for (var i = 0; i < delegated.selectors.length; i++) {\n                var selector = delegated.selectors[i],\n                    context = delegated.contexts[i];\n\n                if (matchesSelector(element, selector)\n                    && nodeContains(context, eventTarget)\n                    && nodeContains(context, element)) {\n\n                    var listeners = delegated.listeners[i];\n\n                    fakeEvent.currentTarget = element;\n\n                    for (var j = 0; j < listeners.length; j++) {\n                        if (listeners[j][1] === useCapture) {\n                            listeners[j][0](fakeEvent);\n                        }\n                    }\n                }\n            }\n\n            element = parentElement(element);\n        }\n    }\n\n    function delegateUseCapture (event) {\n        return delegateListener.call(this, event, true);\n    }\n\n    interactables.indexOfElement = function indexOfElement (element, context) {\n        context = context || document;\n\n        for (var i = 0; i < this.length; i++) {\n            var interactable = this[i];\n\n            if ((interactable.selector === element\n                && (interactable._context === context))\n                || (!interactable.selector && interactable._element === element)) {\n\n                return i;\n            }\n        }\n        return -1;\n    };\n\n    interactables.get = function interactableGet (element, options) {\n        return this[this.indexOfElement(element, options && options.context)];\n    };\n\n    interactables.forEachSelector = function (callback) {\n        for (var i = 0; i < this.length; i++) {\n            var interactable = this[i];\n\n            if (!interactable.selector) {\n                continue;\n            }\n\n            var ret = callback(interactable, interactable.selector, interactable._context, i, this);\n\n            if (ret !== undefined) {\n                return ret;\n            }\n        }\n    };\n\n    /*\\\n     * interact\n     [ method ]\n     *\n     * The methods of this variable can be used to set elements as\n     * interactables and also to change various default settings.\n     *\n     * Calling it as a function and passing an element or a valid CSS selector\n     * string returns an Interactable object which has various methods to\n     * configure it.\n     *\n     - element (Element | string) The HTML or SVG Element to interact with or CSS selector\n     = (object) An @Interactable\n     *\n     > Usage\n     | interact(document.getElementById('draggable')).draggable(true);\n     |\n     | var rectables = interact('rect');\n     | rectables\n     |     .gesturable(true)\n     |     .on('gesturemove', function (event) {\n     |         // something cool...\n     |     })\n     |     .autoScroll(true);\n    \\*/\n    function interact (element, options) {\n        return interactables.get(element, options) || new Interactable(element, options);\n    }\n\n    /*\\\n     * Interactable\n     [ property ]\n     **\n     * Object type returned by @interact\n    \\*/\n    function Interactable (element, options) {\n        this._element = element;\n        this._iEvents = this._iEvents || {};\n\n        var _window;\n\n        if (trySelector(element)) {\n            this.selector = element;\n\n            var context = options && options.context;\n\n            _window = context? getWindow(context) : window;\n\n            if (context && (_window.Node\n                    ? context instanceof _window.Node\n                    : (isElement(context) || context === _window.document))) {\n\n                this._context = context;\n            }\n        }\n        else {\n            _window = getWindow(element);\n\n            if (isElement(element, _window)) {\n\n                if (supportsPointerEvent) {\n                    events.add(this._element, pEventTypes.down, listeners.pointerDown );\n                    events.add(this._element, pEventTypes.move, listeners.pointerHover);\n                }\n                else {\n                    events.add(this._element, 'mousedown' , listeners.pointerDown );\n                    events.add(this._element, 'mousemove' , listeners.pointerHover);\n                    events.add(this._element, 'touchstart', listeners.pointerDown );\n                    events.add(this._element, 'touchmove' , listeners.pointerHover);\n                }\n            }\n        }\n\n        this._doc = _window.document;\n\n        if (!contains(documents, this._doc)) {\n            listenToDocument(this._doc);\n        }\n\n        interactables.push(this);\n\n        this.set(options);\n    }\n\n    Interactable.prototype = {\n        setOnEvents: function (action, phases) {\n            if (action === 'drop') {\n                if (isFunction(phases.ondrop)          ) { this.ondrop           = phases.ondrop          ; }\n                if (isFunction(phases.ondropactivate)  ) { this.ondropactivate   = phases.ondropactivate  ; }\n                if (isFunction(phases.ondropdeactivate)) { this.ondropdeactivate = phases.ondropdeactivate; }\n                if (isFunction(phases.ondragenter)     ) { this.ondragenter      = phases.ondragenter     ; }\n                if (isFunction(phases.ondragleave)     ) { this.ondragleave      = phases.ondragleave     ; }\n                if (isFunction(phases.ondropmove)      ) { this.ondropmove       = phases.ondropmove      ; }\n            }\n            else {\n                action = 'on' + action;\n\n                if (isFunction(phases.onstart)       ) { this[action + 'start'         ] = phases.onstart         ; }\n                if (isFunction(phases.onmove)        ) { this[action + 'move'          ] = phases.onmove          ; }\n                if (isFunction(phases.onend)         ) { this[action + 'end'           ] = phases.onend           ; }\n                if (isFunction(phases.oninertiastart)) { this[action + 'inertiastart'  ] = phases.oninertiastart  ; }\n            }\n\n            return this;\n        },\n\n        /*\\\n         * Interactable.draggable\n         [ method ]\n         *\n         * Gets or sets whether drag actions can be performed on the\n         * Interactable\n         *\n         = (boolean) Indicates if this can be the target of drag events\n         | var isDraggable = interact('ul li').draggable();\n         * or\n         - options (boolean | object) #optional true/false or An object with event listeners to be fired on drag events (object makes the Interactable draggable)\n         = (object) This Interactable\n         | interact(element).draggable({\n         |     onstart: function (event) {},\n         |     onmove : function (event) {},\n         |     onend  : function (event) {},\n         |\n         |     // the axis in which the first movement must be\n         |     // for the drag sequence to start\n         |     // 'xy' by default - any direction\n         |     axis: 'x' || 'y' || 'xy',\n         |\n         |     // max number of drags that can happen concurrently\n         |     // with elements of this Interactable. Infinity by default\n         |     max: Infinity,\n         |\n         |     // max number of drags that can target the same element+Interactable\n         |     // 1 by default\n         |     maxPerElement: 2\n         | });\n        \\*/\n        draggable: function (options) {\n            if (isObject(options)) {\n                this.options.drag.enabled = options.enabled === false? false: true;\n                this.setPerAction('drag', options);\n                this.setOnEvents('drag', options);\n\n                if (/^x$|^y$|^xy$/.test(options.axis)) {\n                    this.options.drag.axis = options.axis;\n                }\n                else if (options.axis === null) {\n                    delete this.options.drag.axis;\n                }\n\n                return this;\n            }\n\n            if (isBool(options)) {\n                this.options.drag.enabled = options;\n\n                return this;\n            }\n\n            return this.options.drag;\n        },\n\n        setPerAction: function (action, options) {\n            // for all the default per-action options\n            for (var option in options) {\n                // if this option exists for this action\n                if (option in defaultOptions[action]) {\n                    // if the option in the options arg is an object value\n                    if (isObject(options[option])) {\n                        // duplicate the object\n                        this.options[action][option] = extend(this.options[action][option] || {}, options[option]);\n\n                        if (isObject(defaultOptions.perAction[option]) && 'enabled' in defaultOptions.perAction[option]) {\n                            this.options[action][option].enabled = options[option].enabled === false? false : true;\n                        }\n                    }\n                    else if (isBool(options[option]) && isObject(defaultOptions.perAction[option])) {\n                        this.options[action][option].enabled = options[option];\n                    }\n                    else if (options[option] !== undefined) {\n                        // or if it's not undefined, do a plain assignment\n                        this.options[action][option] = options[option];\n                    }\n                }\n            }\n        },\n\n        /*\\\n         * Interactable.dropzone\n         [ method ]\n         *\n         * Returns or sets whether elements can be dropped onto this\n         * Interactable to trigger drop events\n         *\n         * Dropzones can receive the following events:\n         *  - `dropactivate` and `dropdeactivate` when an acceptable drag starts and ends\n         *  - `dragenter` and `dragleave` when a draggable enters and leaves the dropzone\n         *  - `dragmove` when a draggable that has entered the dropzone is moved\n         *  - `drop` when a draggable is dropped into this dropzone\n         *\n         *  Use the `accept` option to allow only elements that match the given CSS selector or element.\n         *\n         *  Use the `overlap` option to set how drops are checked for. The allowed values are:\n         *   - `'pointer'`, the pointer must be over the dropzone (default)\n         *   - `'center'`, the draggable element's center must be over the dropzone\n         *   - a number from 0-1 which is the `(intersection area) / (draggable area)`.\n         *       e.g. `0.5` for drop to happen when half of the area of the\n         *       draggable is over the dropzone\n         *\n         - options (boolean | object | null) #optional The new value to be set.\n         | interact('.drop').dropzone({\n         |   accept: '.can-drop' || document.getElementById('single-drop'),\n         |   overlap: 'pointer' || 'center' || zeroToOne\n         | }\n         = (boolean | object) The current setting or this Interactable\n        \\*/\n        dropzone: function (options) {\n            if (isObject(options)) {\n                this.options.drop.enabled = options.enabled === false? false: true;\n                this.setOnEvents('drop', options);\n\n                if (/^(pointer|center)$/.test(options.overlap)) {\n                    this.options.drop.overlap = options.overlap;\n                }\n                else if (isNumber(options.overlap)) {\n                    this.options.drop.overlap = Math.max(Math.min(1, options.overlap), 0);\n                }\n                if ('accept' in options) {\n                  this.options.drop.accept = options.accept;\n                }\n                if ('checker' in options) {\n                  this.options.drop.checker = options.checker;\n                }\n\n                return this;\n            }\n\n            if (isBool(options)) {\n                this.options.drop.enabled = options;\n\n                return this;\n            }\n\n            return this.options.drop;\n        },\n\n        dropCheck: function (dragEvent, event, draggable, draggableElement, dropElement, rect) {\n            var dropped = false;\n\n            // if the dropzone has no rect (eg. display: none)\n            // call the custom dropChecker or just return false\n            if (!(rect = rect || this.getRect(dropElement))) {\n                return (this.options.drop.checker\n                    ? this.options.drop.checker(dragEvent, event, dropped, this, dropElement, draggable, draggableElement)\n                    : false);\n            }\n\n            var dropOverlap = this.options.drop.overlap;\n\n            if (dropOverlap === 'pointer') {\n                var page = getPageXY(dragEvent),\n                    origin = getOriginXY(draggable, draggableElement),\n                    horizontal,\n                    vertical;\n\n                page.x += origin.x;\n                page.y += origin.y;\n\n                horizontal = (page.x > rect.left) && (page.x < rect.right);\n                vertical   = (page.y > rect.top ) && (page.y < rect.bottom);\n\n                dropped = horizontal && vertical;\n            }\n\n            var dragRect = draggable.getRect(draggableElement);\n\n            if (dropOverlap === 'center') {\n                var cx = dragRect.left + dragRect.width  / 2,\n                    cy = dragRect.top  + dragRect.height / 2;\n\n                dropped = cx >= rect.left && cx <= rect.right && cy >= rect.top && cy <= rect.bottom;\n            }\n\n            if (isNumber(dropOverlap)) {\n                var overlapArea  = (Math.max(0, Math.min(rect.right , dragRect.right ) - Math.max(rect.left, dragRect.left))\n                                  * Math.max(0, Math.min(rect.bottom, dragRect.bottom) - Math.max(rect.top , dragRect.top ))),\n                    overlapRatio = overlapArea / (dragRect.width * dragRect.height);\n\n                dropped = overlapRatio >= dropOverlap;\n            }\n\n            if (this.options.drop.checker) {\n                dropped = this.options.drop.checker(dragEvent, event, dropped, this, dropElement, draggable, draggableElement);\n            }\n\n            return dropped;\n        },\n\n        /*\\\n         * Interactable.dropChecker\n         [ method ]\n         *\n         * DEPRECATED. Use interactable.dropzone({ checker: function... }) instead.\n         *\n         * Gets or sets the function used to check if a dragged element is\n         * over this Interactable.\n         *\n         - checker (function) #optional The function that will be called when checking for a drop\n         = (Function | Interactable) The checker function or this Interactable\n         *\n         * The checker function takes the following arguments:\n         *\n         - dragEvent (InteractEvent) The related dragmove or dragend event\n         - event (TouchEvent | PointerEvent | MouseEvent) The user move/up/end Event related to the dragEvent\n         - dropped (boolean) The value from the default drop checker\n         - dropzone (Interactable) The dropzone interactable\n         - dropElement (Element) The dropzone element\n         - draggable (Interactable) The Interactable being dragged\n         - draggableElement (Element) The actual element that's being dragged\n         *\n         > Usage:\n         | interact(target)\n         | .dropChecker(function(dragEvent,         // related dragmove or dragend event\n         |                       event,             // TouchEvent/PointerEvent/MouseEvent\n         |                       dropped,           // bool result of the default checker\n         |                       dropzone,          // dropzone Interactable\n         |                       dropElement,       // dropzone elemnt\n         |                       draggable,         // draggable Interactable\n         |                       draggableElement) {// draggable element\n         |\n         |   return dropped && event.target.hasAttribute('allow-drop');\n         | }\n        \\*/\n        dropChecker: function (checker) {\n            if (isFunction(checker)) {\n                this.options.drop.checker = checker;\n\n                return this;\n            }\n            if (checker === null) {\n                delete this.options.getRect;\n\n                return this;\n            }\n\n            return this.options.drop.checker;\n        },\n\n        /*\\\n         * Interactable.accept\n         [ method ]\n         *\n         * Deprecated. add an `accept` property to the options object passed to\n         * @Interactable.dropzone instead.\n         *\n         * Gets or sets the Element or CSS selector match that this\n         * Interactable accepts if it is a dropzone.\n         *\n         - newValue (Element | string | null) #optional\n         * If it is an Element, then only that element can be dropped into this dropzone.\n         * If it is a string, the element being dragged must match it as a selector.\n         * If it is null, the accept options is cleared - it accepts any element.\n         *\n         = (string | Element | null | Interactable) The current accept option if given `undefined` or this Interactable\n        \\*/\n        accept: function (newValue) {\n            if (isElement(newValue)) {\n                this.options.drop.accept = newValue;\n\n                return this;\n            }\n\n            // test if it is a valid CSS selector\n            if (trySelector(newValue)) {\n                this.options.drop.accept = newValue;\n\n                return this;\n            }\n\n            if (newValue === null) {\n                delete this.options.drop.accept;\n\n                return this;\n            }\n\n            return this.options.drop.accept;\n        },\n\n        /*\\\n         * Interactable.resizable\n         [ method ]\n         *\n         * Gets or sets whether resize actions can be performed on the\n         * Interactable\n         *\n         = (boolean) Indicates if this can be the target of resize elements\n         | var isResizeable = interact('input[type=text]').resizable();\n         * or\n         - options (boolean | object) #optional true/false or An object with event listeners to be fired on resize events (object makes the Interactable resizable)\n         = (object) This Interactable\n         | interact(element).resizable({\n         |     onstart: function (event) {},\n         |     onmove : function (event) {},\n         |     onend  : function (event) {},\n         |\n         |     edges: {\n         |       top   : true,       // Use pointer coords to check for resize.\n         |       left  : false,      // Disable resizing from left edge.\n         |       bottom: '.resize-s',// Resize if pointer target matches selector\n         |       right : handleEl    // Resize if pointer target is the given Element\n         |     },\n         |\n         |     // Width and height can be adjusted independently. When `true`, width and\n         |     // height are adjusted at a 1:1 ratio.\n         |     square: false,\n         |\n         |     // Width and height can be adjusted independently. When `true`, width and\n         |     // height maintain the aspect ratio they had when resizing started.\n         |     preserveAspectRatio: false,\n         |\n         |     // a value of 'none' will limit the resize rect to a minimum of 0x0\n         |     // 'negate' will allow the rect to have negative width/height\n         |     // 'reposition' will keep the width/height positive by swapping\n         |     // the top and bottom edges and/or swapping the left and right edges\n         |     invert: 'none' || 'negate' || 'reposition'\n         |\n         |     // limit multiple resizes.\n         |     // See the explanation in the @Interactable.draggable example\n         |     max: Infinity,\n         |     maxPerElement: 1,\n         | });\n        \\*/\n        resizable: function (options) {\n            if (isObject(options)) {\n                this.options.resize.enabled = options.enabled === false? false: true;\n                this.setPerAction('resize', options);\n                this.setOnEvents('resize', options);\n\n                if (/^x$|^y$|^xy$/.test(options.axis)) {\n                    this.options.resize.axis = options.axis;\n                }\n                else if (options.axis === null) {\n                    this.options.resize.axis = defaultOptions.resize.axis;\n                }\n\n                if (isBool(options.preserveAspectRatio)) {\n                    this.options.resize.preserveAspectRatio = options.preserveAspectRatio;\n                }\n                else if (isBool(options.square)) {\n                    this.options.resize.square = options.square;\n                }\n\n                return this;\n            }\n            if (isBool(options)) {\n                this.options.resize.enabled = options;\n\n                return this;\n            }\n            return this.options.resize;\n        },\n\n        /*\\\n         * Interactable.squareResize\n         [ method ]\n         *\n         * Deprecated. Add a `square: true || false` property to @Interactable.resizable instead\n         *\n         * Gets or sets whether resizing is forced 1:1 aspect\n         *\n         = (boolean) Current setting\n         *\n         * or\n         *\n         - newValue (boolean) #optional\n         = (object) this Interactable\n        \\*/\n        squareResize: function (newValue) {\n            if (isBool(newValue)) {\n                this.options.resize.square = newValue;\n\n                return this;\n            }\n\n            if (newValue === null) {\n                delete this.options.resize.square;\n\n                return this;\n            }\n\n            return this.options.resize.square;\n        },\n\n        /*\\\n         * Interactable.gesturable\n         [ method ]\n         *\n         * Gets or sets whether multitouch gestures can be performed on the\n         * Interactable's element\n         *\n         = (boolean) Indicates if this can be the target of gesture events\n         | var isGestureable = interact(element).gesturable();\n         * or\n         - options (boolean | object) #optional true/false or An object with event listeners to be fired on gesture events (makes the Interactable gesturable)\n         = (object) this Interactable\n         | interact(element).gesturable({\n         |     onstart: function (event) {},\n         |     onmove : function (event) {},\n         |     onend  : function (event) {},\n         |\n         |     // limit multiple gestures.\n         |     // See the explanation in @Interactable.draggable example\n         |     max: Infinity,\n         |     maxPerElement: 1,\n         | });\n        \\*/\n        gesturable: function (options) {\n            if (isObject(options)) {\n                this.options.gesture.enabled = options.enabled === false? false: true;\n                this.setPerAction('gesture', options);\n                this.setOnEvents('gesture', options);\n\n                return this;\n            }\n\n            if (isBool(options)) {\n                this.options.gesture.enabled = options;\n\n                return this;\n            }\n\n            return this.options.gesture;\n        },\n\n        /*\\\n         * Interactable.autoScroll\n         [ method ]\n         **\n         * Deprecated. Add an `autoscroll` property to the options object\n         * passed to @Interactable.draggable or @Interactable.resizable instead.\n         *\n         * Returns or sets whether dragging and resizing near the edges of the\n         * window/container trigger autoScroll for this Interactable\n         *\n         = (object) Object with autoScroll properties\n         *\n         * or\n         *\n         - options (object | boolean) #optional\n         * options can be:\n         * - an object with margin, distance and interval properties,\n         * - true or false to enable or disable autoScroll or\n         = (Interactable) this Interactable\n        \\*/\n        autoScroll: function (options) {\n            if (isObject(options)) {\n                options = extend({ actions: ['drag', 'resize']}, options);\n            }\n            else if (isBool(options)) {\n                options = { actions: ['drag', 'resize'], enabled: options };\n            }\n\n            return this.setOptions('autoScroll', options);\n        },\n\n        /*\\\n         * Interactable.snap\n         [ method ]\n         **\n         * Deprecated. Add a `snap` property to the options object passed\n         * to @Interactable.draggable or @Interactable.resizable instead.\n         *\n         * Returns or sets if and how action coordinates are snapped. By\n         * default, snapping is relative to the pointer coordinates. You can\n         * change this by setting the\n         * [`elementOrigin`](https://github.com/taye/interact.js/pull/72).\n         **\n         = (boolean | object) `false` if snap is disabled; object with snap properties if snap is enabled\n         **\n         * or\n         **\n         - options (object | boolean | null) #optional\n         = (Interactable) this Interactable\n         > Usage\n         | interact(document.querySelector('#thing')).snap({\n         |     targets: [\n         |         // snap to this specific point\n         |         {\n         |             x: 100,\n         |             y: 100,\n         |             range: 25\n         |         },\n         |         // give this function the x and y page coords and snap to the object returned\n         |         function (x, y) {\n         |             return {\n         |                 x: x,\n         |                 y: (75 + 50 * Math.sin(x * 0.04)),\n         |                 range: 40\n         |             };\n         |         },\n         |         // create a function that snaps to a grid\n         |         interact.createSnapGrid({\n         |             x: 50,\n         |             y: 50,\n         |             range: 10,              // optional\n         |             offset: { x: 5, y: 10 } // optional\n         |         })\n         |     ],\n         |     // do not snap during normal movement.\n         |     // Instead, trigger only one snapped move event\n         |     // immediately before the end event.\n         |     endOnly: true,\n         |\n         |     relativePoints: [\n         |         { x: 0, y: 0 },  // snap relative to the top left of the element\n         |         { x: 1, y: 1 },  // and also to the bottom right\n         |     ],  \n         |\n         |     // offset the snap target coordinates\n         |     // can be an object with x/y or 'startCoords'\n         |     offset: { x: 50, y: 50 }\n         |   }\n         | });\n        \\*/\n        snap: function (options) {\n            var ret = this.setOptions('snap', options);\n\n            if (ret === this) { return this; }\n\n            return ret.drag;\n        },\n\n        setOptions: function (option, options) {\n            var actions = options && isArray(options.actions)\n                    ? options.actions\n                    : ['drag'];\n\n            var i;\n\n            if (isObject(options) || isBool(options)) {\n                for (i = 0; i < actions.length; i++) {\n                    var action = /resize/.test(actions[i])? 'resize' : actions[i];\n\n                    if (!isObject(this.options[action])) { continue; }\n\n                    var thisOption = this.options[action][option];\n\n                    if (isObject(options)) {\n                        extend(thisOption, options);\n                        thisOption.enabled = options.enabled === false? false: true;\n\n                        if (option === 'snap') {\n                            if (thisOption.mode === 'grid') {\n                                thisOption.targets = [\n                                    interact.createSnapGrid(extend({\n                                        offset: thisOption.gridOffset || { x: 0, y: 0 }\n                                    }, thisOption.grid || {}))\n                                ];\n                            }\n                            else if (thisOption.mode === 'anchor') {\n                                thisOption.targets = thisOption.anchors;\n                            }\n                            else if (thisOption.mode === 'path') {\n                                thisOption.targets = thisOption.paths;\n                            }\n\n                            if ('elementOrigin' in options) {\n                                thisOption.relativePoints = [options.elementOrigin];\n                            }\n                        }\n                    }\n                    else if (isBool(options)) {\n                        thisOption.enabled = options;\n                    }\n                }\n\n                return this;\n            }\n\n            var ret = {},\n                allActions = ['drag', 'resize', 'gesture'];\n\n            for (i = 0; i < allActions.length; i++) {\n                if (option in defaultOptions[allActions[i]]) {\n                    ret[allActions[i]] = this.options[allActions[i]][option];\n                }\n            }\n\n            return ret;\n        },\n\n\n        /*\\\n         * Interactable.inertia\n         [ method ]\n         **\n         * Deprecated. Add an `inertia` property to the options object passed\n         * to @Interactable.draggable or @Interactable.resizable instead.\n         *\n         * Returns or sets if and how events continue to run after the pointer is released\n         **\n         = (boolean | object) `false` if inertia is disabled; `object` with inertia properties if inertia is enabled\n         **\n         * or\n         **\n         - options (object | boolean | null) #optional\n         = (Interactable) this Interactable\n         > Usage\n         | // enable and use default settings\n         | interact(element).inertia(true);\n         |\n         | // enable and use custom settings\n         | interact(element).inertia({\n         |     // value greater than 0\n         |     // high values slow the object down more quickly\n         |     resistance     : 16,\n         |\n         |     // the minimum launch speed (pixels per second) that results in inertia start\n         |     minSpeed       : 200,\n         |\n         |     // inertia will stop when the object slows down to this speed\n         |     endSpeed       : 20,\n         |\n         |     // boolean; should actions be resumed when the pointer goes down during inertia\n         |     allowResume    : true,\n         |\n         |     // boolean; should the jump when resuming from inertia be ignored in event.dx/dy\n         |     zeroResumeDelta: false,\n         |\n         |     // if snap/restrict are set to be endOnly and inertia is enabled, releasing\n         |     // the pointer without triggering inertia will animate from the release\n         |     // point to the snaped/restricted point in the given amount of time (ms)\n         |     smoothEndDuration: 300,\n         |\n         |     // an array of action types that can have inertia (no gesture)\n         |     actions        : ['drag', 'resize']\n         | });\n         |\n         | // reset custom settings and use all defaults\n         | interact(element).inertia(null);\n        \\*/\n        inertia: function (options) {\n            var ret = this.setOptions('inertia', options);\n\n            if (ret === this) { return this; }\n\n            return ret.drag;\n        },\n\n        getAction: function (pointer, event, interaction, element) {\n            var action = this.defaultActionChecker(pointer, interaction, element);\n\n            if (this.options.actionChecker) {\n                return this.options.actionChecker(pointer, event, action, this, element, interaction);\n            }\n\n            return action;\n        },\n\n        defaultActionChecker: defaultActionChecker,\n\n        /*\\\n         * Interactable.actionChecker\n         [ method ]\n         *\n         * Gets or sets the function used to check action to be performed on\n         * pointerDown\n         *\n         - checker (function | null) #optional A function which takes a pointer event, defaultAction string, interactable, element and interaction as parameters and returns an object with name property 'drag' 'resize' or 'gesture' and optionally an `edges` object with boolean 'top', 'left', 'bottom' and right props.\n         = (Function | Interactable) The checker function or this Interactable\n         *\n         | interact('.resize-drag')\n         |   .resizable(true)\n         |   .draggable(true)\n         |   .actionChecker(function (pointer, event, action, interactable, element, interaction) {\n         |\n         |   if (interact.matchesSelector(event.target, '.drag-handle') {\n         |     // force drag with handle target\n         |     action.name = drag;\n         |   }\n         |   else {\n         |     // resize from the top and right edges\n         |     action.name  = 'resize';\n         |     action.edges = { top: true, right: true };\n         |   }\n         |\n         |   return action;\n         | });\n        \\*/\n        actionChecker: function (checker) {\n            if (isFunction(checker)) {\n                this.options.actionChecker = checker;\n\n                return this;\n            }\n\n            if (checker === null) {\n                delete this.options.actionChecker;\n\n                return this;\n            }\n\n            return this.options.actionChecker;\n        },\n\n        /*\\\n         * Interactable.getRect\n         [ method ]\n         *\n         * The default function to get an Interactables bounding rect. Can be\n         * overridden using @Interactable.rectChecker.\n         *\n         - element (Element) #optional The element to measure.\n         = (object) The object's bounding rectangle.\n         o {\n         o     top   : 0,\n         o     left  : 0,\n         o     bottom: 0,\n         o     right : 0,\n         o     width : 0,\n         o     height: 0\n         o }\n        \\*/\n        getRect: function rectCheck (element) {\n            element = element || this._element;\n\n            if (this.selector && !(isElement(element))) {\n                element = this._context.querySelector(this.selector);\n            }\n\n            return getElementRect(element);\n        },\n\n        /*\\\n         * Interactable.rectChecker\n         [ method ]\n         *\n         * Returns or sets the function used to calculate the interactable's\n         * element's rectangle\n         *\n         - checker (function) #optional A function which returns this Interactable's bounding rectangle. See @Interactable.getRect\n         = (function | object) The checker function or this Interactable\n        \\*/\n        rectChecker: function (checker) {\n            if (isFunction(checker)) {\n                this.getRect = checker;\n\n                return this;\n            }\n\n            if (checker === null) {\n                delete this.options.getRect;\n\n                return this;\n            }\n\n            return this.getRect;\n        },\n\n        /*\\\n         * Interactable.styleCursor\n         [ method ]\n         *\n         * Returns or sets whether the action that would be performed when the\n         * mouse on the element are checked on `mousemove` so that the cursor\n         * may be styled appropriately\n         *\n         - newValue (boolean) #optional\n         = (boolean | Interactable) The current setting or this Interactable\n        \\*/\n        styleCursor: function (newValue) {\n            if (isBool(newValue)) {\n                this.options.styleCursor = newValue;\n\n                return this;\n            }\n\n            if (newValue === null) {\n                delete this.options.styleCursor;\n\n                return this;\n            }\n\n            return this.options.styleCursor;\n        },\n\n        /*\\\n         * Interactable.preventDefault\n         [ method ]\n         *\n         * Returns or sets whether to prevent the browser's default behaviour\n         * in response to pointer events. Can be set to:\n         *  - `'always'` to always prevent\n         *  - `'never'` to never prevent\n         *  - `'auto'` to let interact.js try to determine what would be best\n         *\n         - newValue (string) #optional `true`, `false` or `'auto'`\n         = (string | Interactable) The current setting or this Interactable\n        \\*/\n        preventDefault: function (newValue) {\n            if (/^(always|never|auto)$/.test(newValue)) {\n                this.options.preventDefault = newValue;\n                return this;\n            }\n\n            if (isBool(newValue)) {\n                this.options.preventDefault = newValue? 'always' : 'never';\n                return this;\n            }\n\n            return this.options.preventDefault;\n        },\n\n        /*\\\n         * Interactable.origin\n         [ method ]\n         *\n         * Gets or sets the origin of the Interactable's element.  The x and y\n         * of the origin will be subtracted from action event coordinates.\n         *\n         - origin (object | string) #optional An object eg. { x: 0, y: 0 } or string 'parent', 'self' or any CSS selector\n         * OR\n         - origin (Element) #optional An HTML or SVG Element whose rect will be used\n         **\n         = (object) The current origin or this Interactable\n        \\*/\n        origin: function (newValue) {\n            if (trySelector(newValue)) {\n                this.options.origin = newValue;\n                return this;\n            }\n            else if (isObject(newValue)) {\n                this.options.origin = newValue;\n                return this;\n            }\n\n            return this.options.origin;\n        },\n\n        /*\\\n         * Interactable.deltaSource\n         [ method ]\n         *\n         * Returns or sets the mouse coordinate types used to calculate the\n         * movement of the pointer.\n         *\n         - newValue (string) #optional Use 'client' if you will be scrolling while interacting; Use 'page' if you want autoScroll to work\n         = (string | object) The current deltaSource or this Interactable\n        \\*/\n        deltaSource: function (newValue) {\n            if (newValue === 'page' || newValue === 'client') {\n                this.options.deltaSource = newValue;\n\n                return this;\n            }\n\n            return this.options.deltaSource;\n        },\n\n        /*\\\n         * Interactable.restrict\n         [ method ]\n         **\n         * Deprecated. Add a `restrict` property to the options object passed to\n         * @Interactable.draggable, @Interactable.resizable or @Interactable.gesturable instead.\n         *\n         * Returns or sets the rectangles within which actions on this\n         * interactable (after snap calculations) are restricted. By default,\n         * restricting is relative to the pointer coordinates. You can change\n         * this by setting the\n         * [`elementRect`](https://github.com/taye/interact.js/pull/72).\n         **\n         - options (object) #optional an object with keys drag, resize, and/or gesture whose values are rects, Elements, CSS selectors, or 'parent' or 'self'\n         = (object) The current restrictions object or this Interactable\n         **\n         | interact(element).restrict({\n         |     // the rect will be `interact.getElementRect(element.parentNode)`\n         |     drag: element.parentNode,\n         |\n         |     // x and y are relative to the the interactable's origin\n         |     resize: { x: 100, y: 100, width: 200, height: 200 }\n         | })\n         |\n         | interact('.draggable').restrict({\n         |     // the rect will be the selected element's parent\n         |     drag: 'parent',\n         |\n         |     // do not restrict during normal movement.\n         |     // Instead, trigger only one restricted move event\n         |     // immediately before the end event.\n         |     endOnly: true,\n         |\n         |     // https://github.com/taye/interact.js/pull/72#issue-41813493\n         |     elementRect: { top: 0, left: 0, bottom: 1, right: 1 }\n         | });\n        \\*/\n        restrict: function (options) {\n            if (!isObject(options)) {\n                return this.setOptions('restrict', options);\n            }\n\n            var actions = ['drag', 'resize', 'gesture'],\n                ret;\n\n            for (var i = 0; i < actions.length; i++) {\n                var action = actions[i];\n\n                if (action in options) {\n                    var perAction = extend({\n                            actions: [action],\n                            restriction: options[action]\n                        }, options);\n\n                    ret = this.setOptions('restrict', perAction);\n                }\n            }\n\n            return ret;\n        },\n\n        /*\\\n         * Interactable.context\n         [ method ]\n         *\n         * Gets the selector context Node of the Interactable. The default is `window.document`.\n         *\n         = (Node) The context Node of this Interactable\n         **\n        \\*/\n        context: function () {\n            return this._context;\n        },\n\n        _context: document,\n\n        /*\\\n         * Interactable.ignoreFrom\n         [ method ]\n         *\n         * If the target of the `mousedown`, `pointerdown` or `touchstart`\n         * event or any of it's parents match the given CSS selector or\n         * Element, no drag/resize/gesture is started.\n         *\n         - newValue (string | Element | null) #optional a CSS selector string, an Element or `null` to not ignore any elements\n         = (string | Element | object) The current ignoreFrom value or this Interactable\n         **\n         | interact(element, { ignoreFrom: document.getElementById('no-action') });\n         | // or\n         | interact(element).ignoreFrom('input, textarea, a');\n        \\*/\n        ignoreFrom: function (newValue) {\n            if (trySelector(newValue)) {            // CSS selector to match event.target\n                this.options.ignoreFrom = newValue;\n                return this;\n            }\n\n            if (isElement(newValue)) {              // specific element\n                this.options.ignoreFrom = newValue;\n                return this;\n            }\n\n            return this.options.ignoreFrom;\n        },\n\n        /*\\\n         * Interactable.allowFrom\n         [ method ]\n         *\n         * A drag/resize/gesture is started only If the target of the\n         * `mousedown`, `pointerdown` or `touchstart` event or any of it's\n         * parents match the given CSS selector or Element.\n         *\n         - newValue (string | Element | null) #optional a CSS selector string, an Element or `null` to allow from any element\n         = (string | Element | object) The current allowFrom value or this Interactable\n         **\n         | interact(element, { allowFrom: document.getElementById('drag-handle') });\n         | // or\n         | interact(element).allowFrom('.handle');\n        \\*/\n        allowFrom: function (newValue) {\n            if (trySelector(newValue)) {            // CSS selector to match event.target\n                this.options.allowFrom = newValue;\n                return this;\n            }\n\n            if (isElement(newValue)) {              // specific element\n                this.options.allowFrom = newValue;\n                return this;\n            }\n\n            return this.options.allowFrom;\n        },\n\n        /*\\\n         * Interactable.element\n         [ method ]\n         *\n         * If this is not a selector Interactable, it returns the element this\n         * interactable represents\n         *\n         = (Element) HTML / SVG Element\n        \\*/\n        element: function () {\n            return this._element;\n        },\n\n        /*\\\n         * Interactable.fire\n         [ method ]\n         *\n         * Calls listeners for the given InteractEvent type bound globally\n         * and directly to this Interactable\n         *\n         - iEvent (InteractEvent) The InteractEvent object to be fired on this Interactable\n         = (Interactable) this Interactable\n        \\*/\n        fire: function (iEvent) {\n            if (!(iEvent && iEvent.type) || !contains(eventTypes, iEvent.type)) {\n                return this;\n            }\n\n            var listeners,\n                i,\n                len,\n                onEvent = 'on' + iEvent.type,\n                funcName = '';\n\n            // Interactable#on() listeners\n            if (iEvent.type in this._iEvents) {\n                listeners = this._iEvents[iEvent.type];\n\n                for (i = 0, len = listeners.length; i < len && !iEvent.immediatePropagationStopped; i++) {\n                    funcName = listeners[i].name;\n                    listeners[i](iEvent);\n                }\n            }\n\n            // interactable.onevent listener\n            if (isFunction(this[onEvent])) {\n                funcName = this[onEvent].name;\n                this[onEvent](iEvent);\n            }\n\n            // interact.on() listeners\n            if (iEvent.type in globalEvents && (listeners = globalEvents[iEvent.type]))  {\n\n                for (i = 0, len = listeners.length; i < len && !iEvent.immediatePropagationStopped; i++) {\n                    funcName = listeners[i].name;\n                    listeners[i](iEvent);\n                }\n            }\n\n            return this;\n        },\n\n        /*\\\n         * Interactable.on\n         [ method ]\n         *\n         * Binds a listener for an InteractEvent or DOM event.\n         *\n         - eventType  (string | array | object) The types of events to listen for\n         - listener   (function) The function to be called on the given event(s)\n         - useCapture (boolean) #optional useCapture flag for addEventListener\n         = (object) This Interactable\n        \\*/\n        on: function (eventType, listener, useCapture) {\n            var i;\n\n            if (isString(eventType) && eventType.search(' ') !== -1) {\n                eventType = eventType.trim().split(/ +/);\n            }\n\n            if (isArray(eventType)) {\n                for (i = 0; i < eventType.length; i++) {\n                    this.on(eventType[i], listener, useCapture);\n                }\n\n                return this;\n            }\n\n            if (isObject(eventType)) {\n                for (var prop in eventType) {\n                    this.on(prop, eventType[prop], listener);\n                }\n\n                return this;\n            }\n\n            if (eventType === 'wheel') {\n                eventType = wheelEvent;\n            }\n\n            // convert to boolean\n            useCapture = useCapture? true: false;\n\n            if (contains(eventTypes, eventType)) {\n                // if this type of event was never bound to this Interactable\n                if (!(eventType in this._iEvents)) {\n                    this._iEvents[eventType] = [listener];\n                }\n                else {\n                    this._iEvents[eventType].push(listener);\n                }\n            }\n            // delegated event for selector\n            else if (this.selector) {\n                if (!delegatedEvents[eventType]) {\n                    delegatedEvents[eventType] = {\n                        selectors: [],\n                        contexts : [],\n                        listeners: []\n                    };\n\n                    // add delegate listener functions\n                    for (i = 0; i < documents.length; i++) {\n                        events.add(documents[i], eventType, delegateListener);\n                        events.add(documents[i], eventType, delegateUseCapture, true);\n                    }\n                }\n\n                var delegated = delegatedEvents[eventType],\n                    index;\n\n                for (index = delegated.selectors.length - 1; index >= 0; index--) {\n                    if (delegated.selectors[index] === this.selector\n                        && delegated.contexts[index] === this._context) {\n                        break;\n                    }\n                }\n\n                if (index === -1) {\n                    index = delegated.selectors.length;\n\n                    delegated.selectors.push(this.selector);\n                    delegated.contexts .push(this._context);\n                    delegated.listeners.push([]);\n                }\n\n                // keep listener and useCapture flag\n                delegated.listeners[index].push([listener, useCapture]);\n            }\n            else {\n                events.add(this._element, eventType, listener, useCapture);\n            }\n\n            return this;\n        },\n\n        /*\\\n         * Interactable.off\n         [ method ]\n         *\n         * Removes an InteractEvent or DOM event listener\n         *\n         - eventType  (string | array | object) The types of events that were listened for\n         - listener   (function) The listener function to be removed\n         - useCapture (boolean) #optional useCapture flag for removeEventListener\n         = (object) This Interactable\n        \\*/\n        off: function (eventType, listener, useCapture) {\n            var i;\n\n            if (isString(eventType) && eventType.search(' ') !== -1) {\n                eventType = eventType.trim().split(/ +/);\n            }\n\n            if (isArray(eventType)) {\n                for (i = 0; i < eventType.length; i++) {\n                    this.off(eventType[i], listener, useCapture);\n                }\n\n                return this;\n            }\n\n            if (isObject(eventType)) {\n                for (var prop in eventType) {\n                    this.off(prop, eventType[prop], listener);\n                }\n\n                return this;\n            }\n\n            var eventList,\n                index = -1;\n\n            // convert to boolean\n            useCapture = useCapture? true: false;\n\n            if (eventType === 'wheel') {\n                eventType = wheelEvent;\n            }\n\n            // if it is an action event type\n            if (contains(eventTypes, eventType)) {\n                eventList = this._iEvents[eventType];\n\n                if (eventList && (index = indexOf(eventList, listener)) !== -1) {\n                    this._iEvents[eventType].splice(index, 1);\n                }\n            }\n            // delegated event\n            else if (this.selector) {\n                var delegated = delegatedEvents[eventType],\n                    matchFound = false;\n\n                if (!delegated) { return this; }\n\n                // count from last index of delegated to 0\n                for (index = delegated.selectors.length - 1; index >= 0; index--) {\n                    // look for matching selector and context Node\n                    if (delegated.selectors[index] === this.selector\n                        && delegated.contexts[index] === this._context) {\n\n                        var listeners = delegated.listeners[index];\n\n                        // each item of the listeners array is an array: [function, useCaptureFlag]\n                        for (i = listeners.length - 1; i >= 0; i--) {\n                            var fn = listeners[i][0],\n                                useCap = listeners[i][1];\n\n                            // check if the listener functions and useCapture flags match\n                            if (fn === listener && useCap === useCapture) {\n                                // remove the listener from the array of listeners\n                                listeners.splice(i, 1);\n\n                                // if all listeners for this interactable have been removed\n                                // remove the interactable from the delegated arrays\n                                if (!listeners.length) {\n                                    delegated.selectors.splice(index, 1);\n                                    delegated.contexts .splice(index, 1);\n                                    delegated.listeners.splice(index, 1);\n\n                                    // remove delegate function from context\n                                    events.remove(this._context, eventType, delegateListener);\n                                    events.remove(this._context, eventType, delegateUseCapture, true);\n\n                                    // remove the arrays if they are empty\n                                    if (!delegated.selectors.length) {\n                                        delegatedEvents[eventType] = null;\n                                    }\n                                }\n\n                                // only remove one listener\n                                matchFound = true;\n                                break;\n                            }\n                        }\n\n                        if (matchFound) { break; }\n                    }\n                }\n            }\n            // remove listener from this Interatable's element\n            else {\n                events.remove(this._element, eventType, listener, useCapture);\n            }\n\n            return this;\n        },\n\n        /*\\\n         * Interactable.set\n         [ method ]\n         *\n         * Reset the options of this Interactable\n         - options (object) The new settings to apply\n         = (object) This Interactable\n        \\*/\n        set: function (options) {\n            if (!isObject(options)) {\n                options = {};\n            }\n\n            this.options = extend({}, defaultOptions.base);\n\n            var i,\n                actions = ['drag', 'drop', 'resize', 'gesture'],\n                methods = ['draggable', 'dropzone', 'resizable', 'gesturable'],\n                perActions = extend(extend({}, defaultOptions.perAction), options[action] || {});\n\n            for (i = 0; i < actions.length; i++) {\n                var action = actions[i];\n\n                this.options[action] = extend({}, defaultOptions[action]);\n\n                this.setPerAction(action, perActions);\n\n                this[methods[i]](options[action]);\n            }\n\n            var settings = [\n                    'accept', 'actionChecker', 'allowFrom', 'deltaSource',\n                    'dropChecker', 'ignoreFrom', 'origin', 'preventDefault',\n                    'rectChecker', 'styleCursor'\n                ];\n\n            for (i = 0, len = settings.length; i < len; i++) {\n                var setting = settings[i];\n\n                this.options[setting] = defaultOptions.base[setting];\n\n                if (setting in options) {\n                    this[setting](options[setting]);\n                }\n            }\n\n            return this;\n        },\n\n        /*\\\n         * Interactable.unset\n         [ method ]\n         *\n         * Remove this interactable from the list of interactables and remove\n         * it's drag, drop, resize and gesture capabilities\n         *\n         = (object) @interact\n        \\*/\n        unset: function () {\n            events.remove(this._element, 'all');\n\n            if (!isString(this.selector)) {\n                events.remove(this, 'all');\n                if (this.options.styleCursor) {\n                    this._element.style.cursor = '';\n                }\n            }\n            else {\n                // remove delegated events\n                for (var type in delegatedEvents) {\n                    var delegated = delegatedEvents[type];\n\n                    for (var i = 0; i < delegated.selectors.length; i++) {\n                        if (delegated.selectors[i] === this.selector\n                            && delegated.contexts[i] === this._context) {\n\n                            delegated.selectors.splice(i, 1);\n                            delegated.contexts .splice(i, 1);\n                            delegated.listeners.splice(i, 1);\n\n                            // remove the arrays if they are empty\n                            if (!delegated.selectors.length) {\n                                delegatedEvents[type] = null;\n                            }\n                        }\n\n                        events.remove(this._context, type, delegateListener);\n                        events.remove(this._context, type, delegateUseCapture, true);\n\n                        break;\n                    }\n                }\n            }\n\n            this.dropzone(false);\n\n            interactables.splice(indexOf(interactables, this), 1);\n\n            return interact;\n        }\n    };\n\n    function warnOnce (method, message) {\n        var warned = false;\n\n        return function () {\n            if (!warned) {\n                window.console.warn(message);\n                warned = true;\n            }\n\n            return method.apply(this, arguments);\n        };\n    }\n\n    Interactable.prototype.snap = warnOnce(Interactable.prototype.snap,\n         'Interactable#snap is deprecated. See the new documentation for snapping at http://interactjs.io/docs/snapping');\n    Interactable.prototype.restrict = warnOnce(Interactable.prototype.restrict,\n         'Interactable#restrict is deprecated. See the new documentation for resticting at http://interactjs.io/docs/restriction');\n    Interactable.prototype.inertia = warnOnce(Interactable.prototype.inertia,\n         'Interactable#inertia is deprecated. See the new documentation for inertia at http://interactjs.io/docs/inertia');\n    Interactable.prototype.autoScroll = warnOnce(Interactable.prototype.autoScroll,\n         'Interactable#autoScroll is deprecated. See the new documentation for autoScroll at http://interactjs.io/docs/#autoscroll');\n    Interactable.prototype.squareResize = warnOnce(Interactable.prototype.squareResize,\n         'Interactable#squareResize is deprecated. See http://interactjs.io/docs/#resize-square');\n\n    Interactable.prototype.accept = warnOnce(Interactable.prototype.accept,\n         'Interactable#accept is deprecated. use Interactable#dropzone({ accept: target }) instead');\n    Interactable.prototype.dropChecker = warnOnce(Interactable.prototype.dropChecker,\n         'Interactable#dropChecker is deprecated. use Interactable#dropzone({ dropChecker: checkerFunction }) instead');\n    Interactable.prototype.context = warnOnce(Interactable.prototype.context,\n         'Interactable#context as a method is deprecated. It will soon be a DOM Node instead');\n\n    /*\\\n     * interact.isSet\n     [ method ]\n     *\n     * Check if an element has been set\n     - element (Element) The Element being searched for\n     = (boolean) Indicates if the element or CSS selector was previously passed to interact\n    \\*/\n    interact.isSet = function(element, options) {\n        return interactables.indexOfElement(element, options && options.context) !== -1;\n    };\n\n    /*\\\n     * interact.on\n     [ method ]\n     *\n     * Adds a global listener for an InteractEvent or adds a DOM event to\n     * `document`\n     *\n     - type       (string | array | object) The types of events to listen for\n     - listener   (function) The function to be called on the given event(s)\n     - useCapture (boolean) #optional useCapture flag for addEventListener\n     = (object) interact\n    \\*/\n    interact.on = function (type, listener, useCapture) {\n        if (isString(type) && type.search(' ') !== -1) {\n            type = type.trim().split(/ +/);\n        }\n\n        if (isArray(type)) {\n            for (var i = 0; i < type.length; i++) {\n                interact.on(type[i], listener, useCapture);\n            }\n\n            return interact;\n        }\n\n        if (isObject(type)) {\n            for (var prop in type) {\n                interact.on(prop, type[prop], listener);\n            }\n\n            return interact;\n        }\n\n        // if it is an InteractEvent type, add listener to globalEvents\n        if (contains(eventTypes, type)) {\n            // if this type of event was never bound\n            if (!globalEvents[type]) {\n                globalEvents[type] = [listener];\n            }\n            else {\n                globalEvents[type].push(listener);\n            }\n        }\n        // If non InteractEvent type, addEventListener to document\n        else {\n            events.add(document, type, listener, useCapture);\n        }\n\n        return interact;\n    };\n\n    /*\\\n     * interact.off\n     [ method ]\n     *\n     * Removes a global InteractEvent listener or DOM event from `document`\n     *\n     - type       (string | array | object) The types of events that were listened for\n     - listener   (function) The listener function to be removed\n     - useCapture (boolean) #optional useCapture flag for removeEventListener\n     = (object) interact\n     \\*/\n    interact.off = function (type, listener, useCapture) {\n        if (isString(type) && type.search(' ') !== -1) {\n            type = type.trim().split(/ +/);\n        }\n\n        if (isArray(type)) {\n            for (var i = 0; i < type.length; i++) {\n                interact.off(type[i], listener, useCapture);\n            }\n\n            return interact;\n        }\n\n        if (isObject(type)) {\n            for (var prop in type) {\n                interact.off(prop, type[prop], listener);\n            }\n\n            return interact;\n        }\n\n        if (!contains(eventTypes, type)) {\n            events.remove(document, type, listener, useCapture);\n        }\n        else {\n            var index;\n\n            if (type in globalEvents\n                && (index = indexOf(globalEvents[type], listener)) !== -1) {\n                globalEvents[type].splice(index, 1);\n            }\n        }\n\n        return interact;\n    };\n\n    /*\\\n     * interact.enableDragging\n     [ method ]\n     *\n     * Deprecated.\n     *\n     * Returns or sets whether dragging is enabled for any Interactables\n     *\n     - newValue (boolean) #optional `true` to allow the action; `false` to disable action for all Interactables\n     = (boolean | object) The current setting or interact\n    \\*/\n    interact.enableDragging = warnOnce(function (newValue) {\n        if (newValue !== null && newValue !== undefined) {\n            actionIsEnabled.drag = newValue;\n\n            return interact;\n        }\n        return actionIsEnabled.drag;\n    }, 'interact.enableDragging is deprecated and will soon be removed.');\n\n    /*\\\n     * interact.enableResizing\n     [ method ]\n     *\n     * Deprecated.\n     *\n     * Returns or sets whether resizing is enabled for any Interactables\n     *\n     - newValue (boolean) #optional `true` to allow the action; `false` to disable action for all Interactables\n     = (boolean | object) The current setting or interact\n    \\*/\n    interact.enableResizing = warnOnce(function (newValue) {\n        if (newValue !== null && newValue !== undefined) {\n            actionIsEnabled.resize = newValue;\n\n            return interact;\n        }\n        return actionIsEnabled.resize;\n    }, 'interact.enableResizing is deprecated and will soon be removed.');\n\n    /*\\\n     * interact.enableGesturing\n     [ method ]\n     *\n     * Deprecated.\n     *\n     * Returns or sets whether gesturing is enabled for any Interactables\n     *\n     - newValue (boolean) #optional `true` to allow the action; `false` to disable action for all Interactables\n     = (boolean | object) The current setting or interact\n    \\*/\n    interact.enableGesturing = warnOnce(function (newValue) {\n        if (newValue !== null && newValue !== undefined) {\n            actionIsEnabled.gesture = newValue;\n\n            return interact;\n        }\n        return actionIsEnabled.gesture;\n    }, 'interact.enableGesturing is deprecated and will soon be removed.');\n\n    interact.eventTypes = eventTypes;\n\n    /*\\\n     * interact.debug\n     [ method ]\n     *\n     * Returns debugging data\n     = (object) An object with properties that outline the current state and expose internal functions and variables\n    \\*/\n    interact.debug = function () {\n        var interaction = interactions[0] || new Interaction();\n\n        return {\n            interactions          : interactions,\n            target                : interaction.target,\n            dragging              : interaction.dragging,\n            resizing              : interaction.resizing,\n            gesturing             : interaction.gesturing,\n            prepared              : interaction.prepared,\n            matches               : interaction.matches,\n            matchElements         : interaction.matchElements,\n\n            prevCoords            : interaction.prevCoords,\n            startCoords           : interaction.startCoords,\n\n            pointerIds            : interaction.pointerIds,\n            pointers              : interaction.pointers,\n            addPointer            : listeners.addPointer,\n            removePointer         : listeners.removePointer,\n            recordPointer        : listeners.recordPointer,\n\n            snap                  : interaction.snapStatus,\n            restrict              : interaction.restrictStatus,\n            inertia               : interaction.inertiaStatus,\n\n            downTime              : interaction.downTimes[0],\n            downEvent             : interaction.downEvent,\n            downPointer           : interaction.downPointer,\n            prevEvent             : interaction.prevEvent,\n\n            Interactable          : Interactable,\n            interactables         : interactables,\n            pointerIsDown         : interaction.pointerIsDown,\n            defaultOptions        : defaultOptions,\n            defaultActionChecker  : defaultActionChecker,\n\n            actionCursors         : actionCursors,\n            dragMove              : listeners.dragMove,\n            resizeMove            : listeners.resizeMove,\n            gestureMove           : listeners.gestureMove,\n            pointerUp             : listeners.pointerUp,\n            pointerDown           : listeners.pointerDown,\n            pointerMove           : listeners.pointerMove,\n            pointerHover          : listeners.pointerHover,\n\n            eventTypes            : eventTypes,\n\n            events                : events,\n            globalEvents          : globalEvents,\n            delegatedEvents       : delegatedEvents,\n\n            prefixedPropREs       : prefixedPropREs\n        };\n    };\n\n    // expose the functions used to calculate multi-touch properties\n    interact.getPointerAverage = pointerAverage;\n    interact.getTouchBBox     = touchBBox;\n    interact.getTouchDistance = touchDistance;\n    interact.getTouchAngle    = touchAngle;\n\n    interact.getElementRect         = getElementRect;\n    interact.getElementClientRect   = getElementClientRect;\n    interact.matchesSelector        = matchesSelector;\n    interact.closest                = closest;\n\n    /*\\\n     * interact.margin\n     [ method ]\n     *\n     * Deprecated. Use `interact(target).resizable({ margin: number });` instead.\n     * Returns or sets the margin for autocheck resizing used in\n     * @Interactable.getAction. That is the distance from the bottom and right\n     * edges of an element clicking in which will start resizing\n     *\n     - newValue (number) #optional\n     = (number | interact) The current margin value or interact\n    \\*/\n    interact.margin = warnOnce(function (newvalue) {\n        if (isNumber(newvalue)) {\n            margin = newvalue;\n\n            return interact;\n        }\n        return margin;\n    },\n    'interact.margin is deprecated. Use interact(target).resizable({ margin: number }); instead.') ;\n\n    /*\\\n     * interact.supportsTouch\n     [ method ]\n     *\n     = (boolean) Whether or not the browser supports touch input\n    \\*/\n    interact.supportsTouch = function () {\n        return supportsTouch;\n    };\n\n    /*\\\n     * interact.supportsPointerEvent\n     [ method ]\n     *\n     = (boolean) Whether or not the browser supports PointerEvents\n    \\*/\n    interact.supportsPointerEvent = function () {\n        return supportsPointerEvent;\n    };\n\n    /*\\\n     * interact.stop\n     [ method ]\n     *\n     * Cancels all interactions (end events are not fired)\n     *\n     - event (Event) An event on which to call preventDefault()\n     = (object) interact\n    \\*/\n    interact.stop = function (event) {\n        for (var i = interactions.length - 1; i >= 0; i--) {\n            interactions[i].stop(event);\n        }\n\n        return interact;\n    };\n\n    /*\\\n     * interact.dynamicDrop\n     [ method ]\n     *\n     * Returns or sets whether the dimensions of dropzone elements are\n     * calculated on every dragmove or only on dragstart for the default\n     * dropChecker\n     *\n     - newValue (boolean) #optional True to check on each move. False to check only before start\n     = (boolean | interact) The current setting or interact\n    \\*/\n    interact.dynamicDrop = function (newValue) {\n        if (isBool(newValue)) {\n            //if (dragging && dynamicDrop !== newValue && !newValue) {\n                //calcRects(dropzones);\n            //}\n\n            dynamicDrop = newValue;\n\n            return interact;\n        }\n        return dynamicDrop;\n    };\n\n    /*\\\n     * interact.pointerMoveTolerance\n     [ method ]\n     * Returns or sets the distance the pointer must be moved before an action\n     * sequence occurs. This also affects tolerance for tap events.\n     *\n     - newValue (number) #optional The movement from the start position must be greater than this value\n     = (number | Interactable) The current setting or interact\n    \\*/\n    interact.pointerMoveTolerance = function (newValue) {\n        if (isNumber(newValue)) {\n            pointerMoveTolerance = newValue;\n\n            return this;\n        }\n\n        return pointerMoveTolerance;\n    };\n\n    /*\\\n     * interact.maxInteractions\n     [ method ]\n     **\n     * Returns or sets the maximum number of concurrent interactions allowed.\n     * By default only 1 interaction is allowed at a time (for backwards\n     * compatibility). To allow multiple interactions on the same Interactables\n     * and elements, you need to enable it in the draggable, resizable and\n     * gesturable `'max'` and `'maxPerElement'` options.\n     **\n     - newValue (number) #optional Any number. newValue <= 0 means no interactions.\n    \\*/\n    interact.maxInteractions = function (newValue) {\n        if (isNumber(newValue)) {\n            maxInteractions = newValue;\n\n            return this;\n        }\n\n        return maxInteractions;\n    };\n\n    interact.createSnapGrid = function (grid) {\n        return function (x, y) {\n            var offsetX = 0,\n                offsetY = 0;\n\n            if (isObject(grid.offset)) {\n                offsetX = grid.offset.x;\n                offsetY = grid.offset.y;\n            }\n\n            var gridx = Math.round((x - offsetX) / grid.x),\n                gridy = Math.round((y - offsetY) / grid.y),\n\n                newX = gridx * grid.x + offsetX,\n                newY = gridy * grid.y + offsetY;\n\n            return {\n                x: newX,\n                y: newY,\n                range: grid.range\n            };\n        };\n    };\n\n    function endAllInteractions (event) {\n        for (var i = 0; i < interactions.length; i++) {\n            interactions[i].pointerEnd(event, event);\n        }\n    }\n\n    function listenToDocument (doc) {\n        if (contains(documents, doc)) { return; }\n\n        var win = doc.defaultView || doc.parentWindow;\n\n        // add delegate event listener\n        for (var eventType in delegatedEvents) {\n            events.add(doc, eventType, delegateListener);\n            events.add(doc, eventType, delegateUseCapture, true);\n        }\n\n        if (supportsPointerEvent) {\n            if (PointerEvent === win.MSPointerEvent) {\n                pEventTypes = {\n                    up: 'MSPointerUp', down: 'MSPointerDown', over: 'mouseover',\n                    out: 'mouseout', move: 'MSPointerMove', cancel: 'MSPointerCancel' };\n            }\n            else {\n                pEventTypes = {\n                    up: 'pointerup', down: 'pointerdown', over: 'pointerover',\n                    out: 'pointerout', move: 'pointermove', cancel: 'pointercancel' };\n            }\n\n            events.add(doc, pEventTypes.down  , listeners.selectorDown );\n            events.add(doc, pEventTypes.move  , listeners.pointerMove  );\n            events.add(doc, pEventTypes.over  , listeners.pointerOver  );\n            events.add(doc, pEventTypes.out   , listeners.pointerOut   );\n            events.add(doc, pEventTypes.up    , listeners.pointerUp    );\n            events.add(doc, pEventTypes.cancel, listeners.pointerCancel);\n\n            // autoscroll\n            events.add(doc, pEventTypes.move, listeners.autoScrollMove);\n        }\n        else {\n            events.add(doc, 'mousedown', listeners.selectorDown);\n            events.add(doc, 'mousemove', listeners.pointerMove );\n            events.add(doc, 'mouseup'  , listeners.pointerUp   );\n            events.add(doc, 'mouseover', listeners.pointerOver );\n            events.add(doc, 'mouseout' , listeners.pointerOut  );\n\n            events.add(doc, 'touchstart' , listeners.selectorDown );\n            events.add(doc, 'touchmove'  , listeners.pointerMove  );\n            events.add(doc, 'touchend'   , listeners.pointerUp    );\n            events.add(doc, 'touchcancel', listeners.pointerCancel);\n\n            // autoscroll\n            events.add(doc, 'mousemove', listeners.autoScrollMove);\n            events.add(doc, 'touchmove', listeners.autoScrollMove);\n        }\n\n        events.add(win, 'blur', endAllInteractions);\n\n        try {\n            if (win.frameElement) {\n                var parentDoc = win.frameElement.ownerDocument,\n                    parentWindow = parentDoc.defaultView;\n\n                events.add(parentDoc   , 'mouseup'      , listeners.pointerEnd);\n                events.add(parentDoc   , 'touchend'     , listeners.pointerEnd);\n                events.add(parentDoc   , 'touchcancel'  , listeners.pointerEnd);\n                events.add(parentDoc   , 'pointerup'    , listeners.pointerEnd);\n                events.add(parentDoc   , 'MSPointerUp'  , listeners.pointerEnd);\n                events.add(parentWindow, 'blur'         , endAllInteractions );\n            }\n        }\n        catch (error) {\n            interact.windowParentError = error;\n        }\n\n        // prevent native HTML5 drag on interact.js target elements\n        events.add(doc, 'dragstart', function (event) {\n            for (var i = 0; i < interactions.length; i++) {\n                var interaction = interactions[i];\n\n                if (interaction.element\n                    && (interaction.element === event.target\n                        || nodeContains(interaction.element, event.target))) {\n\n                    interaction.checkAndPreventDefault(event, interaction.target, interaction.element);\n                    return;\n                }\n            }\n        });\n\n        if (events.useAttachEvent) {\n            // For IE's lack of Event#preventDefault\n            events.add(doc, 'selectstart', function (event) {\n                var interaction = interactions[0];\n\n                if (interaction.currentAction()) {\n                    interaction.checkAndPreventDefault(event);\n                }\n            });\n\n            // For IE's bad dblclick event sequence\n            events.add(doc, 'dblclick', doOnInteractions('ie8Dblclick'));\n        }\n\n        documents.push(doc);\n    }\n\n    listenToDocument(document);\n\n    function indexOf (array, target) {\n        for (var i = 0, len = array.length; i < len; i++) {\n            if (array[i] === target) {\n                return i;\n            }\n        }\n\n        return -1;\n    }\n\n    function contains (array, target) {\n        return indexOf(array, target) !== -1;\n    }\n\n    function matchesSelector (element, selector, nodeList) {\n        if (ie8MatchesSelector) {\n            return ie8MatchesSelector(element, selector, nodeList);\n        }\n\n        // remove /deep/ from selectors if shadowDOM polyfill is used\n        if (window !== realWindow) {\n            selector = selector.replace(/\\/deep\\//g, ' ');\n        }\n\n        return element[prefixedMatchesSelector](selector);\n    }\n\n    function matchesUpTo (element, selector, limit) {\n        while (isElement(element)) {\n            if (matchesSelector(element, selector)) {\n                return true;\n            }\n\n            element = parentElement(element);\n\n            if (element === limit) {\n                return matchesSelector(element, selector);\n            }\n        }\n\n        return false;\n    }\n\n    // For IE8's lack of an Element#matchesSelector\n    // taken from http://tanalin.com/en/blog/2012/12/matches-selector-ie8/ and modified\n    if (!(prefixedMatchesSelector in Element.prototype) || !isFunction(Element.prototype[prefixedMatchesSelector])) {\n        ie8MatchesSelector = function (element, selector, elems) {\n            elems = elems || element.parentNode.querySelectorAll(selector);\n\n            for (var i = 0, len = elems.length; i < len; i++) {\n                if (elems[i] === element) {\n                    return true;\n                }\n            }\n\n            return false;\n        };\n    }\n\n    // requestAnimationFrame polyfill\n    (function() {\n        var lastTime = 0,\n            vendors = ['ms', 'moz', 'webkit', 'o'];\n\n        for(var x = 0; x < vendors.length && !realWindow.requestAnimationFrame; ++x) {\n            reqFrame = realWindow[vendors[x]+'RequestAnimationFrame'];\n            cancelFrame = realWindow[vendors[x]+'CancelAnimationFrame'] || realWindow[vendors[x]+'CancelRequestAnimationFrame'];\n        }\n\n        if (!reqFrame) {\n            reqFrame = function(callback) {\n                var currTime = new Date().getTime(),\n                    timeToCall = Math.max(0, 16 - (currTime - lastTime)),\n                    id = setTimeout(function() { callback(currTime + timeToCall); },\n                  timeToCall);\n                lastTime = currTime + timeToCall;\n                return id;\n            };\n        }\n\n        if (!cancelFrame) {\n            cancelFrame = function(id) {\n                clearTimeout(id);\n            };\n        }\n    }());\n\n    /* global exports: true, module, define */\n\n    // http://documentcloud.github.io/underscore/docs/underscore.html#section-11\n    if (typeof exports !== 'undefined') {\n        if (typeof module !== 'undefined' && module.exports) {\n            exports = module.exports = interact;\n        }\n        exports.interact = interact;\n    }\n    // AMD\n    else if (typeof define === 'function' && define.amd) {\n        define('interact', function() {\n            return interact;\n        });\n    }\n    else {\n        realWindow.interact = interact;\n    }\n\n} (typeof window === 'undefined'? undefined : window));\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/interact.js/interact.js\n// module id = 1\n// module chunks = 0"],"sourceRoot":""}